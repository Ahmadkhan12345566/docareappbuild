(window["webpackJsonp"]=window["webpackJsonp"]||[]).push([["chunk-2ca3b1a4"],{"0227":function(module,exports,__webpack_require__){eval('(function (global, factory) {\n   true ? factory(exports) :\n  undefined;\n}(this, function (exports) { \'use strict\';\n\n  var fp = typeof window !== "undefined" && window.flatpickr !== undefined\n      ? window.flatpickr\n      : {\n          l10ns: {}\n      };\n  var French = {\n      firstDayOfWeek: 1,\n      weekdays: {\n          shorthand: ["dim", "lun", "mar", "mer", "jeu", "ven", "sam"],\n          longhand: [\n              "dimanche",\n              "lundi",\n              "mardi",\n              "mercredi",\n              "jeudi",\n              "vendredi",\n              "samedi",\n          ]\n      },\n      months: {\n          shorthand: [\n              "janv",\n              "févr",\n              "mars",\n              "avr",\n              "mai",\n              "juin",\n              "juil",\n              "août",\n              "sept",\n              "oct",\n              "nov",\n              "déc",\n          ],\n          longhand: [\n              "janvier",\n              "février",\n              "mars",\n              "avril",\n              "mai",\n              "juin",\n              "juillet",\n              "août",\n              "septembre",\n              "octobre",\n              "novembre",\n              "décembre",\n          ]\n      },\n      ordinal: function (nth) {\n          if (nth > 1)\n              return "";\n          return "er";\n      },\n      rangeSeparator: " au ",\n      weekAbbreviation: "Sem",\n      scrollTitle: "Défiler pour augmenter la valeur",\n      toggleTitle: "Cliquer pour basculer",\n      time_24hr: true\n  };\n  fp.l10ns.fr = French;\n  var fr = fp.l10ns;\n\n  exports.French = French;\n  exports.default = fr;\n\n  Object.defineProperty(exports, \'__esModule\', { value: true });\n\n}));\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZmxhdHBpY2tyL2Rpc3QvbDEwbi9mci5qcz8wMjI3Il0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0EsRUFBRSxLQUE0RDtBQUM5RCxFQUFFLFNBQ2tEO0FBQ3BELENBQUMsMkJBQTJCOztBQUU1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsZ0RBQWdELGNBQWM7O0FBRTlELENBQUMiLCJmaWxlIjoiMDIyNy5qcyIsInNvdXJjZXNDb250ZW50IjpbIihmdW5jdGlvbiAoZ2xvYmFsLCBmYWN0b3J5KSB7XG4gIHR5cGVvZiBleHBvcnRzID09PSAnb2JqZWN0JyAmJiB0eXBlb2YgbW9kdWxlICE9PSAndW5kZWZpbmVkJyA/IGZhY3RvcnkoZXhwb3J0cykgOlxuICB0eXBlb2YgZGVmaW5lID09PSAnZnVuY3Rpb24nICYmIGRlZmluZS5hbWQgPyBkZWZpbmUoWydleHBvcnRzJ10sIGZhY3RvcnkpIDpcbiAgKGdsb2JhbCA9IGdsb2JhbCB8fCBzZWxmLCBmYWN0b3J5KGdsb2JhbC5mciA9IHt9KSk7XG59KHRoaXMsIGZ1bmN0aW9uIChleHBvcnRzKSB7ICd1c2Ugc3RyaWN0JztcblxuICB2YXIgZnAgPSB0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiICYmIHdpbmRvdy5mbGF0cGlja3IgIT09IHVuZGVmaW5lZFxuICAgICAgPyB3aW5kb3cuZmxhdHBpY2tyXG4gICAgICA6IHtcbiAgICAgICAgICBsMTBuczoge31cbiAgICAgIH07XG4gIHZhciBGcmVuY2ggPSB7XG4gICAgICBmaXJzdERheU9mV2VlazogMSxcbiAgICAgIHdlZWtkYXlzOiB7XG4gICAgICAgICAgc2hvcnRoYW5kOiBbXCJkaW1cIiwgXCJsdW5cIiwgXCJtYXJcIiwgXCJtZXJcIiwgXCJqZXVcIiwgXCJ2ZW5cIiwgXCJzYW1cIl0sXG4gICAgICAgICAgbG9uZ2hhbmQ6IFtcbiAgICAgICAgICAgICAgXCJkaW1hbmNoZVwiLFxuICAgICAgICAgICAgICBcImx1bmRpXCIsXG4gICAgICAgICAgICAgIFwibWFyZGlcIixcbiAgICAgICAgICAgICAgXCJtZXJjcmVkaVwiLFxuICAgICAgICAgICAgICBcImpldWRpXCIsXG4gICAgICAgICAgICAgIFwidmVuZHJlZGlcIixcbiAgICAgICAgICAgICAgXCJzYW1lZGlcIixcbiAgICAgICAgICBdXG4gICAgICB9LFxuICAgICAgbW9udGhzOiB7XG4gICAgICAgICAgc2hvcnRoYW5kOiBbXG4gICAgICAgICAgICAgIFwiamFudlwiLFxuICAgICAgICAgICAgICBcImbDqXZyXCIsXG4gICAgICAgICAgICAgIFwibWFyc1wiLFxuICAgICAgICAgICAgICBcImF2clwiLFxuICAgICAgICAgICAgICBcIm1haVwiLFxuICAgICAgICAgICAgICBcImp1aW5cIixcbiAgICAgICAgICAgICAgXCJqdWlsXCIsXG4gICAgICAgICAgICAgIFwiYW/Du3RcIixcbiAgICAgICAgICAgICAgXCJzZXB0XCIsXG4gICAgICAgICAgICAgIFwib2N0XCIsXG4gICAgICAgICAgICAgIFwibm92XCIsXG4gICAgICAgICAgICAgIFwiZMOpY1wiLFxuICAgICAgICAgIF0sXG4gICAgICAgICAgbG9uZ2hhbmQ6IFtcbiAgICAgICAgICAgICAgXCJqYW52aWVyXCIsXG4gICAgICAgICAgICAgIFwiZsOpdnJpZXJcIixcbiAgICAgICAgICAgICAgXCJtYXJzXCIsXG4gICAgICAgICAgICAgIFwiYXZyaWxcIixcbiAgICAgICAgICAgICAgXCJtYWlcIixcbiAgICAgICAgICAgICAgXCJqdWluXCIsXG4gICAgICAgICAgICAgIFwianVpbGxldFwiLFxuICAgICAgICAgICAgICBcImFvw7t0XCIsXG4gICAgICAgICAgICAgIFwic2VwdGVtYnJlXCIsXG4gICAgICAgICAgICAgIFwib2N0b2JyZVwiLFxuICAgICAgICAgICAgICBcIm5vdmVtYnJlXCIsXG4gICAgICAgICAgICAgIFwiZMOpY2VtYnJlXCIsXG4gICAgICAgICAgXVxuICAgICAgfSxcbiAgICAgIG9yZGluYWw6IGZ1bmN0aW9uIChudGgpIHtcbiAgICAgICAgICBpZiAobnRoID4gMSlcbiAgICAgICAgICAgICAgcmV0dXJuIFwiXCI7XG4gICAgICAgICAgcmV0dXJuIFwiZXJcIjtcbiAgICAgIH0sXG4gICAgICByYW5nZVNlcGFyYXRvcjogXCIgYXUgXCIsXG4gICAgICB3ZWVrQWJicmV2aWF0aW9uOiBcIlNlbVwiLFxuICAgICAgc2Nyb2xsVGl0bGU6IFwiRMOpZmlsZXIgcG91ciBhdWdtZW50ZXIgbGEgdmFsZXVyXCIsXG4gICAgICB0b2dnbGVUaXRsZTogXCJDbGlxdWVyIHBvdXIgYmFzY3VsZXJcIixcbiAgICAgIHRpbWVfMjRocjogdHJ1ZVxuICB9O1xuICBmcC5sMTBucy5mciA9IEZyZW5jaDtcbiAgdmFyIGZyID0gZnAubDEwbnM7XG5cbiAgZXhwb3J0cy5GcmVuY2ggPSBGcmVuY2g7XG4gIGV4cG9ydHMuZGVmYXVsdCA9IGZyO1xuXG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAnX19lc01vZHVsZScsIHsgdmFsdWU6IHRydWUgfSk7XG5cbn0pKTtcbiJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///0227\n')},"0cb2":function(module,exports,__webpack_require__){eval("var uncurryThis = __webpack_require__(\"e330\");\nvar toObject = __webpack_require__(\"7b0b\");\n\nvar floor = Math.floor;\nvar charAt = uncurryThis(''.charAt);\nvar replace = uncurryThis(''.replace);\nvar stringSlice = uncurryThis(''.slice);\nvar SUBSTITUTION_SYMBOLS = /\\$([$&'`]|\\d{1,2}|<[^>]*>)/g;\nvar SUBSTITUTION_SYMBOLS_NO_NAMED = /\\$([$&'`]|\\d{1,2})/g;\n\n// `GetSubstitution` abstract operation\n// https://tc39.es/ecma262/#sec-getsubstitution\nmodule.exports = function (matched, str, position, captures, namedCaptures, replacement) {\n  var tailPos = position + matched.length;\n  var m = captures.length;\n  var symbols = SUBSTITUTION_SYMBOLS_NO_NAMED;\n  if (namedCaptures !== undefined) {\n    namedCaptures = toObject(namedCaptures);\n    symbols = SUBSTITUTION_SYMBOLS;\n  }\n  return replace(replacement, symbols, function (match, ch) {\n    var capture;\n    switch (charAt(ch, 0)) {\n      case '$': return '$';\n      case '&': return matched;\n      case '`': return stringSlice(str, 0, position);\n      case \"'\": return stringSlice(str, tailPos);\n      case '<':\n        capture = namedCaptures[stringSlice(ch, 1, -1)];\n        break;\n      default: // \\d\\d?\n        var n = +ch;\n        if (n === 0) return match;\n        if (n > m) {\n          var f = floor(n / 10);\n          if (f === 0) return match;\n          if (f <= m) return captures[f - 1] === undefined ? charAt(ch, 1) : captures[f - 1] + charAt(ch, 1);\n          return match;\n        }\n        capture = captures[n - 1];\n    }\n    return capture === undefined ? '' : capture;\n  });\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvZ2V0LXN1YnN0aXR1dGlvbi5qcz8wY2IyIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBLGtCQUFrQixtQkFBTyxDQUFDLE1BQW9DO0FBQzlELGVBQWUsbUJBQU8sQ0FBQyxNQUF3Qjs7QUFFL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5Q0FBeUMsSUFBSTtBQUM3QyxrREFBa0QsSUFBSTs7QUFFdEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSCIsImZpbGUiOiIwY2IyLmpzIiwic291cmNlc0NvbnRlbnQiOlsidmFyIHVuY3VycnlUaGlzID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2Z1bmN0aW9uLXVuY3VycnktdGhpcycpO1xudmFyIHRvT2JqZWN0ID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL3RvLW9iamVjdCcpO1xuXG52YXIgZmxvb3IgPSBNYXRoLmZsb29yO1xudmFyIGNoYXJBdCA9IHVuY3VycnlUaGlzKCcnLmNoYXJBdCk7XG52YXIgcmVwbGFjZSA9IHVuY3VycnlUaGlzKCcnLnJlcGxhY2UpO1xudmFyIHN0cmluZ1NsaWNlID0gdW5jdXJyeVRoaXMoJycuc2xpY2UpO1xudmFyIFNVQlNUSVRVVElPTl9TWU1CT0xTID0gL1xcJChbJCYnYF18XFxkezEsMn18PFtePl0qPikvZztcbnZhciBTVUJTVElUVVRJT05fU1lNQk9MU19OT19OQU1FRCA9IC9cXCQoWyQmJ2BdfFxcZHsxLDJ9KS9nO1xuXG4vLyBgR2V0U3Vic3RpdHV0aW9uYCBhYnN0cmFjdCBvcGVyYXRpb25cbi8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtZ2V0c3Vic3RpdHV0aW9uXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChtYXRjaGVkLCBzdHIsIHBvc2l0aW9uLCBjYXB0dXJlcywgbmFtZWRDYXB0dXJlcywgcmVwbGFjZW1lbnQpIHtcbiAgdmFyIHRhaWxQb3MgPSBwb3NpdGlvbiArIG1hdGNoZWQubGVuZ3RoO1xuICB2YXIgbSA9IGNhcHR1cmVzLmxlbmd0aDtcbiAgdmFyIHN5bWJvbHMgPSBTVUJTVElUVVRJT05fU1lNQk9MU19OT19OQU1FRDtcbiAgaWYgKG5hbWVkQ2FwdHVyZXMgIT09IHVuZGVmaW5lZCkge1xuICAgIG5hbWVkQ2FwdHVyZXMgPSB0b09iamVjdChuYW1lZENhcHR1cmVzKTtcbiAgICBzeW1ib2xzID0gU1VCU1RJVFVUSU9OX1NZTUJPTFM7XG4gIH1cbiAgcmV0dXJuIHJlcGxhY2UocmVwbGFjZW1lbnQsIHN5bWJvbHMsIGZ1bmN0aW9uIChtYXRjaCwgY2gpIHtcbiAgICB2YXIgY2FwdHVyZTtcbiAgICBzd2l0Y2ggKGNoYXJBdChjaCwgMCkpIHtcbiAgICAgIGNhc2UgJyQnOiByZXR1cm4gJyQnO1xuICAgICAgY2FzZSAnJic6IHJldHVybiBtYXRjaGVkO1xuICAgICAgY2FzZSAnYCc6IHJldHVybiBzdHJpbmdTbGljZShzdHIsIDAsIHBvc2l0aW9uKTtcbiAgICAgIGNhc2UgXCInXCI6IHJldHVybiBzdHJpbmdTbGljZShzdHIsIHRhaWxQb3MpO1xuICAgICAgY2FzZSAnPCc6XG4gICAgICAgIGNhcHR1cmUgPSBuYW1lZENhcHR1cmVzW3N0cmluZ1NsaWNlKGNoLCAxLCAtMSldO1xuICAgICAgICBicmVhaztcbiAgICAgIGRlZmF1bHQ6IC8vIFxcZFxcZD9cbiAgICAgICAgdmFyIG4gPSArY2g7XG4gICAgICAgIGlmIChuID09PSAwKSByZXR1cm4gbWF0Y2g7XG4gICAgICAgIGlmIChuID4gbSkge1xuICAgICAgICAgIHZhciBmID0gZmxvb3IobiAvIDEwKTtcbiAgICAgICAgICBpZiAoZiA9PT0gMCkgcmV0dXJuIG1hdGNoO1xuICAgICAgICAgIGlmIChmIDw9IG0pIHJldHVybiBjYXB0dXJlc1tmIC0gMV0gPT09IHVuZGVmaW5lZCA/IGNoYXJBdChjaCwgMSkgOiBjYXB0dXJlc1tmIC0gMV0gKyBjaGFyQXQoY2gsIDEpO1xuICAgICAgICAgIHJldHVybiBtYXRjaDtcbiAgICAgICAgfVxuICAgICAgICBjYXB0dXJlID0gY2FwdHVyZXNbbiAtIDFdO1xuICAgIH1cbiAgICByZXR1cm4gY2FwdHVyZSA9PT0gdW5kZWZpbmVkID8gJycgOiBjYXB0dXJlO1xuICB9KTtcbn07XG4iXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///0cb2\n")},"1f76":function(module,__webpack_exports__,__webpack_require__){"use strict";eval('/* harmony import */ var _node_modules_mini_css_extract_plugin_dist_loader_js_ref_7_oneOf_1_0_node_modules_css_loader_dist_cjs_js_ref_7_oneOf_1_1_node_modules_vue_cli_service_node_modules_vue_loader_lib_loaders_stylePostLoader_js_node_modules_postcss_loader_src_index_js_ref_7_oneOf_1_2_node_modules_cache_loader_dist_cjs_js_ref_1_0_node_modules_vue_cli_service_node_modules_vue_loader_lib_index_js_vue_loader_options_Add_vue_vue_type_style_index_0_lang_css___WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("60d6");\n/* harmony import */ var _node_modules_mini_css_extract_plugin_dist_loader_js_ref_7_oneOf_1_0_node_modules_css_loader_dist_cjs_js_ref_7_oneOf_1_1_node_modules_vue_cli_service_node_modules_vue_loader_lib_loaders_stylePostLoader_js_node_modules_postcss_loader_src_index_js_ref_7_oneOf_1_2_node_modules_cache_loader_dist_cjs_js_ref_1_0_node_modules_vue_cli_service_node_modules_vue_loader_lib_index_js_vue_loader_options_Add_vue_vue_type_style_index_0_lang_css___WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_node_modules_mini_css_extract_plugin_dist_loader_js_ref_7_oneOf_1_0_node_modules_css_loader_dist_cjs_js_ref_7_oneOf_1_1_node_modules_vue_cli_service_node_modules_vue_loader_lib_loaders_stylePostLoader_js_node_modules_postcss_loader_src_index_js_ref_7_oneOf_1_2_node_modules_cache_loader_dist_cjs_js_ref_1_0_node_modules_vue_cli_service_node_modules_vue_loader_lib_index_js_vue_loader_options_Add_vue_vue_type_style_index_0_lang_css___WEBPACK_IMPORTED_MODULE_0__);\n/* unused harmony reexport * */\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvbW9kdWxlcy9hcHAvbW9kdWxlcy9zdXBlcmFkbWluL21vZHVsZXMvc3BlY2lhbGlzdC92aWV3cy9BZGQudnVlP2RkZDAiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7QUFBQTtBQUFBIiwiZmlsZSI6IjFmNzYuanMiLCJzb3VyY2VzQ29udGVudCI6WyJleHBvcnQgKiBmcm9tIFwiLSEuLi8uLi8uLi8uLi8uLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvbWluaS1jc3MtZXh0cmFjdC1wbHVnaW4vZGlzdC9sb2FkZXIuanM/P3JlZi0tNy1vbmVPZi0xLTAhLi4vLi4vLi4vLi4vLi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2Nzcy1sb2FkZXIvZGlzdC9janMuanM/P3JlZi0tNy1vbmVPZi0xLTEhLi4vLi4vLi4vLi4vLi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL0B2dWUvY2xpLXNlcnZpY2Uvbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvbGliL2xvYWRlcnMvc3R5bGVQb3N0TG9hZGVyLmpzIS4uLy4uLy4uLy4uLy4uLy4uLy4uLy4uL25vZGVfbW9kdWxlcy9wb3N0Y3NzLWxvYWRlci9zcmMvaW5kZXguanM/P3JlZi0tNy1vbmVPZi0xLTIhLi4vLi4vLi4vLi4vLi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2NhY2hlLWxvYWRlci9kaXN0L2Nqcy5qcz8/cmVmLS0xLTAhLi4vLi4vLi4vLi4vLi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL0B2dWUvY2xpLXNlcnZpY2Uvbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvbGliL2luZGV4LmpzPz92dWUtbG9hZGVyLW9wdGlvbnMhLi9BZGQudnVlP3Z1ZSZ0eXBlPXN0eWxlJmluZGV4PTAmbGFuZz1jc3MmXCIiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///1f76\n')},"2be5":function(module,exports,__webpack_require__){eval("// extracted by mini-css-extract-plugin//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZmxhdHBpY2tyL2Rpc3QvZmxhdHBpY2tyLm1pbi5jc3M/OTRkMyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQSIsImZpbGUiOiIyYmU1LmpzIiwic291cmNlc0NvbnRlbnQiOlsiLy8gZXh0cmFjdGVkIGJ5IG1pbmktY3NzLWV4dHJhY3QtcGx1Z2luIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///2be5\n")},"2ca0":function(module,exports,__webpack_require__){"use strict";eval('\nvar $ = __webpack_require__("23e7");\nvar uncurryThis = __webpack_require__("e330");\nvar getOwnPropertyDescriptor = __webpack_require__("06cf").f;\nvar toLength = __webpack_require__("50c4");\nvar toString = __webpack_require__("577e");\nvar notARegExp = __webpack_require__("5a34");\nvar requireObjectCoercible = __webpack_require__("1d80");\nvar correctIsRegExpLogic = __webpack_require__("ab13");\nvar IS_PURE = __webpack_require__("c430");\n\n// eslint-disable-next-line es/no-string-prototype-startswith -- safe\nvar un$StartsWith = uncurryThis(\'\'.startsWith);\nvar stringSlice = uncurryThis(\'\'.slice);\nvar min = Math.min;\n\nvar CORRECT_IS_REGEXP_LOGIC = correctIsRegExpLogic(\'startsWith\');\n// https://github.com/zloirock/core-js/pull/702\nvar MDN_POLYFILL_BUG = !IS_PURE && !CORRECT_IS_REGEXP_LOGIC && !!function () {\n  var descriptor = getOwnPropertyDescriptor(String.prototype, \'startsWith\');\n  return descriptor && !descriptor.writable;\n}();\n\n// `String.prototype.startsWith` method\n// https://tc39.es/ecma262/#sec-string.prototype.startswith\n$({ target: \'String\', proto: true, forced: !MDN_POLYFILL_BUG && !CORRECT_IS_REGEXP_LOGIC }, {\n  startsWith: function startsWith(searchString /* , position = 0 */) {\n    var that = toString(requireObjectCoercible(this));\n    notARegExp(searchString);\n    var index = toLength(min(arguments.length > 1 ? arguments[1] : undefined, that.length));\n    var search = toString(searchString);\n    return un$StartsWith\n      ? un$StartsWith(that, search, index)\n      : stringSlice(that, index, index + search.length) === search;\n  }\n});\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzLnN0cmluZy5zdGFydHMtd2l0aC5qcz8yY2EwIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFhO0FBQ2IsUUFBUSxtQkFBTyxDQUFDLE1BQXFCO0FBQ3JDLGtCQUFrQixtQkFBTyxDQUFDLE1BQW9DO0FBQzlELCtCQUErQixtQkFBTyxDQUFDLE1BQWlEO0FBQ3hGLGVBQWUsbUJBQU8sQ0FBQyxNQUF3QjtBQUMvQyxlQUFlLG1CQUFPLENBQUMsTUFBd0I7QUFDL0MsaUJBQWlCLG1CQUFPLENBQUMsTUFBMkI7QUFDcEQsNkJBQTZCLG1CQUFPLENBQUMsTUFBdUM7QUFDNUUsMkJBQTJCLG1CQUFPLENBQUMsTUFBc0M7QUFDekUsY0FBYyxtQkFBTyxDQUFDLE1BQXNCOztBQUU1QztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0EsR0FBRyx1RkFBdUY7QUFDMUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyIsImZpbGUiOiIyY2EwLmpzIiwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xudmFyICQgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvZXhwb3J0Jyk7XG52YXIgdW5jdXJyeVRoaXMgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvZnVuY3Rpb24tdW5jdXJyeS10aGlzJyk7XG52YXIgZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL29iamVjdC1nZXQtb3duLXByb3BlcnR5LWRlc2NyaXB0b3InKS5mO1xudmFyIHRvTGVuZ3RoID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL3RvLWxlbmd0aCcpO1xudmFyIHRvU3RyaW5nID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL3RvLXN0cmluZycpO1xudmFyIG5vdEFSZWdFeHAgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvbm90LWEtcmVnZXhwJyk7XG52YXIgcmVxdWlyZU9iamVjdENvZXJjaWJsZSA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9yZXF1aXJlLW9iamVjdC1jb2VyY2libGUnKTtcbnZhciBjb3JyZWN0SXNSZWdFeHBMb2dpYyA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9jb3JyZWN0LWlzLXJlZ2V4cC1sb2dpYycpO1xudmFyIElTX1BVUkUgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvaXMtcHVyZScpO1xuXG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgZXMvbm8tc3RyaW5nLXByb3RvdHlwZS1zdGFydHN3aXRoIC0tIHNhZmVcbnZhciB1biRTdGFydHNXaXRoID0gdW5jdXJyeVRoaXMoJycuc3RhcnRzV2l0aCk7XG52YXIgc3RyaW5nU2xpY2UgPSB1bmN1cnJ5VGhpcygnJy5zbGljZSk7XG52YXIgbWluID0gTWF0aC5taW47XG5cbnZhciBDT1JSRUNUX0lTX1JFR0VYUF9MT0dJQyA9IGNvcnJlY3RJc1JlZ0V4cExvZ2ljKCdzdGFydHNXaXRoJyk7XG4vLyBodHRwczovL2dpdGh1Yi5jb20vemxvaXJvY2svY29yZS1qcy9wdWxsLzcwMlxudmFyIE1ETl9QT0xZRklMTF9CVUcgPSAhSVNfUFVSRSAmJiAhQ09SUkVDVF9JU19SRUdFWFBfTE9HSUMgJiYgISFmdW5jdGlvbiAoKSB7XG4gIHZhciBkZXNjcmlwdG9yID0gZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKFN0cmluZy5wcm90b3R5cGUsICdzdGFydHNXaXRoJyk7XG4gIHJldHVybiBkZXNjcmlwdG9yICYmICFkZXNjcmlwdG9yLndyaXRhYmxlO1xufSgpO1xuXG4vLyBgU3RyaW5nLnByb3RvdHlwZS5zdGFydHNXaXRoYCBtZXRob2Rcbi8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtc3RyaW5nLnByb3RvdHlwZS5zdGFydHN3aXRoXG4kKHsgdGFyZ2V0OiAnU3RyaW5nJywgcHJvdG86IHRydWUsIGZvcmNlZDogIU1ETl9QT0xZRklMTF9CVUcgJiYgIUNPUlJFQ1RfSVNfUkVHRVhQX0xPR0lDIH0sIHtcbiAgc3RhcnRzV2l0aDogZnVuY3Rpb24gc3RhcnRzV2l0aChzZWFyY2hTdHJpbmcgLyogLCBwb3NpdGlvbiA9IDAgKi8pIHtcbiAgICB2YXIgdGhhdCA9IHRvU3RyaW5nKHJlcXVpcmVPYmplY3RDb2VyY2libGUodGhpcykpO1xuICAgIG5vdEFSZWdFeHAoc2VhcmNoU3RyaW5nKTtcbiAgICB2YXIgaW5kZXggPSB0b0xlbmd0aChtaW4oYXJndW1lbnRzLmxlbmd0aCA+IDEgPyBhcmd1bWVudHNbMV0gOiB1bmRlZmluZWQsIHRoYXQubGVuZ3RoKSk7XG4gICAgdmFyIHNlYXJjaCA9IHRvU3RyaW5nKHNlYXJjaFN0cmluZyk7XG4gICAgcmV0dXJuIHVuJFN0YXJ0c1dpdGhcbiAgICAgID8gdW4kU3RhcnRzV2l0aCh0aGF0LCBzZWFyY2gsIGluZGV4KVxuICAgICAgOiBzdHJpbmdTbGljZSh0aGF0LCBpbmRleCwgaW5kZXggKyBzZWFyY2gubGVuZ3RoKSA9PT0gc2VhcmNoO1xuICB9XG59KTtcbiJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///2ca0\n')},5319:function(module,exports,__webpack_require__){"use strict";eval("\nvar apply = __webpack_require__(\"2ba4\");\nvar call = __webpack_require__(\"c65b\");\nvar uncurryThis = __webpack_require__(\"e330\");\nvar fixRegExpWellKnownSymbolLogic = __webpack_require__(\"d784\");\nvar fails = __webpack_require__(\"d039\");\nvar anObject = __webpack_require__(\"825a\");\nvar isCallable = __webpack_require__(\"1626\");\nvar toIntegerOrInfinity = __webpack_require__(\"5926\");\nvar toLength = __webpack_require__(\"50c4\");\nvar toString = __webpack_require__(\"577e\");\nvar requireObjectCoercible = __webpack_require__(\"1d80\");\nvar advanceStringIndex = __webpack_require__(\"8aa5\");\nvar getMethod = __webpack_require__(\"dc4a\");\nvar getSubstitution = __webpack_require__(\"0cb2\");\nvar regExpExec = __webpack_require__(\"14c3\");\nvar wellKnownSymbol = __webpack_require__(\"b622\");\n\nvar REPLACE = wellKnownSymbol('replace');\nvar max = Math.max;\nvar min = Math.min;\nvar concat = uncurryThis([].concat);\nvar push = uncurryThis([].push);\nvar stringIndexOf = uncurryThis(''.indexOf);\nvar stringSlice = uncurryThis(''.slice);\n\nvar maybeToString = function (it) {\n  return it === undefined ? it : String(it);\n};\n\n// IE <= 11 replaces $0 with the whole match, as if it was $&\n// https://stackoverflow.com/questions/6024666/getting-ie-to-replace-a-regex-with-the-literal-string-0\nvar REPLACE_KEEPS_$0 = (function () {\n  // eslint-disable-next-line regexp/prefer-escape-replacement-dollar-char -- required for testing\n  return 'a'.replace(/./, '$0') === '$0';\n})();\n\n// Safari <= 13.0.3(?) substitutes nth capture where n>m with an empty string\nvar REGEXP_REPLACE_SUBSTITUTES_UNDEFINED_CAPTURE = (function () {\n  if (/./[REPLACE]) {\n    return /./[REPLACE]('a', '$0') === '';\n  }\n  return false;\n})();\n\nvar REPLACE_SUPPORTS_NAMED_GROUPS = !fails(function () {\n  var re = /./;\n  re.exec = function () {\n    var result = [];\n    result.groups = { a: '7' };\n    return result;\n  };\n  // eslint-disable-next-line regexp/no-useless-dollar-replacements -- false positive\n  return ''.replace(re, '$<a>') !== '7';\n});\n\n// @@replace logic\nfixRegExpWellKnownSymbolLogic('replace', function (_, nativeReplace, maybeCallNative) {\n  var UNSAFE_SUBSTITUTE = REGEXP_REPLACE_SUBSTITUTES_UNDEFINED_CAPTURE ? '$' : '$0';\n\n  return [\n    // `String.prototype.replace` method\n    // https://tc39.es/ecma262/#sec-string.prototype.replace\n    function replace(searchValue, replaceValue) {\n      var O = requireObjectCoercible(this);\n      var replacer = searchValue == undefined ? undefined : getMethod(searchValue, REPLACE);\n      return replacer\n        ? call(replacer, searchValue, O, replaceValue)\n        : call(nativeReplace, toString(O), searchValue, replaceValue);\n    },\n    // `RegExp.prototype[@@replace]` method\n    // https://tc39.es/ecma262/#sec-regexp.prototype-@@replace\n    function (string, replaceValue) {\n      var rx = anObject(this);\n      var S = toString(string);\n\n      if (\n        typeof replaceValue == 'string' &&\n        stringIndexOf(replaceValue, UNSAFE_SUBSTITUTE) === -1 &&\n        stringIndexOf(replaceValue, '$<') === -1\n      ) {\n        var res = maybeCallNative(nativeReplace, rx, S, replaceValue);\n        if (res.done) return res.value;\n      }\n\n      var functionalReplace = isCallable(replaceValue);\n      if (!functionalReplace) replaceValue = toString(replaceValue);\n\n      var global = rx.global;\n      if (global) {\n        var fullUnicode = rx.unicode;\n        rx.lastIndex = 0;\n      }\n      var results = [];\n      while (true) {\n        var result = regExpExec(rx, S);\n        if (result === null) break;\n\n        push(results, result);\n        if (!global) break;\n\n        var matchStr = toString(result[0]);\n        if (matchStr === '') rx.lastIndex = advanceStringIndex(S, toLength(rx.lastIndex), fullUnicode);\n      }\n\n      var accumulatedResult = '';\n      var nextSourcePosition = 0;\n      for (var i = 0; i < results.length; i++) {\n        result = results[i];\n\n        var matched = toString(result[0]);\n        var position = max(min(toIntegerOrInfinity(result.index), S.length), 0);\n        var captures = [];\n        // NOTE: This is equivalent to\n        //   captures = result.slice(1).map(maybeToString)\n        // but for some reason `nativeSlice.call(result, 1, result.length)` (called in\n        // the slice polyfill when slicing native arrays) \"doesn't work\" in safari 9 and\n        // causes a crash (https://pastebin.com/N21QzeQA) when trying to debug it.\n        for (var j = 1; j < result.length; j++) push(captures, maybeToString(result[j]));\n        var namedCaptures = result.groups;\n        if (functionalReplace) {\n          var replacerArgs = concat([matched], captures, position, S);\n          if (namedCaptures !== undefined) push(replacerArgs, namedCaptures);\n          var replacement = toString(apply(replaceValue, undefined, replacerArgs));\n        } else {\n          replacement = getSubstitution(matched, S, position, captures, namedCaptures, replaceValue);\n        }\n        if (position >= nextSourcePosition) {\n          accumulatedResult += stringSlice(S, nextSourcePosition, position) + replacement;\n          nextSourcePosition = position + matched.length;\n        }\n      }\n      return accumulatedResult + stringSlice(S, nextSourcePosition);\n    }\n  ];\n}, !REPLACE_SUPPORTS_NAMED_GROUPS || !REPLACE_KEEPS_$0 || REGEXP_REPLACE_SUBSTITUTES_UNDEFINED_CAPTURE);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzLnN0cmluZy5yZXBsYWNlLmpzPzUzMTkiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQWE7QUFDYixZQUFZLG1CQUFPLENBQUMsTUFBNkI7QUFDakQsV0FBVyxtQkFBTyxDQUFDLE1BQTRCO0FBQy9DLGtCQUFrQixtQkFBTyxDQUFDLE1BQW9DO0FBQzlELG9DQUFvQyxtQkFBTyxDQUFDLE1BQWlEO0FBQzdGLFlBQVksbUJBQU8sQ0FBQyxNQUFvQjtBQUN4QyxlQUFlLG1CQUFPLENBQUMsTUFBd0I7QUFDL0MsaUJBQWlCLG1CQUFPLENBQUMsTUFBMEI7QUFDbkQsMEJBQTBCLG1CQUFPLENBQUMsTUFBcUM7QUFDdkUsZUFBZSxtQkFBTyxDQUFDLE1BQXdCO0FBQy9DLGVBQWUsbUJBQU8sQ0FBQyxNQUF3QjtBQUMvQyw2QkFBNkIsbUJBQU8sQ0FBQyxNQUF1QztBQUM1RSx5QkFBeUIsbUJBQU8sQ0FBQyxNQUFtQztBQUNwRSxnQkFBZ0IsbUJBQU8sQ0FBQyxNQUF5QjtBQUNqRCxzQkFBc0IsbUJBQU8sQ0FBQyxNQUErQjtBQUM3RCxpQkFBaUIsbUJBQU8sQ0FBQyxNQUFtQztBQUM1RCxzQkFBc0IsbUJBQU8sQ0FBQyxNQUFnQzs7QUFFOUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxxQkFBcUIsb0JBQW9CO0FBQ3pDOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsbUJBQW1CO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDIiwiZmlsZSI6IjUzMTkuanMiLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG52YXIgYXBwbHkgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvZnVuY3Rpb24tYXBwbHknKTtcbnZhciBjYWxsID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2Z1bmN0aW9uLWNhbGwnKTtcbnZhciB1bmN1cnJ5VGhpcyA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9mdW5jdGlvbi11bmN1cnJ5LXRoaXMnKTtcbnZhciBmaXhSZWdFeHBXZWxsS25vd25TeW1ib2xMb2dpYyA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9maXgtcmVnZXhwLXdlbGwta25vd24tc3ltYm9sLWxvZ2ljJyk7XG52YXIgZmFpbHMgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvZmFpbHMnKTtcbnZhciBhbk9iamVjdCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9hbi1vYmplY3QnKTtcbnZhciBpc0NhbGxhYmxlID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2lzLWNhbGxhYmxlJyk7XG52YXIgdG9JbnRlZ2VyT3JJbmZpbml0eSA9IHJlcXVpcmUoJy4uL2ludGVybmFscy90by1pbnRlZ2VyLW9yLWluZmluaXR5Jyk7XG52YXIgdG9MZW5ndGggPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvdG8tbGVuZ3RoJyk7XG52YXIgdG9TdHJpbmcgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvdG8tc3RyaW5nJyk7XG52YXIgcmVxdWlyZU9iamVjdENvZXJjaWJsZSA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9yZXF1aXJlLW9iamVjdC1jb2VyY2libGUnKTtcbnZhciBhZHZhbmNlU3RyaW5nSW5kZXggPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvYWR2YW5jZS1zdHJpbmctaW5kZXgnKTtcbnZhciBnZXRNZXRob2QgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvZ2V0LW1ldGhvZCcpO1xudmFyIGdldFN1YnN0aXR1dGlvbiA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9nZXQtc3Vic3RpdHV0aW9uJyk7XG52YXIgcmVnRXhwRXhlYyA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9yZWdleHAtZXhlYy1hYnN0cmFjdCcpO1xudmFyIHdlbGxLbm93blN5bWJvbCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy93ZWxsLWtub3duLXN5bWJvbCcpO1xuXG52YXIgUkVQTEFDRSA9IHdlbGxLbm93blN5bWJvbCgncmVwbGFjZScpO1xudmFyIG1heCA9IE1hdGgubWF4O1xudmFyIG1pbiA9IE1hdGgubWluO1xudmFyIGNvbmNhdCA9IHVuY3VycnlUaGlzKFtdLmNvbmNhdCk7XG52YXIgcHVzaCA9IHVuY3VycnlUaGlzKFtdLnB1c2gpO1xudmFyIHN0cmluZ0luZGV4T2YgPSB1bmN1cnJ5VGhpcygnJy5pbmRleE9mKTtcbnZhciBzdHJpbmdTbGljZSA9IHVuY3VycnlUaGlzKCcnLnNsaWNlKTtcblxudmFyIG1heWJlVG9TdHJpbmcgPSBmdW5jdGlvbiAoaXQpIHtcbiAgcmV0dXJuIGl0ID09PSB1bmRlZmluZWQgPyBpdCA6IFN0cmluZyhpdCk7XG59O1xuXG4vLyBJRSA8PSAxMSByZXBsYWNlcyAkMCB3aXRoIHRoZSB3aG9sZSBtYXRjaCwgYXMgaWYgaXQgd2FzICQmXG4vLyBodHRwczovL3N0YWNrb3ZlcmZsb3cuY29tL3F1ZXN0aW9ucy82MDI0NjY2L2dldHRpbmctaWUtdG8tcmVwbGFjZS1hLXJlZ2V4LXdpdGgtdGhlLWxpdGVyYWwtc3RyaW5nLTBcbnZhciBSRVBMQUNFX0tFRVBTXyQwID0gKGZ1bmN0aW9uICgpIHtcbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIHJlZ2V4cC9wcmVmZXItZXNjYXBlLXJlcGxhY2VtZW50LWRvbGxhci1jaGFyIC0tIHJlcXVpcmVkIGZvciB0ZXN0aW5nXG4gIHJldHVybiAnYScucmVwbGFjZSgvLi8sICckMCcpID09PSAnJDAnO1xufSkoKTtcblxuLy8gU2FmYXJpIDw9IDEzLjAuMyg/KSBzdWJzdGl0dXRlcyBudGggY2FwdHVyZSB3aGVyZSBuPm0gd2l0aCBhbiBlbXB0eSBzdHJpbmdcbnZhciBSRUdFWFBfUkVQTEFDRV9TVUJTVElUVVRFU19VTkRFRklORURfQ0FQVFVSRSA9IChmdW5jdGlvbiAoKSB7XG4gIGlmICgvLi9bUkVQTEFDRV0pIHtcbiAgICByZXR1cm4gLy4vW1JFUExBQ0VdKCdhJywgJyQwJykgPT09ICcnO1xuICB9XG4gIHJldHVybiBmYWxzZTtcbn0pKCk7XG5cbnZhciBSRVBMQUNFX1NVUFBPUlRTX05BTUVEX0dST1VQUyA9ICFmYWlscyhmdW5jdGlvbiAoKSB7XG4gIHZhciByZSA9IC8uLztcbiAgcmUuZXhlYyA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgcmVzdWx0ID0gW107XG4gICAgcmVzdWx0Lmdyb3VwcyA9IHsgYTogJzcnIH07XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfTtcbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIHJlZ2V4cC9uby11c2VsZXNzLWRvbGxhci1yZXBsYWNlbWVudHMgLS0gZmFsc2UgcG9zaXRpdmVcbiAgcmV0dXJuICcnLnJlcGxhY2UocmUsICckPGE+JykgIT09ICc3Jztcbn0pO1xuXG4vLyBAQHJlcGxhY2UgbG9naWNcbmZpeFJlZ0V4cFdlbGxLbm93blN5bWJvbExvZ2ljKCdyZXBsYWNlJywgZnVuY3Rpb24gKF8sIG5hdGl2ZVJlcGxhY2UsIG1heWJlQ2FsbE5hdGl2ZSkge1xuICB2YXIgVU5TQUZFX1NVQlNUSVRVVEUgPSBSRUdFWFBfUkVQTEFDRV9TVUJTVElUVVRFU19VTkRFRklORURfQ0FQVFVSRSA/ICckJyA6ICckMCc7XG5cbiAgcmV0dXJuIFtcbiAgICAvLyBgU3RyaW5nLnByb3RvdHlwZS5yZXBsYWNlYCBtZXRob2RcbiAgICAvLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLXN0cmluZy5wcm90b3R5cGUucmVwbGFjZVxuICAgIGZ1bmN0aW9uIHJlcGxhY2Uoc2VhcmNoVmFsdWUsIHJlcGxhY2VWYWx1ZSkge1xuICAgICAgdmFyIE8gPSByZXF1aXJlT2JqZWN0Q29lcmNpYmxlKHRoaXMpO1xuICAgICAgdmFyIHJlcGxhY2VyID0gc2VhcmNoVmFsdWUgPT0gdW5kZWZpbmVkID8gdW5kZWZpbmVkIDogZ2V0TWV0aG9kKHNlYXJjaFZhbHVlLCBSRVBMQUNFKTtcbiAgICAgIHJldHVybiByZXBsYWNlclxuICAgICAgICA/IGNhbGwocmVwbGFjZXIsIHNlYXJjaFZhbHVlLCBPLCByZXBsYWNlVmFsdWUpXG4gICAgICAgIDogY2FsbChuYXRpdmVSZXBsYWNlLCB0b1N0cmluZyhPKSwgc2VhcmNoVmFsdWUsIHJlcGxhY2VWYWx1ZSk7XG4gICAgfSxcbiAgICAvLyBgUmVnRXhwLnByb3RvdHlwZVtAQHJlcGxhY2VdYCBtZXRob2RcbiAgICAvLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLXJlZ2V4cC5wcm90b3R5cGUtQEByZXBsYWNlXG4gICAgZnVuY3Rpb24gKHN0cmluZywgcmVwbGFjZVZhbHVlKSB7XG4gICAgICB2YXIgcnggPSBhbk9iamVjdCh0aGlzKTtcbiAgICAgIHZhciBTID0gdG9TdHJpbmcoc3RyaW5nKTtcblxuICAgICAgaWYgKFxuICAgICAgICB0eXBlb2YgcmVwbGFjZVZhbHVlID09ICdzdHJpbmcnICYmXG4gICAgICAgIHN0cmluZ0luZGV4T2YocmVwbGFjZVZhbHVlLCBVTlNBRkVfU1VCU1RJVFVURSkgPT09IC0xICYmXG4gICAgICAgIHN0cmluZ0luZGV4T2YocmVwbGFjZVZhbHVlLCAnJDwnKSA9PT0gLTFcbiAgICAgICkge1xuICAgICAgICB2YXIgcmVzID0gbWF5YmVDYWxsTmF0aXZlKG5hdGl2ZVJlcGxhY2UsIHJ4LCBTLCByZXBsYWNlVmFsdWUpO1xuICAgICAgICBpZiAocmVzLmRvbmUpIHJldHVybiByZXMudmFsdWU7XG4gICAgICB9XG5cbiAgICAgIHZhciBmdW5jdGlvbmFsUmVwbGFjZSA9IGlzQ2FsbGFibGUocmVwbGFjZVZhbHVlKTtcbiAgICAgIGlmICghZnVuY3Rpb25hbFJlcGxhY2UpIHJlcGxhY2VWYWx1ZSA9IHRvU3RyaW5nKHJlcGxhY2VWYWx1ZSk7XG5cbiAgICAgIHZhciBnbG9iYWwgPSByeC5nbG9iYWw7XG4gICAgICBpZiAoZ2xvYmFsKSB7XG4gICAgICAgIHZhciBmdWxsVW5pY29kZSA9IHJ4LnVuaWNvZGU7XG4gICAgICAgIHJ4Lmxhc3RJbmRleCA9IDA7XG4gICAgICB9XG4gICAgICB2YXIgcmVzdWx0cyA9IFtdO1xuICAgICAgd2hpbGUgKHRydWUpIHtcbiAgICAgICAgdmFyIHJlc3VsdCA9IHJlZ0V4cEV4ZWMocngsIFMpO1xuICAgICAgICBpZiAocmVzdWx0ID09PSBudWxsKSBicmVhaztcblxuICAgICAgICBwdXNoKHJlc3VsdHMsIHJlc3VsdCk7XG4gICAgICAgIGlmICghZ2xvYmFsKSBicmVhaztcblxuICAgICAgICB2YXIgbWF0Y2hTdHIgPSB0b1N0cmluZyhyZXN1bHRbMF0pO1xuICAgICAgICBpZiAobWF0Y2hTdHIgPT09ICcnKSByeC5sYXN0SW5kZXggPSBhZHZhbmNlU3RyaW5nSW5kZXgoUywgdG9MZW5ndGgocngubGFzdEluZGV4KSwgZnVsbFVuaWNvZGUpO1xuICAgICAgfVxuXG4gICAgICB2YXIgYWNjdW11bGF0ZWRSZXN1bHQgPSAnJztcbiAgICAgIHZhciBuZXh0U291cmNlUG9zaXRpb24gPSAwO1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCByZXN1bHRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHJlc3VsdCA9IHJlc3VsdHNbaV07XG5cbiAgICAgICAgdmFyIG1hdGNoZWQgPSB0b1N0cmluZyhyZXN1bHRbMF0pO1xuICAgICAgICB2YXIgcG9zaXRpb24gPSBtYXgobWluKHRvSW50ZWdlck9ySW5maW5pdHkocmVzdWx0LmluZGV4KSwgUy5sZW5ndGgpLCAwKTtcbiAgICAgICAgdmFyIGNhcHR1cmVzID0gW107XG4gICAgICAgIC8vIE5PVEU6IFRoaXMgaXMgZXF1aXZhbGVudCB0b1xuICAgICAgICAvLyAgIGNhcHR1cmVzID0gcmVzdWx0LnNsaWNlKDEpLm1hcChtYXliZVRvU3RyaW5nKVxuICAgICAgICAvLyBidXQgZm9yIHNvbWUgcmVhc29uIGBuYXRpdmVTbGljZS5jYWxsKHJlc3VsdCwgMSwgcmVzdWx0Lmxlbmd0aClgIChjYWxsZWQgaW5cbiAgICAgICAgLy8gdGhlIHNsaWNlIHBvbHlmaWxsIHdoZW4gc2xpY2luZyBuYXRpdmUgYXJyYXlzKSBcImRvZXNuJ3Qgd29ya1wiIGluIHNhZmFyaSA5IGFuZFxuICAgICAgICAvLyBjYXVzZXMgYSBjcmFzaCAoaHR0cHM6Ly9wYXN0ZWJpbi5jb20vTjIxUXplUUEpIHdoZW4gdHJ5aW5nIHRvIGRlYnVnIGl0LlxuICAgICAgICBmb3IgKHZhciBqID0gMTsgaiA8IHJlc3VsdC5sZW5ndGg7IGorKykgcHVzaChjYXB0dXJlcywgbWF5YmVUb1N0cmluZyhyZXN1bHRbal0pKTtcbiAgICAgICAgdmFyIG5hbWVkQ2FwdHVyZXMgPSByZXN1bHQuZ3JvdXBzO1xuICAgICAgICBpZiAoZnVuY3Rpb25hbFJlcGxhY2UpIHtcbiAgICAgICAgICB2YXIgcmVwbGFjZXJBcmdzID0gY29uY2F0KFttYXRjaGVkXSwgY2FwdHVyZXMsIHBvc2l0aW9uLCBTKTtcbiAgICAgICAgICBpZiAobmFtZWRDYXB0dXJlcyAhPT0gdW5kZWZpbmVkKSBwdXNoKHJlcGxhY2VyQXJncywgbmFtZWRDYXB0dXJlcyk7XG4gICAgICAgICAgdmFyIHJlcGxhY2VtZW50ID0gdG9TdHJpbmcoYXBwbHkocmVwbGFjZVZhbHVlLCB1bmRlZmluZWQsIHJlcGxhY2VyQXJncykpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJlcGxhY2VtZW50ID0gZ2V0U3Vic3RpdHV0aW9uKG1hdGNoZWQsIFMsIHBvc2l0aW9uLCBjYXB0dXJlcywgbmFtZWRDYXB0dXJlcywgcmVwbGFjZVZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAocG9zaXRpb24gPj0gbmV4dFNvdXJjZVBvc2l0aW9uKSB7XG4gICAgICAgICAgYWNjdW11bGF0ZWRSZXN1bHQgKz0gc3RyaW5nU2xpY2UoUywgbmV4dFNvdXJjZVBvc2l0aW9uLCBwb3NpdGlvbikgKyByZXBsYWNlbWVudDtcbiAgICAgICAgICBuZXh0U291cmNlUG9zaXRpb24gPSBwb3NpdGlvbiArIG1hdGNoZWQubGVuZ3RoO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gYWNjdW11bGF0ZWRSZXN1bHQgKyBzdHJpbmdTbGljZShTLCBuZXh0U291cmNlUG9zaXRpb24pO1xuICAgIH1cbiAgXTtcbn0sICFSRVBMQUNFX1NVUFBPUlRTX05BTUVEX0dST1VQUyB8fCAhUkVQTEFDRV9LRUVQU18kMCB8fCBSRUdFWFBfUkVQTEFDRV9TVUJTVElUVVRFU19VTkRFRklORURfQ0FQVFVSRSk7XG4iXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///5319\n")},"60d6":function(module,exports,__webpack_require__){eval("// extracted by mini-css-extract-plugin//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvbW9kdWxlcy9hcHAvbW9kdWxlcy9zdXBlcmFkbWluL21vZHVsZXMvc3BlY2lhbGlzdC92aWV3cy9BZGQudnVlP2VjOGEiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUEiLCJmaWxlIjoiNjBkNi5qcyIsInNvdXJjZXNDb250ZW50IjpbIi8vIGV4dHJhY3RlZCBieSBtaW5pLWNzcy1leHRyYWN0LXBsdWdpbiJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///60d6\n")},8758:function(module,__webpack_exports__,__webpack_require__){"use strict";eval('// ESM COMPAT FLAG\n__webpack_require__.r(__webpack_exports__);\n\n// CONCATENATED MODULE: ./node_modules/cache-loader/dist/cjs.js?{"cacheDirectory":"node_modules/.cache/vue-loader","cacheIdentifier":"5f77683a-vue-loader-template"}!./node_modules/@vue/cli-service/node_modules/vue-loader/lib/loaders/templateLoader.js??vue-loader-options!./node_modules/cache-loader/dist/cjs.js??ref--1-0!./node_modules/@vue/cli-service/node_modules/vue-loader/lib??vue-loader-options!./src/modules/app/modules/superadmin/modules/specialist/views/Add.vue?vue&type=template&id=08c49d7f&\nvar render = function () {var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;return _c(\'div\',[_c(\'div\',{staticClass:"ajax-loader"},[_c(\'svg\',{staticStyle:{"position":"fixed","top":"50%","left":"50%","transform":"translate(-50%, -50%)"},attrs:{"width":"135","height":"135","viewBox":"0 0 135 135","xmlns":"http://www.w3.org/2000/svg","fill":"#A7D08E"}},[_c(\'path\',{attrs:{"d":"M67.447 58c5.523 0 10-4.477 10-10s-4.477-10-10-10-10 4.477-10 10 4.477 10 10 10zm9.448 9.447c0 5.523 4.477 10 10 10 5.522 0 10-4.477 10-10s-4.478-10-10-10c-5.523 0-10 4.477-10 10zm-9.448 9.448c-5.523 0-10 4.477-10 10 0 5.522 4.477 10 10 10s10-4.478 10-10c0-5.523-4.477-10-10-10zM58 67.447c0-5.523-4.477-10-10-10s-10 4.477-10 10 4.477 10 10 10 10-4.477 10-10z"}},[_c(\'animateTransform\',{attrs:{"attributeName":"transform","type":"rotate","from":"0 67 67","to":"-360 67 67","dur":"2.5s","repeatCount":"indefinite"}})],1),_c(\'path\',{attrs:{"d":"M28.19 40.31c6.627 0 12-5.374 12-12 0-6.628-5.373-12-12-12-6.628 0-12 5.372-12 12 0 6.626 5.372 12 12 12zm30.72-19.825c4.686 4.687 12.284 4.687 16.97 0 4.686-4.686 4.686-12.284 0-16.97-4.686-4.687-12.284-4.687-16.97 0-4.687 4.686-4.687 12.284 0 16.97zm35.74 7.705c0 6.627 5.37 12 12 12 6.626 0 12-5.373 12-12 0-6.628-5.374-12-12-12-6.63 0-12 5.372-12 12zm19.822 30.72c-4.686 4.686-4.686 12.284 0 16.97 4.687 4.686 12.285 4.686 16.97 0 4.687-4.686 4.687-12.284 0-16.97-4.685-4.687-12.283-4.687-16.97 0zm-7.704 35.74c-6.627 0-12 5.37-12 12 0 6.626 5.373 12 12 12s12-5.374 12-12c0-6.63-5.373-12-12-12zm-30.72 19.822c-4.686-4.686-12.284-4.686-16.97 0-4.686 4.687-4.686 12.285 0 16.97 4.686 4.687 12.284 4.687 16.97 0 4.687-4.685 4.687-12.283 0-16.97zm-35.74-7.704c0-6.627-5.372-12-12-12-6.626 0-12 5.373-12 12s5.374 12 12 12c6.628 0 12-5.373 12-12zm-19.823-30.72c4.687-4.686 4.687-12.284 0-16.97-4.686-4.686-12.284-4.686-16.97 0-4.687 4.686-4.687 12.284 0 16.97 4.686 4.687 12.284 4.687 16.97 0z"}},[_c(\'animateTransform\',{attrs:{"attributeName":"transform","type":"rotate","from":"0 67 67","to":"360 67 67","dur":"8s","repeatCount":"indefinite"}})],1)])]),_c(\'div\',{staticClass:"layout-px-spacing"},[_c(\'div\',{staticClass:"row layout-top-spacing"}),_c(\'div\',{staticClass:"widget-content widget-content-area custom-border-radius"},[_c(\'form\',{staticClass:"contact",attrs:{"id":"register_specialist_fm"}},[_c(\'div\',{staticClass:"info"},[_vm._m(0),_c(\'div\',{staticClass:"row"},[(Object.keys(_vm.errors).length)?_c(\'div\',{staticClass:"col-md-12"},[_c(\'div\',{staticClass:"alert alert-danger"},[_vm._v(" Whoops, something went wrong! "),_c(\'ul\',_vm._l((Object.keys(_vm.errors)),function(error){return _c(\'li\',{key:error,staticStyle:{"list-style":"unset"}},[_vm._v(_vm._s(_vm.errors[error][0]))])}),0)])]):_vm._e(),_c(\'div\',{staticClass:"col-md-12"},[_c(\'h3\',{staticClass:"specialist-info-text"},[_vm._v("Information spécialisée")]),_c(\'div\',{staticClass:"row"},[_c(\'div\',{staticClass:"col-md-6"},[_c(\'div\',{staticClass:"form-group"},[_c(\'label\',{attrs:{"for":"first_name"}},[_vm._v("Prénom du spécialiste")]),_c(\'input\',{directives:[{name:"model",rawName:"v-model",value:(_vm.form.user.firstname),expression:"form.user.firstname"}],staticClass:"form-control mb-4 inp-person-first-name",attrs:{"type":"text","id":"first_name","name":"first_name","placeholder":"Prénom du spécialiste"},domProps:{"value":(_vm.form.user.firstname)},on:{"input":function($event){if($event.target.composing){ return; }_vm.$set(_vm.form.user, "firstname", $event.target.value)}}})])]),_c(\'div\',{staticClass:"col-md-6"},[_c(\'div\',{staticClass:"form-group"},[_c(\'label\',{attrs:{"for":"last_name"}},[_vm._v("Nom de famille du spécialiste")]),_c(\'input\',{directives:[{name:"model",rawName:"v-model",value:(_vm.form.user.lastname),expression:"form.user.lastname"}],staticClass:"inp-person-last-name form-control mb-4",attrs:{"type":"text","id":"last_name","name":"last_name","placeholder":"Nom de famille du spécialiste"},domProps:{"value":(_vm.form.user.lastname)},on:{"input":function($event){if($event.target.composing){ return; }_vm.$set(_vm.form.user, "lastname", $event.target.value)}}})])])]),_c(\'div\',{staticClass:"row"},[_c(\'div\',{staticClass:"col-md-6"},[_c(\'div\',{staticClass:"form-group"},[_c(\'label\',{attrs:{"for":"specialitycategory_id_fk"}},[_vm._v("Spécialiste")]),_c(\'select\',{staticClass:"form-control specialist_category tagging",attrs:{"id":"specialitycategory_id_fk","name":"specialitycategory_id_fk","multiple":"true"}},_vm._l((_vm.specialities),function(speciality){return _c(\'option\',{domProps:{"value":speciality.speciality_id}},[_vm._v(_vm._s(speciality.name))])}),0),_c(\'br\')])]),_c(\'div\',{staticClass:"col-md-6"},[_c(\'div\',{staticClass:"form-group"},[_c(\'label\',{attrs:{"for":"email"}},[_vm._v("Adresse électronique")]),_c(\'input\',{directives:[{name:"model",rawName:"v-model",value:(_vm.form.user.email),expression:"form.user.email"}],staticClass:"form-control mb-4 inp-email",attrs:{"type":"email","id":"email","name":"email","placeholder":"Adresse électronique"},domProps:{"value":(_vm.form.user.email)},on:{"input":function($event){if($event.target.composing){ return; }_vm.$set(_vm.form.user, "email", $event.target.value)}}}),_c(\'span\',{attrs:{"id":"email_error"}})])])]),_c(\'div\',{staticClass:"row"},[_c(\'div\',{staticClass:"col-md-6"},[_c(\'div\',{staticClass:"form-group"},[_c(\'label\',{attrs:{"for":"mobile_number"}},[_vm._v("Numéro de portable")]),_c(\'input\',{directives:[{name:"model",rawName:"v-model",value:(_vm.form.user.phone_number),expression:"form.user.phone_number"}],staticClass:"form-control mb-4 inp-phone",attrs:{"type":"text","id":"mobile_number","name":"mobile_number","maxlength":"10","placeholder":"Numéro de portable","data-rule-minlength":"10","data-msg-minlength":"Numéro de portable La longueur est de 10"},domProps:{"value":(_vm.form.user.phone_number)},on:{"input":function($event){if($event.target.composing){ return; }_vm.$set(_vm.form.user, "phone_number", $event.target.value)}}}),_c(\'span\',{attrs:{"id":"mobile_error"}})])]),_c(\'div\',{staticClass:"col-md-6"},[_c(\'div\',{staticClass:"form-group"},[_c(\'label\',{attrs:{"for":"practice_start_date"}},[_vm._v("Date de début")]),_c(\'input\',{directives:[{name:"model",rawName:"v-model",value:(_vm.form.practice_start_date),expression:"form.practice_start_date"}],staticClass:"form-control flatpickr flatpickr-input active",attrs:{"type":"text","id":"practice_start_date1","name":"practice_start_date","placeholder":"Date de début"},domProps:{"value":(_vm.form.practice_start_date)},on:{"input":function($event){if($event.target.composing){ return; }_vm.$set(_vm.form, "practice_start_date", $event.target.value)}}})])])]),_c(\'div\',{staticClass:"row"},[_c(\'div\',{staticClass:"col-md-6"},[_c(\'div\',{staticClass:"form-group"},[_c(\'label\',[_vm._v("Adresse spécialiste – Ligne 1 (exemple : 33 rue censier)*")]),_c(\'input\',{directives:[{name:"model",rawName:"v-model",value:(_vm.form.addresses[0].street_address),expression:"form.addresses[0].street_address"}],staticClass:"form-control inp-company-street-address1",attrs:{"type":"text","placeholder":"Adresse spécialiste – Ligne 1 (exemple : 33 rue censier)*","name":"owner_address_line1","data-rule-required":"true","data-msg-required":"Adresse spécialiste – Ligne 1 (exemple : 33 rue censier)* champ est obligatoire."},domProps:{"value":(_vm.form.addresses[0].street_address)},on:{"input":function($event){if($event.target.composing){ return; }_vm.$set(_vm.form.addresses[0], "street_address", $event.target.value)}}})])])]),_c(\'div\',{staticClass:"row"},[_c(\'div\',{staticClass:"col-md-6"},[_c(\'div\',{staticClass:"form-group"},[_c(\'label\',[_vm._v("Adresse spécialiste – Ligne 2 (exemple: Résidence, maison, etc..)*")]),_c(\'input\',{directives:[{name:"model",rawName:"v-model",value:(_vm.form.addresses[1].street_address),expression:"form.addresses[1].street_address"}],staticClass:"form-control add_2",attrs:{"type":"text","placeholder":"Adresse spécialiste – Ligne 2 (exemple: Résidence, maison, etc..)*","name":"owner_address_line2","data-rule-required":"true","data-msg-required":"Adresse spécialiste – Ligne 2 (exemple: Résidence, maison, etc..)* champ est obligatoire."},domProps:{"value":(_vm.form.addresses[1].street_address)},on:{"input":function($event){if($event.target.composing){ return; }_vm.$set(_vm.form.addresses[1], "street_address", $event.target.value)}}})])]),_c(\'div\',{staticClass:"col-md-6"},[_c(\'label\',[_vm._v("Pays")]),_c(\'select\',{directives:[{name:"model",rawName:"v-model",value:(_vm.form.user.profile.country_id),expression:"form.user.profile.country_id"}],staticClass:"form-control init-select2 select-field",staticStyle:{"padding-left":"2px"},attrs:{"name":"country","id":"sel_country","data-rule-required":"true","data-msg-required":"Pays champ est obligatoire."},on:{"change":function($event){var $$selectedVal = Array.prototype.filter.call($event.target.options,function(o){return o.selected}).map(function(o){var val = "_value" in o ? o._value : o.value;return val}); _vm.$set(_vm.form.user.profile, "country_id", $event.target.multiple ? $$selectedVal : $$selectedVal[0])}}},[_c(\'option\',{attrs:{"selected":"","disabled":"","value":""}},[_vm._v("Pays")]),_vm._l((_vm.countries),function(country){return _c(\'option\',{key:country.id,domProps:{"value":country.id}},[_vm._v(_vm._s(country.name.en))])})],2)])]),_c(\'div\',{staticClass:"row"},[_c(\'div\',{staticClass:"col-md-6"},[_c(\'div\',{staticClass:"form-group"},[_c(\'label\',[_vm._v("Ville")]),_c(\'select\',{staticClass:"form-control select-field inp-company-city",staticStyle:{"padding-left":"2px"},attrs:{"name":"city","id":"sel_city","data-rule-required":"true","data-msg-required":"<?= $this->lang->line(\'city\') champ est obligatoire."}},[_c(\'option\',{attrs:{"selected":"","disabled":"","value":""}},[_vm._v("Ville")]),_vm._l((_vm.cities),function(city){return _c(\'option\',{key:city.id,domProps:{"value":city.id}},[_vm._v(_vm._s(city.name.en))])})],2)])])]),_c(\'div\',{staticClass:"row"},[_vm._m(1),_c(\'div\',{staticClass:"col-md-6"},[_c(\'div\',{staticClass:"form-group"},[_c(\'label\',[_vm._v("Date de naissance")]),_c(\'input\',{directives:[{name:"model",rawName:"v-model",value:(_vm.form.user.profile.date_of_birth),expression:"form.user.profile.date_of_birth"}],staticClass:"form-control flatpickr flatpickr-input active date_of_birth",attrs:{"type":"text","id":"date_of_birth","name":"date_of_birth","placeholder":"Date de naissance","data-rule-required":"true","data-msg-required":"Date champ est obligatoire."},domProps:{"value":(_vm.form.user.profile.date_of_birth)},on:{"input":function($event){if($event.target.composing){ return; }_vm.$set(_vm.form.user.profile, "date_of_birth", $event.target.value)}}})])])]),_vm._m(2),_vm._m(3),_vm._m(4),_vm._m(5),_c(\'div\',{staticClass:"row"},[_c(\'div\',{staticClass:"col-md-12"},[_c(\'center\',[_c(\'span\',{staticClass:"bank_validations error"})])],1)]),_c(\'div\',{staticClass:"row bottom-button-row"},[_c(\'div\',{staticClass:"col-md-12 text-center pt-5"},[_c(\'input\',{attrs:{"type":"hidden","name":"stripe_bank_account","id":"stripe_bank_account"}}),_c(\'input\',{attrs:{"type":"hidden","name":"token-account","id":"token-account"}}),_c(\'button\',{staticClass:"btn btn-primary custom-submit-btn add-btn",attrs:{"type":"submit"}},[_vm._v("Soumettre")]),_c(\'button\',{staticClass:"btn btn-outline-success btn-rounded reset-btn",attrs:{"type":"reset"}},[_vm._v("Réinitialiser")]),_c(\'router-link\',{staticClass:"btn btn-outline-dark btn-rounded back-btn-width",attrs:{"to":"/superadmin/specialist"}},[_vm._v("Retour")])],1)])])])])])])])])}\nvar staticRenderFns = [function () {var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;return _c(\'div\',{staticClass:"row"},[_c(\'div\',{staticClass:"col-md-12 col-lg-12 col-sm-12 col-xs-12"},[_c(\'div\',{staticClass:"upload pr-md-4"},[_c(\'input\',{staticClass:"dropify",attrs:{"type":"file","id":"specialist_picture","name":"specialist_picture","data-max-file-size":"2M"}}),_c(\'p\',{staticClass:"mt-2 text-center text-capitalize"},[_c(\'i\',{staticClass:"flaticon-cloud-upload mr-1 "}),_vm._v("Photo du spécialiste")])])])])},function () {var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;return _c(\'div\',{staticClass:"col-md-6"},[_c(\'div\',{staticClass:"form-group"},[_c(\'label\',[_vm._v("Code postal")]),_c(\'input\',{staticClass:"form-control inp-person-zip",attrs:{"type":"text","placeholder":"Code postal","name":"postal_code","data-rule-required":"true","data-msg-required":"postal code champ est obligatoire."}})])])},function () {var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;return _c(\'div\',{staticClass:"row"},[_c(\'div\',{staticClass:"col-md-6"},[_c(\'div\',{staticClass:"form-group"},[_c(\'label\',[_vm._v("Numéro de pièce d\'identité*")]),_c(\'input\',{staticClass:"form-control",attrs:{"type":"text","id":"id_number","name":"id_number","placeholder":"Numéro de pièce d\'identité*"}})])]),_c(\'div\',{staticClass:"col-md-6"},[_c(\'div\',{staticClass:"form-group"},[_c(\'label\',[_vm._v("Nom du titulaire du compte")]),_c(\'input\',{staticClass:"form-control",attrs:{"type":"text","id":"account_holder_name","name":"account_holder_name","placeholder":"Nom du titulaire du compte","data-rule-required":"true","data-msg-required":"Le champ du nom du titulaire du compte est obligatoire"}})])])])},function () {var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;return _c(\'div\',{staticClass:"row"},[_c(\'div\',{staticClass:"col-md-6"},[_c(\'div\',{staticClass:"form-group"},[_c(\'label\',[_vm._v("IBAN – sans espace*")]),_c(\'input\',{staticClass:"form-control IBAN",attrs:{"type":"text","id":"","placeholder":"IBAN – sans espace*","name":"IBAN","data-rule-required":"true","data-msg-required":"IBAN – sans espace* champ est obligatoire."}})])]),_c(\'div\',{staticClass:"col-md-6"},[_c(\'div\',{staticClass:"form-group"},[_c(\'label\',[_vm._v("Recto pièce d\'identité (format jpg)*")]),_c(\'div\',{attrs:{"id":"fileUpload"}},[_c(\'p\',{staticClass:"choose_btn"},[_vm._v("Importer")])]),_c(\'input\',{attrs:{"type":"file","id":"doc_front","name":"doc_front","data-rule-required":"true","data-msg-required":"Document front champ est obligatoire."}}),_c(\'span\',{staticClass:"doc_front"}),_c(\'p\',{staticClass:"error_file"},[_vm._v("Veuillez sélectionner un document")])])])])},function () {var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;return _c(\'div\',{staticClass:"row"},[_c(\'div\',{staticClass:"col-md-6"},[_c(\'div\',{staticClass:"form-group"},[_c(\'label\',[_vm._v("Verso pièce d\'identité (format jpg)*")]),_c(\'div\',{attrs:{"id":"fileUpload_2"}},[_c(\'p\',{staticClass:"choose_btn"},[_vm._v("Importer")])]),_c(\'input\',{attrs:{"type":"file","id":"doc_back","name":"doc_back","data-rule-required":"true","data-msg-required":"Document back champ est obligatoire."}}),_c(\'p\',{staticClass:"error_file_1"},[_vm._v("Veuillez sélectionner un document")]),_c(\'span\',{staticClass:"doc_back"})])]),_c(\'div\',{staticClass:"col-md-6"},[_c(\'div\',{staticClass:"form-group"},[_c(\'label\',[_vm._v("Recto document complémentaire (à défaut remettre la pièce d\'identité recto)*")]),_c(\'div\',{attrs:{"id":"fileUpload_3"}},[_c(\'p\',{staticClass:"choose_btn"},[_vm._v("Importer")])]),_c(\'input\',{attrs:{"type":"file","id":"additional_doc_front","name":"additional_doc_front","data-rule-required":"true","data-msg-required":"Additional Document back champ est obligatoire."}}),_c(\'p\',{staticClass:"error_file_2"},[_vm._v("Veuillez sélectionner un document")]),_c(\'span\',{staticClass:"additional_doc_front"})])])])},function () {var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;return _c(\'div\',{staticClass:"row"},[_c(\'div\',{staticClass:"col-md-6"},[_c(\'div\',{staticClass:"form-group"},[_c(\'div\',{staticClass:"quform-input"},[_c(\'label\',[_vm._v("Verso document complémentaire (à défaut remettre la pièce d\'identité verso)*")]),_c(\'div\',{attrs:{"id":"fileUpload_4"}},[_c(\'p\',{staticClass:"choose_btn"},[_vm._v("Importer")])]),_c(\'input\',{attrs:{"type":"file","id":"additional_doc_back","name":"additional_doc_back","data-rule-required":"true","data-msg-required":"Additional Document back champ est obligatoire."}}),_c(\'p\',{staticClass:"error_file_3"},[_vm._v("Veuillez sélectionner un document")]),_c(\'span\',{staticClass:"additional_doc_back"})])]),_c(\'div\',{staticClass:"col-md-6"},[_c(\'div\',{staticClass:"form-group"})])])])}]\n\n\n// CONCATENATED MODULE: ./src/modules/app/modules/superadmin/modules/specialist/views/Add.vue?vue&type=template&id=08c49d7f&\n\n// EXTERNAL MODULE: ./node_modules/@babel/runtime/helpers/esm/objectSpread2.js\nvar objectSpread2 = __webpack_require__("5530");\n\n// EXTERNAL MODULE: ./node_modules/core-js/modules/es.regexp.exec.js\nvar es_regexp_exec = __webpack_require__("ac1f");\n\n// EXTERNAL MODULE: ./node_modules/core-js/modules/es.string.replace.js\nvar es_string_replace = __webpack_require__("5319");\n\n// EXTERNAL MODULE: ./node_modules/core-js/modules/es.string.starts-with.js\nvar es_string_starts_with = __webpack_require__("2ca0");\n\n// EXTERNAL MODULE: ./node_modules/core-js/modules/es.regexp.test.js\nvar es_regexp_test = __webpack_require__("00b4");\n\n// EXTERNAL MODULE: ./node_modules/core-js/modules/es.string.match.js\nvar es_string_match = __webpack_require__("466d");\n\n// EXTERNAL MODULE: ./node_modules/core-js/modules/es.array.filter.js\nvar es_array_filter = __webpack_require__("4de4");\n\n// EXTERNAL MODULE: ./node_modules/core-js/modules/es.object.to-string.js\nvar es_object_to_string = __webpack_require__("d3b7");\n\n// EXTERNAL MODULE: ./src/modules/http/api/requestFactory.js\nvar requestFactory = __webpack_require__("8c0b");\n\n// EXTERNAL MODULE: ./node_modules/select2/dist/js/select2.js\nvar select2 = __webpack_require__("0e33");\n\n// EXTERNAL MODULE: ./node_modules/dropify/dist/js/dropify.js\nvar dropify = __webpack_require__("a9fb");\n\n// EXTERNAL MODULE: ./node_modules/jquery-validation/dist/jquery.validate.js\nvar jquery_validate = __webpack_require__("ac82");\n\n// EXTERNAL MODULE: ./node_modules/dropify/dist/css/dropify.css\nvar css_dropify = __webpack_require__("fe7f");\n\n// EXTERNAL MODULE: ./node_modules/flatpickr/dist/flatpickr.js\nvar flatpickr = __webpack_require__("cf06");\n\n// EXTERNAL MODULE: ./node_modules/flatpickr/dist/l10n/fr.js\nvar fr = __webpack_require__("0227");\n\n// EXTERNAL MODULE: ./node_modules/flatpickr/dist/flatpickr.min.css\nvar flatpickr_min = __webpack_require__("2be5");\n\n// EXTERNAL MODULE: ./node_modules/vuex/dist/vuex.esm.js\nvar vuex_esm = __webpack_require__("2f62");\n\n// CONCATENATED MODULE: ./node_modules/cache-loader/dist/cjs.js??ref--13-0!./node_modules/thread-loader/dist/cjs.js!./node_modules/babel-loader/lib!./node_modules/cache-loader/dist/cjs.js??ref--1-0!./node_modules/@vue/cli-service/node_modules/vue-loader/lib??vue-loader-options!./src/modules/app/modules/superadmin/modules/specialist/views/Add.vue?vue&type=script&lang=js&\n\n\n\n\n\n\n\n\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n\n\n\n\n\n\n\n\n\n/* harmony default export */ var Addvue_type_script_lang_js_ = ({\n  name: \'add-specialist\',\n  methods: Object(objectSpread2["a" /* default */])({\n    validateMobile: function validateMobile(value) {\n      var mobile = ""; //First remove all spaces:\n\n      value = value.replace(/\\s/g, \'\');\n\n      if (value.startsWith("0")) {\n        var temp = value.substring(1, value.length);\n        mobile = "+33" + temp; //Mobile number:\n\n        return mobile;\n        console.log(\'mobile\' + mobile);\n      } else if (value.startsWith("+")) {\n        var temp = value.substring(3, value.length);\n        mobile = "+33" + temp; //Mobile number:\n\n        console.log(\'mobile:\' + mobile);\n        return mobile;\n      } else {\n        mobile = value; //Mobile number:\n\n        console.log(mobile);\n        return mobile;\n      }\n    }\n  }, Object(vuex_esm["b" /* mapActions */])(\'app/superAdminSpecialistStore\', [\'setCountries\', \'setSpecialities\', \'post\'])),\n  data: function data() {\n    return {\n      errors: {},\n      form: {\n        practice_start_date: \'\',\n        speciality_id: [],\n        addresses: [{\n          street_address: \'\'\n        }, {\n          street_address: \'\'\n        }],\n        postal_code: \'\',\n        user: {\n          email: \'\',\n          firstname: \'\',\n          lastname: \'\',\n          phone_number: \'\',\n          profile: {\n            profile_image: \'\'\n          }\n        }\n      },\n      cities: []\n    };\n  },\n  computed: Object(objectSpread2["a" /* default */])({}, Object(vuex_esm["c" /* mapGetters */])(\'app/superAdminSpecialistStore\', [\'countries\', \'specialities\'])),\n  mounted: function mounted() {\n    var _this = this;\n\n    var that = this;\n    $(".tagging").select2({\n      tags: true\n    }); //$(\'.init-select2\').select2();\n\n    Object(requestFactory["a" /* default */])().get(\'/api/v1/superadmin/specialities\').then(function (data) {\n      that.setSpecialities(data);\n    });\n    Object(requestFactory["a" /* default */])().get(\'/api/v1/superadmin/countries\').then(function (response) {\n      return _this.setCountries(response.data);\n    });\n    $(\'.dropify\').dropify({\n      messages: {\n        \'default\': \'Click to Upload or Drag n Drop\',\n        \'remove\': \'<i class="fa fa-times"></i>\',\n        \'replace\': \'Upload or Drag n Drop\'\n      }\n    });\n    $(\'#fileUpload_4\').on(\'click\', function () {\n      $(\'#additional_doc_back\').click();\n    });\n    $(\'#additional_doc_back\').on(\'change\', function () {\n      if ($(\'#additional_doc_back\').val() != \'\') {\n        $(\'#fileUpload_4\').html($(\'#additional_doc_back\').val().replace(/.*(\\/|\\\\)/, \'\'));\n      } else {\n        $(\'#fileUpload_4\').html($(\'Importer\').val());\n      }\n    });\n    $(\'.add-btn\').on(\'click\', function () {\n      $("#register_specialist_fm").valid();\n    });\n    $(\'#fileUpload\').on(\'click\', function () {\n      $(\'#doc_front\').click();\n    });\n    $(\'#doc_front\').on(\'change\', function () {\n      if ($(\'#doc_front\').val() != \'\') {\n        $(\'#fileUpload\').html($(\'#doc_front\').val().replace(/.*(\\/|\\\\)/, \'\'));\n      } else {\n        $(\'#fileUpload\').html($(\'Importer\').val());\n      }\n    });\n    $(\'#fileUpload_2\').on(\'click\', function () {\n      $(\'#doc_back\').click();\n    });\n    $(\'#doc_back\').on(\'change\', function () {\n      if ($(\'#doc_back\').val() != \'\') {\n        $(\'#fileUpload_2\').html($(\'#doc_back\').val().replace(/.*(\\/|\\\\)/, \'\'));\n      } else {\n        $(\'#fileUpload_2\').html($(\'Importer\').val());\n      }\n    });\n    $(\'#fileUpload_3\').on(\'click\', function () {\n      $(\'#additional_doc_front\').click();\n    });\n    $(\'#additional_doc_front\').on(\'change\', function () {\n      if ($(\'#additional_doc_front\').val() != \'\') {\n        $(\'#fileUpload_3\').html($(\'#additional_doc_front\').val().replace(/.*(\\/|\\\\)/, \'\'));\n      } else {\n        $(\'#fileUpload_3\').html($(\'Importer\').val());\n      }\n    });\n    document.getElementById(\'date_of_birth\').flatpickr({\n      inline: false,\n      dateFormat: "d/m/Y",\n      maxDate: "today",\n      locale: "fr"\n    });\n    document.getElementById(\'practice_start_date1\').flatpickr({\n      inline: false,\n      dateFormat: "d/m/Y",\n      minDate: "today",\n      locale: "fr"\n    });\n    $(\'#register_specialist_fm\').validate({\n      rules: {\n        first_name: {\n          required: true //lettersonly: true,\n\n        },\n        last_name: {\n          required: true // lettersonly: true,\n\n        },\n        specialitycategory_id_fk: {\n          required: true // lettersonly: true,\n\n        },\n        practice_start_date: {\n          required: true // lettersonly: true,\n\n        },\n        email: {\n          required: true // lettersonly: true,\n\n        },\n        mobile_number: {\n          required: true // lettersonly: true,\n\n        }\n      },\n      messages: {\n        first_name: {\n          required: "champ est obligatoire."\n        },\n        last_name: {\n          required: "champ est obligatoire."\n        },\n        specialitycategory_id_fk: {\n          required: "champ est obligatoire."\n        },\n        practice_start_date: {\n          required: "champ est obligatoire."\n        },\n        email: {\n          required: "champ est obligatoire."\n        },\n        mobile_number: {\n          required: "champ est obligatoire."\n        }\n      },\n      errorElement: \'span\',\n      errorPlacement: function errorPlacement(error, element) {\n        console.log(error, element);\n        error.addClass(\'invalid-feedback\');\n        error.insertAfter(element);\n      },\n      highlight: function highlight(element, errorClass, validClass) {\n        $(element).addClass(\'is-invalid\');\n      },\n      unhighlight: function unhighlight(element, errorClass, validClass) {\n        $(element).removeClass(\'is-invalid\');\n      },\n      submitHandler: function submitHandler(form) {\n        console.log(form);\n        that.post(new FormData(form)).then(function (response) {\n          /*if(response.success) {\r\n              toastr.success(\'onnées ajoutées avec succès.\', \'Succès\');\r\n            that.$router.push({name: \'superadmin.enterprises\'});\r\n          }*/\n        });\n      }\n    });\n    $("#first_name,#last_name,#fullname,#account_holder_name").keypress(function (event) {\n      var inputValue = event.charCode;\n\n      if (!(inputValue >= 65 && inputValue <= 120) && inputValue != 32 && inputValue != 0) {\n        event.preventDefault();\n      }\n    });\n    jQuery.validator.addMethod("lettersonly", function (value, element) {\n      return this.optional(element) || /^[a-z]+$/i.test(value);\n    }, "<?=$this->lang->line(\'letters_error\');?>");\n    $.validator.addMethod("custom_number", function (value, element) {\n      return this.optional(element) || value === "NA" || value.match(/^[0-9,\\*-]+$/);\n    }, "Please enter a valid number");\n  },\n  watch: {\n    \'form.user.profile.country_id\': function formUserProfileCountry_id(newValue) {\n      if (newValue) {\n        this.cities = this.countries.filter(function (country) {\n          return country.id == newValue;\n        })[0].cities;\n      }\n    }\n  }\n});\n// CONCATENATED MODULE: ./src/modules/app/modules/superadmin/modules/specialist/views/Add.vue?vue&type=script&lang=js&\n /* harmony default export */ var views_Addvue_type_script_lang_js_ = (Addvue_type_script_lang_js_); \n// EXTERNAL MODULE: ./src/modules/app/modules/superadmin/modules/specialist/views/Add.vue?vue&type=style&index=0&lang=css&\nvar Addvue_type_style_index_0_lang_css_ = __webpack_require__("1f76");\n\n// EXTERNAL MODULE: ./node_modules/@vue/cli-service/node_modules/vue-loader/lib/runtime/componentNormalizer.js\nvar componentNormalizer = __webpack_require__("0c7c");\n\n// CONCATENATED MODULE: ./src/modules/app/modules/superadmin/modules/specialist/views/Add.vue\n\n\n\n\n\n\n/* normalize component */\n\nvar component = Object(componentNormalizer["a" /* default */])(\n  views_Addvue_type_script_lang_js_,\n  render,\n  staticRenderFns,\n  false,\n  null,\n  null,\n  null\n  \n)\n\n/* harmony default export */ var Add = __webpack_exports__["default"] = (component.exports);//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvbW9kdWxlcy9hcHAvbW9kdWxlcy9zdXBlcmFkbWluL21vZHVsZXMvc3BlY2lhbGlzdC92aWV3cy9BZGQudnVlP2MxZGUiLCJ3ZWJwYWNrOi8vL3NyYy9tb2R1bGVzL2FwcC9tb2R1bGVzL3N1cGVyYWRtaW4vbW9kdWxlcy9zcGVjaWFsaXN0L3ZpZXdzL0FkZC52dWU/YTViNiIsIndlYnBhY2s6Ly8vLi9zcmMvbW9kdWxlcy9hcHAvbW9kdWxlcy9zdXBlcmFkbWluL21vZHVsZXMvc3BlY2lhbGlzdC92aWV3cy9BZGQudnVlPzg0MTEiLCJ3ZWJwYWNrOi8vLy4vc3JjL21vZHVsZXMvYXBwL21vZHVsZXMvc3VwZXJhZG1pbi9tb2R1bGVzL3NwZWNpYWxpc3Qvdmlld3MvQWRkLnZ1ZT82MDY0Il0sIm5hbWVzIjpbIm5hbWUiLCJtZXRob2RzIiwidmFsaWRhdGVNb2JpbGUiLCJ2YWx1ZSIsIm1vYmlsZSIsImNvbnNvbGUiLCJtYXBBY3Rpb25zIiwiZGF0YSIsImVycm9ycyIsImZvcm0iLCJwcmFjdGljZV9zdGFydF9kYXRlIiwic3BlY2lhbGl0eV9pZCIsImFkZHJlc3NlcyIsInN0cmVldF9hZGRyZXNzIiwicG9zdGFsX2NvZGUiLCJ1c2VyIiwiZW1haWwiLCJmaXJzdG5hbWUiLCJsYXN0bmFtZSIsInBob25lX251bWJlciIsInByb2ZpbGUiLCJwcm9maWxlX2ltYWdlIiwiY2l0aWVzIiwiY29tcHV0ZWQiLCJtYXBHZXR0ZXJzIiwibW91bnRlZCIsIiQiLCJ0YWdzIiwicmVxdWVzdEZhY3RvcnkiLCJ0aGVuIiwidGhhdCIsIm1lc3NhZ2VzIiwiZG9jdW1lbnQiLCJpbmxpbmUiLCJkYXRlRm9ybWF0IiwibWF4RGF0ZSIsImxvY2FsZSIsIm1pbkRhdGUiLCJydWxlcyIsImZpcnN0X25hbWUiLCJyZXF1aXJlZCIsImxhc3RfbmFtZSIsInNwZWNpYWxpdHljYXRlZ29yeV9pZF9mayIsIm1vYmlsZV9udW1iZXIiLCJlcnJvckVsZW1lbnQiLCJlcnJvclBsYWNlbWVudCIsImVycm9yIiwiaGlnaGxpZ2h0IiwidW5oaWdobGlnaHQiLCJzdWJtaXRIYW5kbGVyIiwiZXZlbnQiLCJqUXVlcnkiLCJ3YXRjaCIsIm5ld1ZhbHVlIl0sIm1hcHBpbmdzIjoiOzs7O0FBQUEsMEJBQTBCLGFBQWEsMEJBQTBCLHdCQUF3QiwyQkFBMkIsMEJBQTBCLFlBQVksYUFBYSxnRkFBZ0YsUUFBUSw0R0FBNEcsYUFBYSxPQUFPLDhXQUE4Vyx5QkFBeUIsT0FBTyx3SEFBd0gsaUJBQWlCLE9BQU8sdStCQUF1K0IseUJBQXlCLE9BQU8scUhBQXFILG9CQUFvQixnQ0FBZ0MsWUFBWSxxQ0FBcUMsWUFBWSxzRUFBc0UsYUFBYSw2QkFBNkIsK0JBQStCLFlBQVksbUJBQW1CLHNCQUFzQixrQkFBa0IsNkNBQTZDLHdCQUF3QixZQUFZLGlDQUFpQyxxR0FBcUcsZ0JBQWdCLHVCQUF1QixzQkFBc0IseUNBQXlDLDRCQUE0Qix3QkFBd0IsV0FBVyxtQ0FBbUMsZ0RBQWdELGtCQUFrQixZQUFZLHVCQUF1QixZQUFZLHlCQUF5QixjQUFjLE9BQU8sb0JBQW9CLGdEQUFnRCxhQUFhLGdHQUFnRywrREFBK0QsMEZBQTBGLFdBQVcsa0NBQWtDLEtBQUsseUJBQXlCLDRCQUE0QixRQUFRLEVBQUUsNERBQTRELGdCQUFnQix1QkFBdUIsWUFBWSx5QkFBeUIsY0FBYyxPQUFPLG1CQUFtQix3REFBd0QsYUFBYSw4RkFBOEYsOERBQThELGdHQUFnRyxXQUFXLGlDQUFpQyxLQUFLLHlCQUF5Qiw0QkFBNEIsUUFBUSxFQUFFLDJEQUEyRCxrQkFBa0Isa0JBQWtCLFlBQVksdUJBQXVCLFlBQVkseUJBQXlCLGNBQWMsT0FBTyxrQ0FBa0MsdUNBQXVDLDhEQUE4RCxxRkFBcUYsZ0RBQWdELG9CQUFvQixVQUFVLGtDQUFrQyxvQ0FBb0MsNEJBQTRCLHVCQUF1QixZQUFZLHlCQUF5QixjQUFjLE9BQU8sZUFBZSwrQ0FBK0MsYUFBYSx3RkFBd0YsbURBQW1ELGdGQUFnRixXQUFXLDhCQUE4QixLQUFLLHlCQUF5Qiw0QkFBNEIsUUFBUSxFQUFFLHdEQUF3RCxhQUFhLE9BQU8sb0JBQW9CLGtCQUFrQixrQkFBa0IsWUFBWSx1QkFBdUIsWUFBWSx5QkFBeUIsY0FBYyxPQUFPLHVCQUF1Qiw2Q0FBNkMsYUFBYSxzR0FBc0csbURBQW1ELHlNQUF5TSxXQUFXLHFDQUFxQyxLQUFLLHlCQUF5Qiw0QkFBNEIsUUFBUSxFQUFFLCtEQUErRCxhQUFhLE9BQU8scUJBQXFCLGdCQUFnQix1QkFBdUIsWUFBWSx5QkFBeUIsY0FBYyxPQUFPLDZCQUE2Qix3Q0FBd0MsYUFBYSwwR0FBMEcscUVBQXFFLHFHQUFxRyxXQUFXLHVDQUF1QyxLQUFLLHlCQUF5Qiw0QkFBNEIsUUFBUSxFQUFFLGlFQUFpRSxrQkFBa0Isa0JBQWtCLFlBQVksdUJBQXVCLFlBQVkseUJBQXlCLGdHQUFnRyxhQUFhLDBIQUEwSCxnRUFBZ0Usd1BBQXdQLFdBQVcsK0NBQStDLEtBQUsseUJBQXlCLDRCQUE0QixRQUFRLEVBQUUseUVBQXlFLGtCQUFrQixrQkFBa0IsWUFBWSx1QkFBdUIsWUFBWSx5QkFBeUIseUdBQXlHLGFBQWEsMEhBQTBILDBDQUEwQywwUUFBMFEsV0FBVywrQ0FBK0MsS0FBSyx5QkFBeUIsNEJBQTRCLFFBQVEsRUFBRSx5RUFBeUUsZ0JBQWdCLHVCQUF1Qiw0Q0FBNEMsYUFBYSxrSEFBa0gsb0VBQW9FLHFCQUFxQixRQUFRLGtIQUFrSCxLQUFLLDBCQUEwQixrRkFBa0Ysa0JBQWtCLGtCQUFrQiw2Q0FBNkMsV0FBVyxFQUFFLDRHQUE0RyxlQUFlLE9BQU8sd0NBQXdDLDREQUE0RCxvQkFBb0IseUJBQXlCLG9CQUFvQixvQ0FBb0Msb0JBQW9CLGtCQUFrQixZQUFZLHVCQUF1QixZQUFZLHlCQUF5Qiw2Q0FBNkMsc0VBQXNFLHFCQUFxQixRQUFRLHNJQUFzSSxlQUFlLE9BQU8sd0NBQXdDLHVEQUF1RCxvQkFBb0Isc0JBQXNCLGlCQUFpQixpQ0FBaUMsc0JBQXNCLGtCQUFrQixzQkFBc0IsdUJBQXVCLFlBQVkseUJBQXlCLHdEQUF3RCxhQUFhLHdIQUF3SCxtRkFBbUYsMEtBQTBLLFdBQVcsOENBQThDLEtBQUsseUJBQXlCLDRCQUE0QixRQUFRLEVBQUUsd0VBQXdFLDBEQUEwRCxrQkFBa0IsWUFBWSx3QkFBd0IsMEJBQTBCLHFDQUFxQyxvQkFBb0Isb0NBQW9DLFlBQVkseUNBQXlDLGNBQWMsT0FBTyx5RUFBeUUsY0FBYyxPQUFPLDZEQUE2RCxlQUFlLCtEQUErRCxpQkFBaUIscUNBQXFDLG1FQUFtRSxnQkFBZ0IsOENBQThDLHFFQUFxRSwrQkFBK0I7QUFDL3JXLG9DQUFvQyxhQUFhLDBCQUEwQix3QkFBd0IsaUJBQWlCLGtCQUFrQixZQUFZLHNEQUFzRCxZQUFZLDZCQUE2QixjQUFjLDZCQUE2QiwrRkFBK0YsVUFBVSwrQ0FBK0MsVUFBVSwwQ0FBMEMseUNBQXlDLGNBQWMsYUFBYSwwQkFBMEIsd0JBQXdCLGlCQUFpQix1QkFBdUIsWUFBWSx5QkFBeUIsa0RBQWtELGlEQUFpRCxxSkFBcUosTUFBTSxjQUFjLGFBQWEsMEJBQTBCLHdCQUF3QixpQkFBaUIsa0JBQWtCLFlBQVksdUJBQXVCLFlBQVkseUJBQXlCLGtFQUFrRSxrQ0FBa0MsK0ZBQStGLGdCQUFnQix1QkFBdUIsWUFBWSx5QkFBeUIsaUVBQWlFLGtDQUFrQywyTkFBMk4sUUFBUSxjQUFjLGFBQWEsMEJBQTBCLHdCQUF3QixpQkFBaUIsa0JBQWtCLFlBQVksdUJBQXVCLFlBQVkseUJBQXlCLDBEQUEwRCx1Q0FBdUMsc0tBQXNLLGdCQUFnQix1QkFBdUIsWUFBWSx5QkFBeUIseUVBQXlFLE9BQU8sbUJBQW1CLFVBQVUseUJBQXlCLHFDQUFxQyxPQUFPLDJJQUEySSxhQUFhLHdCQUF3QixVQUFVLHlCQUF5QixzREFBc0QsY0FBYyxhQUFhLDBCQUEwQix3QkFBd0IsaUJBQWlCLGtCQUFrQixZQUFZLHVCQUF1QixZQUFZLHlCQUF5Qix5RUFBeUUsT0FBTyxxQkFBcUIsVUFBVSx5QkFBeUIscUNBQXFDLE9BQU8sd0lBQXdJLFVBQVUsMkJBQTJCLDJEQUEyRCx1QkFBdUIsZ0JBQWdCLHVCQUF1QixZQUFZLHlCQUF5QixpSEFBaUgsT0FBTyxxQkFBcUIsVUFBVSx5QkFBeUIscUNBQXFDLE9BQU8sMktBQTJLLFVBQVUsMkJBQTJCLDJEQUEyRCxtQ0FBbUMsUUFBUSxjQUFjLGFBQWEsMEJBQTBCLHdCQUF3QixpQkFBaUIsa0JBQWtCLFlBQVksdUJBQXVCLFlBQVkseUJBQXlCLFlBQVksMkJBQTJCLGlIQUFpSCxPQUFPLHFCQUFxQixVQUFVLHlCQUF5QixxQ0FBcUMsT0FBTyx5S0FBeUssVUFBVSwyQkFBMkIsMkRBQTJELGtDQUFrQyxnQkFBZ0IsdUJBQXVCLFlBQVkseUJBQXlCLFFBQVE7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FDa1Foa0o7QUFDL0Q7QUFDQTtBQUN5QztBQUN6QztBQUNpRDtBQUNqRDtBQUNBO0FBQ0E7QUFHZTtBQUNmQSx3QkFEQTtBQUVBQyxXQUFXQTtBQUNYQyxrQkFEQSwwQkFDQUMsS0FEQSxFQUNBO0FBRUEsc0JBRkEsQ0FHQTs7QUFDQUE7O0FBRUE7QUFDQTtBQUNBQyw4QkFGQSxDQUdBOztBQUNBO0FBQ0FDO0FBQ0EsT0FOQSxNQU1BO0FBQ0E7QUFDQUQsOEJBRkEsQ0FHQTs7QUFDQUM7QUFDQTtBQUNBLE9BTkEsTUFPQTtBQUNBRCx1QkFEQSxDQUVBOztBQUNBQztBQUNBO0FBQ0E7QUFDQTtBQTFCQSxLQTJCQUMseUVBQ0EsY0FEQSxFQUVBLGlCQUZBLEVBR0EsTUFIQSxFQTNCQSxDQUZBO0FBd0RBQyxNQXhEQSxrQkF3REE7QUFDQTtBQUNBQyxnQkFEQTtBQUVBQztBQUNBQywrQkFEQTtBQUVBQyx5QkFGQTtBQUdBQyxvQkFDQTtBQUFBQztBQUFBLFNBREEsRUFFQTtBQUFBQTtBQUFBLFNBRkEsQ0FIQTtBQU9BQyx1QkFQQTtBQVFBQztBQUNBQyxtQkFEQTtBQUVBQyx1QkFGQTtBQUdBQyxzQkFIQTtBQUlBQywwQkFKQTtBQUtBQztBQUNBQztBQURBO0FBTEE7QUFSQSxPQUZBO0FBcUJBQztBQXJCQTtBQXVCQSxHQWhGQTtBQWlGQUMsWUFBWUEsNkNBQ1pDLHlFQUNBLFdBREEsRUFFQSxjQUZBLEVBREEsQ0FqRkE7QUF1RkFDLFNBdkZBLHFCQXVGQTtBQUFBOztBQUVBO0FBQ0FDO0FBQUFDO0FBQUEsT0FIQSxDQUlBOztBQUVBQyxJQUFJQSx5Q0FBY0EsMENBQ2xCQyxJQURBLENBQ0E7QUFBQUM7QUFBQSxLQURBO0FBR0FGLElBQUlBLHlDQUFjQSx1Q0FDbEJDLElBREEsQ0FDQTtBQUFBO0FBQUEsS0FEQTtBQUlBSDtBQUNBSztBQUFBO0FBQUE7QUFBQTtBQUFBO0FBREE7QUFJQUw7QUFDQUE7QUFDQSxLQUZBO0FBSUFBO0FBQ0E7QUFDQUE7QUFDQSxPQUZBLE1BRUE7QUFDQUE7QUFDQTtBQUNBLEtBTkE7QUFRQUE7QUFDQUE7QUFDQSxLQUZBO0FBSUFBO0FBQ0FBO0FBQ0EsS0FGQTtBQUlBQTtBQUNBO0FBQ0FBO0FBQ0EsT0FGQSxNQUVBO0FBQ0FBO0FBQ0E7QUFDQSxLQU5BO0FBUUFBO0FBQ0FBO0FBQ0EsS0FGQTtBQUlBQTtBQUNBO0FBQ0FBO0FBQ0EsT0FGQSxNQUVBO0FBQ0FBO0FBQ0E7QUFDQSxLQU5BO0FBUUFBO0FBQ0FBO0FBQ0EsS0FGQTtBQUlBQTtBQUNBO0FBQ0FBO0FBQ0EsT0FGQSxNQUVBO0FBQ0FBO0FBQ0E7QUFDQSxLQU5BO0FBUUFNO0FBQUFDO0FBQUFDO0FBQUFDO0FBQUFDO0FBQUE7QUFDQUo7QUFBQUM7QUFBQUM7QUFBQUc7QUFBQUQ7QUFBQTtBQUVBVjtBQUNBWTtBQUNBQztBQUNBQyx3QkFEQSxDQUVBOztBQUZBLFNBREE7QUFLQUM7QUFDQUQsd0JBREEsQ0FFQTs7QUFGQSxTQUxBO0FBU0FFO0FBQ0FGLHdCQURBLENBRUE7O0FBRkEsU0FUQTtBQWFBOUI7QUFDQThCLHdCQURBLENBRUE7O0FBRkEsU0FiQTtBQWlCQXhCO0FBQ0F3Qix3QkFEQSxDQUVBOztBQUZBLFNBakJBO0FBcUJBRztBQUNBSCx3QkFEQSxDQUVBOztBQUZBO0FBckJBLE9BREE7QUE2QkFUO0FBQ0FRO0FBQUFDO0FBQUEsU0FEQTtBQUVBQztBQUFBRDtBQUFBLFNBRkE7QUFHQUU7QUFBQUY7QUFBQSxTQUhBO0FBSUE5QjtBQUFBOEI7QUFBQSxTQUpBO0FBS0F4QjtBQUFBd0I7QUFBQSxTQUxBO0FBTUFHO0FBQUFIO0FBQUE7QUFOQSxPQTdCQTtBQXFDQUksMEJBckNBO0FBc0NBQztBQUNBeEM7QUFDQXlDO0FBQ0FBO0FBQ0EsT0ExQ0E7QUEyQ0FDO0FBQ0FyQjtBQUNBLE9BN0NBO0FBOENBc0I7QUFDQXRCO0FBQ0EsT0FoREE7QUFpREF1QjtBQUVBNUM7QUFDQXlCO0FBRUE7O0FBRUE7QUFDQTtBQUVBLFNBUEE7QUFRQTtBQTVEQTtBQStEQUo7QUFDQTs7QUFDQTtBQUNBd0I7QUFDQTtBQUNBLEtBTEE7QUFPQUM7QUFDQTtBQUNBLEtBRkEsRUFFQSwwQ0FGQTtBQUlBekI7QUFDQSx5REFDQXZCLDJCQURBO0FBRUEsS0FIQSxFQUdBLDZCQUhBO0FBSUEsR0E3T0E7QUE4T0FpRDtBQUNBLGtDQURBLHFDQUNBQyxRQURBLEVBQ0E7QUFFQTtBQUVBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFQQTtBQTlPQSxHOztBQzlRcWIsQ0FBZ0IsaUdBQUcsRUFBQyxDOzs7Ozs7OztBQ0F2WDtBQUMzQjtBQUNMO0FBQ2E7OztBQUcvRDtBQUMwSTtBQUMxSSxnQkFBZ0IsOENBQVU7QUFDMUIsRUFBRSxpQ0FBTTtBQUNSLEVBQUUsTUFBTTtBQUNSLEVBQUUsZUFBZTtBQUNqQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFZSwwRiIsImZpbGUiOiI4NzU4LmpzIiwic291cmNlc0NvbnRlbnQiOlsidmFyIHJlbmRlciA9IGZ1bmN0aW9uICgpIHt2YXIgX3ZtPXRoaXM7dmFyIF9oPV92bS4kY3JlYXRlRWxlbWVudDt2YXIgX2M9X3ZtLl9zZWxmLl9jfHxfaDtyZXR1cm4gX2MoJ2RpdicsW19jKCdkaXYnLHtzdGF0aWNDbGFzczpcImFqYXgtbG9hZGVyXCJ9LFtfYygnc3ZnJyx7c3RhdGljU3R5bGU6e1wicG9zaXRpb25cIjpcImZpeGVkXCIsXCJ0b3BcIjpcIjUwJVwiLFwibGVmdFwiOlwiNTAlXCIsXCJ0cmFuc2Zvcm1cIjpcInRyYW5zbGF0ZSgtNTAlLCAtNTAlKVwifSxhdHRyczp7XCJ3aWR0aFwiOlwiMTM1XCIsXCJoZWlnaHRcIjpcIjEzNVwiLFwidmlld0JveFwiOlwiMCAwIDEzNSAxMzVcIixcInhtbG5zXCI6XCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1wiLFwiZmlsbFwiOlwiI0E3RDA4RVwifX0sW19jKCdwYXRoJyx7YXR0cnM6e1wiZFwiOlwiTTY3LjQ0NyA1OGM1LjUyMyAwIDEwLTQuNDc3IDEwLTEwcy00LjQ3Ny0xMC0xMC0xMC0xMCA0LjQ3Ny0xMCAxMCA0LjQ3NyAxMCAxMCAxMHptOS40NDggOS40NDdjMCA1LjUyMyA0LjQ3NyAxMCAxMCAxMCA1LjUyMiAwIDEwLTQuNDc3IDEwLTEwcy00LjQ3OC0xMC0xMC0xMGMtNS41MjMgMC0xMCA0LjQ3Ny0xMCAxMHptLTkuNDQ4IDkuNDQ4Yy01LjUyMyAwLTEwIDQuNDc3LTEwIDEwIDAgNS41MjIgNC40NzcgMTAgMTAgMTBzMTAtNC40NzggMTAtMTBjMC01LjUyMy00LjQ3Ny0xMC0xMC0xMHpNNTggNjcuNDQ3YzAtNS41MjMtNC40NzctMTAtMTAtMTBzLTEwIDQuNDc3LTEwIDEwIDQuNDc3IDEwIDEwIDEwIDEwLTQuNDc3IDEwLTEwelwifX0sW19jKCdhbmltYXRlVHJhbnNmb3JtJyx7YXR0cnM6e1wiYXR0cmlidXRlTmFtZVwiOlwidHJhbnNmb3JtXCIsXCJ0eXBlXCI6XCJyb3RhdGVcIixcImZyb21cIjpcIjAgNjcgNjdcIixcInRvXCI6XCItMzYwIDY3IDY3XCIsXCJkdXJcIjpcIjIuNXNcIixcInJlcGVhdENvdW50XCI6XCJpbmRlZmluaXRlXCJ9fSldLDEpLF9jKCdwYXRoJyx7YXR0cnM6e1wiZFwiOlwiTTI4LjE5IDQwLjMxYzYuNjI3IDAgMTItNS4zNzQgMTItMTIgMC02LjYyOC01LjM3My0xMi0xMi0xMi02LjYyOCAwLTEyIDUuMzcyLTEyIDEyIDAgNi42MjYgNS4zNzIgMTIgMTIgMTJ6bTMwLjcyLTE5LjgyNWM0LjY4NiA0LjY4NyAxMi4yODQgNC42ODcgMTYuOTcgMCA0LjY4Ni00LjY4NiA0LjY4Ni0xMi4yODQgMC0xNi45Ny00LjY4Ni00LjY4Ny0xMi4yODQtNC42ODctMTYuOTcgMC00LjY4NyA0LjY4Ni00LjY4NyAxMi4yODQgMCAxNi45N3ptMzUuNzQgNy43MDVjMCA2LjYyNyA1LjM3IDEyIDEyIDEyIDYuNjI2IDAgMTItNS4zNzMgMTItMTIgMC02LjYyOC01LjM3NC0xMi0xMi0xMi02LjYzIDAtMTIgNS4zNzItMTIgMTJ6bTE5LjgyMiAzMC43MmMtNC42ODYgNC42ODYtNC42ODYgMTIuMjg0IDAgMTYuOTcgNC42ODcgNC42ODYgMTIuMjg1IDQuNjg2IDE2Ljk3IDAgNC42ODctNC42ODYgNC42ODctMTIuMjg0IDAtMTYuOTctNC42ODUtNC42ODctMTIuMjgzLTQuNjg3LTE2Ljk3IDB6bS03LjcwNCAzNS43NGMtNi42MjcgMC0xMiA1LjM3LTEyIDEyIDAgNi42MjYgNS4zNzMgMTIgMTIgMTJzMTItNS4zNzQgMTItMTJjMC02LjYzLTUuMzczLTEyLTEyLTEyem0tMzAuNzIgMTkuODIyYy00LjY4Ni00LjY4Ni0xMi4yODQtNC42ODYtMTYuOTcgMC00LjY4NiA0LjY4Ny00LjY4NiAxMi4yODUgMCAxNi45NyA0LjY4NiA0LjY4NyAxMi4yODQgNC42ODcgMTYuOTcgMCA0LjY4Ny00LjY4NSA0LjY4Ny0xMi4yODMgMC0xNi45N3ptLTM1Ljc0LTcuNzA0YzAtNi42MjctNS4zNzItMTItMTItMTItNi42MjYgMC0xMiA1LjM3My0xMiAxMnM1LjM3NCAxMiAxMiAxMmM2LjYyOCAwIDEyLTUuMzczIDEyLTEyem0tMTkuODIzLTMwLjcyYzQuNjg3LTQuNjg2IDQuNjg3LTEyLjI4NCAwLTE2Ljk3LTQuNjg2LTQuNjg2LTEyLjI4NC00LjY4Ni0xNi45NyAwLTQuNjg3IDQuNjg2LTQuNjg3IDEyLjI4NCAwIDE2Ljk3IDQuNjg2IDQuNjg3IDEyLjI4NCA0LjY4NyAxNi45NyAwelwifX0sW19jKCdhbmltYXRlVHJhbnNmb3JtJyx7YXR0cnM6e1wiYXR0cmlidXRlTmFtZVwiOlwidHJhbnNmb3JtXCIsXCJ0eXBlXCI6XCJyb3RhdGVcIixcImZyb21cIjpcIjAgNjcgNjdcIixcInRvXCI6XCIzNjAgNjcgNjdcIixcImR1clwiOlwiOHNcIixcInJlcGVhdENvdW50XCI6XCJpbmRlZmluaXRlXCJ9fSldLDEpXSldKSxfYygnZGl2Jyx7c3RhdGljQ2xhc3M6XCJsYXlvdXQtcHgtc3BhY2luZ1wifSxbX2MoJ2Rpdicse3N0YXRpY0NsYXNzOlwicm93IGxheW91dC10b3Atc3BhY2luZ1wifSksX2MoJ2Rpdicse3N0YXRpY0NsYXNzOlwid2lkZ2V0LWNvbnRlbnQgd2lkZ2V0LWNvbnRlbnQtYXJlYSBjdXN0b20tYm9yZGVyLXJhZGl1c1wifSxbX2MoJ2Zvcm0nLHtzdGF0aWNDbGFzczpcImNvbnRhY3RcIixhdHRyczp7XCJpZFwiOlwicmVnaXN0ZXJfc3BlY2lhbGlzdF9mbVwifX0sW19jKCdkaXYnLHtzdGF0aWNDbGFzczpcImluZm9cIn0sW192bS5fbSgwKSxfYygnZGl2Jyx7c3RhdGljQ2xhc3M6XCJyb3dcIn0sWyhPYmplY3Qua2V5cyhfdm0uZXJyb3JzKS5sZW5ndGgpP19jKCdkaXYnLHtzdGF0aWNDbGFzczpcImNvbC1tZC0xMlwifSxbX2MoJ2Rpdicse3N0YXRpY0NsYXNzOlwiYWxlcnQgYWxlcnQtZGFuZ2VyXCJ9LFtfdm0uX3YoXCIgV2hvb3BzLCBzb21ldGhpbmcgd2VudCB3cm9uZyEgXCIpLF9jKCd1bCcsX3ZtLl9sKChPYmplY3Qua2V5cyhfdm0uZXJyb3JzKSksZnVuY3Rpb24oZXJyb3Ipe3JldHVybiBfYygnbGknLHtrZXk6ZXJyb3Isc3RhdGljU3R5bGU6e1wibGlzdC1zdHlsZVwiOlwidW5zZXRcIn19LFtfdm0uX3YoX3ZtLl9zKF92bS5lcnJvcnNbZXJyb3JdWzBdKSldKX0pLDApXSldKTpfdm0uX2UoKSxfYygnZGl2Jyx7c3RhdGljQ2xhc3M6XCJjb2wtbWQtMTJcIn0sW19jKCdoMycse3N0YXRpY0NsYXNzOlwic3BlY2lhbGlzdC1pbmZvLXRleHRcIn0sW192bS5fdihcIkluZm9ybWF0aW9uIHNww6ljaWFsaXPDqWVcIildKSxfYygnZGl2Jyx7c3RhdGljQ2xhc3M6XCJyb3dcIn0sW19jKCdkaXYnLHtzdGF0aWNDbGFzczpcImNvbC1tZC02XCJ9LFtfYygnZGl2Jyx7c3RhdGljQ2xhc3M6XCJmb3JtLWdyb3VwXCJ9LFtfYygnbGFiZWwnLHthdHRyczp7XCJmb3JcIjpcImZpcnN0X25hbWVcIn19LFtfdm0uX3YoXCJQcsOpbm9tIGR1IHNww6ljaWFsaXN0ZVwiKV0pLF9jKCdpbnB1dCcse2RpcmVjdGl2ZXM6W3tuYW1lOlwibW9kZWxcIixyYXdOYW1lOlwidi1tb2RlbFwiLHZhbHVlOihfdm0uZm9ybS51c2VyLmZpcnN0bmFtZSksZXhwcmVzc2lvbjpcImZvcm0udXNlci5maXJzdG5hbWVcIn1dLHN0YXRpY0NsYXNzOlwiZm9ybS1jb250cm9sIG1iLTQgaW5wLXBlcnNvbi1maXJzdC1uYW1lXCIsYXR0cnM6e1widHlwZVwiOlwidGV4dFwiLFwiaWRcIjpcImZpcnN0X25hbWVcIixcIm5hbWVcIjpcImZpcnN0X25hbWVcIixcInBsYWNlaG9sZGVyXCI6XCJQcsOpbm9tIGR1IHNww6ljaWFsaXN0ZVwifSxkb21Qcm9wczp7XCJ2YWx1ZVwiOihfdm0uZm9ybS51c2VyLmZpcnN0bmFtZSl9LG9uOntcImlucHV0XCI6ZnVuY3Rpb24oJGV2ZW50KXtpZigkZXZlbnQudGFyZ2V0LmNvbXBvc2luZyl7IHJldHVybjsgfV92bS4kc2V0KF92bS5mb3JtLnVzZXIsIFwiZmlyc3RuYW1lXCIsICRldmVudC50YXJnZXQudmFsdWUpfX19KV0pXSksX2MoJ2Rpdicse3N0YXRpY0NsYXNzOlwiY29sLW1kLTZcIn0sW19jKCdkaXYnLHtzdGF0aWNDbGFzczpcImZvcm0tZ3JvdXBcIn0sW19jKCdsYWJlbCcse2F0dHJzOntcImZvclwiOlwibGFzdF9uYW1lXCJ9fSxbX3ZtLl92KFwiTm9tIGRlIGZhbWlsbGUgZHUgc3DDqWNpYWxpc3RlXCIpXSksX2MoJ2lucHV0Jyx7ZGlyZWN0aXZlczpbe25hbWU6XCJtb2RlbFwiLHJhd05hbWU6XCJ2LW1vZGVsXCIsdmFsdWU6KF92bS5mb3JtLnVzZXIubGFzdG5hbWUpLGV4cHJlc3Npb246XCJmb3JtLnVzZXIubGFzdG5hbWVcIn1dLHN0YXRpY0NsYXNzOlwiaW5wLXBlcnNvbi1sYXN0LW5hbWUgZm9ybS1jb250cm9sIG1iLTRcIixhdHRyczp7XCJ0eXBlXCI6XCJ0ZXh0XCIsXCJpZFwiOlwibGFzdF9uYW1lXCIsXCJuYW1lXCI6XCJsYXN0X25hbWVcIixcInBsYWNlaG9sZGVyXCI6XCJOb20gZGUgZmFtaWxsZSBkdSBzcMOpY2lhbGlzdGVcIn0sZG9tUHJvcHM6e1widmFsdWVcIjooX3ZtLmZvcm0udXNlci5sYXN0bmFtZSl9LG9uOntcImlucHV0XCI6ZnVuY3Rpb24oJGV2ZW50KXtpZigkZXZlbnQudGFyZ2V0LmNvbXBvc2luZyl7IHJldHVybjsgfV92bS4kc2V0KF92bS5mb3JtLnVzZXIsIFwibGFzdG5hbWVcIiwgJGV2ZW50LnRhcmdldC52YWx1ZSl9fX0pXSldKV0pLF9jKCdkaXYnLHtzdGF0aWNDbGFzczpcInJvd1wifSxbX2MoJ2Rpdicse3N0YXRpY0NsYXNzOlwiY29sLW1kLTZcIn0sW19jKCdkaXYnLHtzdGF0aWNDbGFzczpcImZvcm0tZ3JvdXBcIn0sW19jKCdsYWJlbCcse2F0dHJzOntcImZvclwiOlwic3BlY2lhbGl0eWNhdGVnb3J5X2lkX2ZrXCJ9fSxbX3ZtLl92KFwiU3DDqWNpYWxpc3RlXCIpXSksX2MoJ3NlbGVjdCcse3N0YXRpY0NsYXNzOlwiZm9ybS1jb250cm9sIHNwZWNpYWxpc3RfY2F0ZWdvcnkgdGFnZ2luZ1wiLGF0dHJzOntcImlkXCI6XCJzcGVjaWFsaXR5Y2F0ZWdvcnlfaWRfZmtcIixcIm5hbWVcIjpcInNwZWNpYWxpdHljYXRlZ29yeV9pZF9ma1wiLFwibXVsdGlwbGVcIjpcInRydWVcIn19LF92bS5fbCgoX3ZtLnNwZWNpYWxpdGllcyksZnVuY3Rpb24oc3BlY2lhbGl0eSl7cmV0dXJuIF9jKCdvcHRpb24nLHtkb21Qcm9wczp7XCJ2YWx1ZVwiOnNwZWNpYWxpdHkuc3BlY2lhbGl0eV9pZH19LFtfdm0uX3YoX3ZtLl9zKHNwZWNpYWxpdHkubmFtZSkpXSl9KSwwKSxfYygnYnInKV0pXSksX2MoJ2Rpdicse3N0YXRpY0NsYXNzOlwiY29sLW1kLTZcIn0sW19jKCdkaXYnLHtzdGF0aWNDbGFzczpcImZvcm0tZ3JvdXBcIn0sW19jKCdsYWJlbCcse2F0dHJzOntcImZvclwiOlwiZW1haWxcIn19LFtfdm0uX3YoXCJBZHJlc3NlIMOpbGVjdHJvbmlxdWVcIildKSxfYygnaW5wdXQnLHtkaXJlY3RpdmVzOlt7bmFtZTpcIm1vZGVsXCIscmF3TmFtZTpcInYtbW9kZWxcIix2YWx1ZTooX3ZtLmZvcm0udXNlci5lbWFpbCksZXhwcmVzc2lvbjpcImZvcm0udXNlci5lbWFpbFwifV0sc3RhdGljQ2xhc3M6XCJmb3JtLWNvbnRyb2wgbWItNCBpbnAtZW1haWxcIixhdHRyczp7XCJ0eXBlXCI6XCJlbWFpbFwiLFwiaWRcIjpcImVtYWlsXCIsXCJuYW1lXCI6XCJlbWFpbFwiLFwicGxhY2Vob2xkZXJcIjpcIkFkcmVzc2Ugw6lsZWN0cm9uaXF1ZVwifSxkb21Qcm9wczp7XCJ2YWx1ZVwiOihfdm0uZm9ybS51c2VyLmVtYWlsKX0sb246e1wiaW5wdXRcIjpmdW5jdGlvbigkZXZlbnQpe2lmKCRldmVudC50YXJnZXQuY29tcG9zaW5nKXsgcmV0dXJuOyB9X3ZtLiRzZXQoX3ZtLmZvcm0udXNlciwgXCJlbWFpbFwiLCAkZXZlbnQudGFyZ2V0LnZhbHVlKX19fSksX2MoJ3NwYW4nLHthdHRyczp7XCJpZFwiOlwiZW1haWxfZXJyb3JcIn19KV0pXSldKSxfYygnZGl2Jyx7c3RhdGljQ2xhc3M6XCJyb3dcIn0sW19jKCdkaXYnLHtzdGF0aWNDbGFzczpcImNvbC1tZC02XCJ9LFtfYygnZGl2Jyx7c3RhdGljQ2xhc3M6XCJmb3JtLWdyb3VwXCJ9LFtfYygnbGFiZWwnLHthdHRyczp7XCJmb3JcIjpcIm1vYmlsZV9udW1iZXJcIn19LFtfdm0uX3YoXCJOdW3DqXJvIGRlIHBvcnRhYmxlXCIpXSksX2MoJ2lucHV0Jyx7ZGlyZWN0aXZlczpbe25hbWU6XCJtb2RlbFwiLHJhd05hbWU6XCJ2LW1vZGVsXCIsdmFsdWU6KF92bS5mb3JtLnVzZXIucGhvbmVfbnVtYmVyKSxleHByZXNzaW9uOlwiZm9ybS51c2VyLnBob25lX251bWJlclwifV0sc3RhdGljQ2xhc3M6XCJmb3JtLWNvbnRyb2wgbWItNCBpbnAtcGhvbmVcIixhdHRyczp7XCJ0eXBlXCI6XCJ0ZXh0XCIsXCJpZFwiOlwibW9iaWxlX251bWJlclwiLFwibmFtZVwiOlwibW9iaWxlX251bWJlclwiLFwibWF4bGVuZ3RoXCI6XCIxMFwiLFwicGxhY2Vob2xkZXJcIjpcIk51bcOpcm8gZGUgcG9ydGFibGVcIixcImRhdGEtcnVsZS1taW5sZW5ndGhcIjpcIjEwXCIsXCJkYXRhLW1zZy1taW5sZW5ndGhcIjpcIk51bcOpcm8gZGUgcG9ydGFibGUgTGEgbG9uZ3VldXIgZXN0IGRlIDEwXCJ9LGRvbVByb3BzOntcInZhbHVlXCI6KF92bS5mb3JtLnVzZXIucGhvbmVfbnVtYmVyKX0sb246e1wiaW5wdXRcIjpmdW5jdGlvbigkZXZlbnQpe2lmKCRldmVudC50YXJnZXQuY29tcG9zaW5nKXsgcmV0dXJuOyB9X3ZtLiRzZXQoX3ZtLmZvcm0udXNlciwgXCJwaG9uZV9udW1iZXJcIiwgJGV2ZW50LnRhcmdldC52YWx1ZSl9fX0pLF9jKCdzcGFuJyx7YXR0cnM6e1wiaWRcIjpcIm1vYmlsZV9lcnJvclwifX0pXSldKSxfYygnZGl2Jyx7c3RhdGljQ2xhc3M6XCJjb2wtbWQtNlwifSxbX2MoJ2Rpdicse3N0YXRpY0NsYXNzOlwiZm9ybS1ncm91cFwifSxbX2MoJ2xhYmVsJyx7YXR0cnM6e1wiZm9yXCI6XCJwcmFjdGljZV9zdGFydF9kYXRlXCJ9fSxbX3ZtLl92KFwiRGF0ZSBkZSBkw6lidXRcIildKSxfYygnaW5wdXQnLHtkaXJlY3RpdmVzOlt7bmFtZTpcIm1vZGVsXCIscmF3TmFtZTpcInYtbW9kZWxcIix2YWx1ZTooX3ZtLmZvcm0ucHJhY3RpY2Vfc3RhcnRfZGF0ZSksZXhwcmVzc2lvbjpcImZvcm0ucHJhY3RpY2Vfc3RhcnRfZGF0ZVwifV0sc3RhdGljQ2xhc3M6XCJmb3JtLWNvbnRyb2wgZmxhdHBpY2tyIGZsYXRwaWNrci1pbnB1dCBhY3RpdmVcIixhdHRyczp7XCJ0eXBlXCI6XCJ0ZXh0XCIsXCJpZFwiOlwicHJhY3RpY2Vfc3RhcnRfZGF0ZTFcIixcIm5hbWVcIjpcInByYWN0aWNlX3N0YXJ0X2RhdGVcIixcInBsYWNlaG9sZGVyXCI6XCJEYXRlIGRlIGTDqWJ1dFwifSxkb21Qcm9wczp7XCJ2YWx1ZVwiOihfdm0uZm9ybS5wcmFjdGljZV9zdGFydF9kYXRlKX0sb246e1wiaW5wdXRcIjpmdW5jdGlvbigkZXZlbnQpe2lmKCRldmVudC50YXJnZXQuY29tcG9zaW5nKXsgcmV0dXJuOyB9X3ZtLiRzZXQoX3ZtLmZvcm0sIFwicHJhY3RpY2Vfc3RhcnRfZGF0ZVwiLCAkZXZlbnQudGFyZ2V0LnZhbHVlKX19fSldKV0pXSksX2MoJ2Rpdicse3N0YXRpY0NsYXNzOlwicm93XCJ9LFtfYygnZGl2Jyx7c3RhdGljQ2xhc3M6XCJjb2wtbWQtNlwifSxbX2MoJ2Rpdicse3N0YXRpY0NsYXNzOlwiZm9ybS1ncm91cFwifSxbX2MoJ2xhYmVsJyxbX3ZtLl92KFwiQWRyZXNzZSBzcMOpY2lhbGlzdGUg4oCTIExpZ25lIDEgKGV4ZW1wbGUgOiAzMyBydWUgY2Vuc2llcikqXCIpXSksX2MoJ2lucHV0Jyx7ZGlyZWN0aXZlczpbe25hbWU6XCJtb2RlbFwiLHJhd05hbWU6XCJ2LW1vZGVsXCIsdmFsdWU6KF92bS5mb3JtLmFkZHJlc3Nlc1swXS5zdHJlZXRfYWRkcmVzcyksZXhwcmVzc2lvbjpcImZvcm0uYWRkcmVzc2VzWzBdLnN0cmVldF9hZGRyZXNzXCJ9XSxzdGF0aWNDbGFzczpcImZvcm0tY29udHJvbCBpbnAtY29tcGFueS1zdHJlZXQtYWRkcmVzczFcIixhdHRyczp7XCJ0eXBlXCI6XCJ0ZXh0XCIsXCJwbGFjZWhvbGRlclwiOlwiQWRyZXNzZSBzcMOpY2lhbGlzdGUg4oCTIExpZ25lIDEgKGV4ZW1wbGUgOiAzMyBydWUgY2Vuc2llcikqXCIsXCJuYW1lXCI6XCJvd25lcl9hZGRyZXNzX2xpbmUxXCIsXCJkYXRhLXJ1bGUtcmVxdWlyZWRcIjpcInRydWVcIixcImRhdGEtbXNnLXJlcXVpcmVkXCI6XCJBZHJlc3NlIHNww6ljaWFsaXN0ZSDigJMgTGlnbmUgMSAoZXhlbXBsZSA6IDMzIHJ1ZSBjZW5zaWVyKSogY2hhbXAgZXN0IG9ibGlnYXRvaXJlLlwifSxkb21Qcm9wczp7XCJ2YWx1ZVwiOihfdm0uZm9ybS5hZGRyZXNzZXNbMF0uc3RyZWV0X2FkZHJlc3MpfSxvbjp7XCJpbnB1dFwiOmZ1bmN0aW9uKCRldmVudCl7aWYoJGV2ZW50LnRhcmdldC5jb21wb3NpbmcpeyByZXR1cm47IH1fdm0uJHNldChfdm0uZm9ybS5hZGRyZXNzZXNbMF0sIFwic3RyZWV0X2FkZHJlc3NcIiwgJGV2ZW50LnRhcmdldC52YWx1ZSl9fX0pXSldKV0pLF9jKCdkaXYnLHtzdGF0aWNDbGFzczpcInJvd1wifSxbX2MoJ2Rpdicse3N0YXRpY0NsYXNzOlwiY29sLW1kLTZcIn0sW19jKCdkaXYnLHtzdGF0aWNDbGFzczpcImZvcm0tZ3JvdXBcIn0sW19jKCdsYWJlbCcsW192bS5fdihcIkFkcmVzc2Ugc3DDqWNpYWxpc3RlIOKAkyBMaWduZSAyIChleGVtcGxlOiBSw6lzaWRlbmNlLCBtYWlzb24sIGV0Yy4uKSpcIildKSxfYygnaW5wdXQnLHtkaXJlY3RpdmVzOlt7bmFtZTpcIm1vZGVsXCIscmF3TmFtZTpcInYtbW9kZWxcIix2YWx1ZTooX3ZtLmZvcm0uYWRkcmVzc2VzWzFdLnN0cmVldF9hZGRyZXNzKSxleHByZXNzaW9uOlwiZm9ybS5hZGRyZXNzZXNbMV0uc3RyZWV0X2FkZHJlc3NcIn1dLHN0YXRpY0NsYXNzOlwiZm9ybS1jb250cm9sIGFkZF8yXCIsYXR0cnM6e1widHlwZVwiOlwidGV4dFwiLFwicGxhY2Vob2xkZXJcIjpcIkFkcmVzc2Ugc3DDqWNpYWxpc3RlIOKAkyBMaWduZSAyIChleGVtcGxlOiBSw6lzaWRlbmNlLCBtYWlzb24sIGV0Yy4uKSpcIixcIm5hbWVcIjpcIm93bmVyX2FkZHJlc3NfbGluZTJcIixcImRhdGEtcnVsZS1yZXF1aXJlZFwiOlwidHJ1ZVwiLFwiZGF0YS1tc2ctcmVxdWlyZWRcIjpcIkFkcmVzc2Ugc3DDqWNpYWxpc3RlIOKAkyBMaWduZSAyIChleGVtcGxlOiBSw6lzaWRlbmNlLCBtYWlzb24sIGV0Yy4uKSogY2hhbXAgZXN0IG9ibGlnYXRvaXJlLlwifSxkb21Qcm9wczp7XCJ2YWx1ZVwiOihfdm0uZm9ybS5hZGRyZXNzZXNbMV0uc3RyZWV0X2FkZHJlc3MpfSxvbjp7XCJpbnB1dFwiOmZ1bmN0aW9uKCRldmVudCl7aWYoJGV2ZW50LnRhcmdldC5jb21wb3NpbmcpeyByZXR1cm47IH1fdm0uJHNldChfdm0uZm9ybS5hZGRyZXNzZXNbMV0sIFwic3RyZWV0X2FkZHJlc3NcIiwgJGV2ZW50LnRhcmdldC52YWx1ZSl9fX0pXSldKSxfYygnZGl2Jyx7c3RhdGljQ2xhc3M6XCJjb2wtbWQtNlwifSxbX2MoJ2xhYmVsJyxbX3ZtLl92KFwiUGF5c1wiKV0pLF9jKCdzZWxlY3QnLHtkaXJlY3RpdmVzOlt7bmFtZTpcIm1vZGVsXCIscmF3TmFtZTpcInYtbW9kZWxcIix2YWx1ZTooX3ZtLmZvcm0udXNlci5wcm9maWxlLmNvdW50cnlfaWQpLGV4cHJlc3Npb246XCJmb3JtLnVzZXIucHJvZmlsZS5jb3VudHJ5X2lkXCJ9XSxzdGF0aWNDbGFzczpcImZvcm0tY29udHJvbCBpbml0LXNlbGVjdDIgc2VsZWN0LWZpZWxkXCIsc3RhdGljU3R5bGU6e1wicGFkZGluZy1sZWZ0XCI6XCIycHhcIn0sYXR0cnM6e1wibmFtZVwiOlwiY291bnRyeVwiLFwiaWRcIjpcInNlbF9jb3VudHJ5XCIsXCJkYXRhLXJ1bGUtcmVxdWlyZWRcIjpcInRydWVcIixcImRhdGEtbXNnLXJlcXVpcmVkXCI6XCJQYXlzIGNoYW1wIGVzdCBvYmxpZ2F0b2lyZS5cIn0sb246e1wiY2hhbmdlXCI6ZnVuY3Rpb24oJGV2ZW50KXt2YXIgJCRzZWxlY3RlZFZhbCA9IEFycmF5LnByb3RvdHlwZS5maWx0ZXIuY2FsbCgkZXZlbnQudGFyZ2V0Lm9wdGlvbnMsZnVuY3Rpb24obyl7cmV0dXJuIG8uc2VsZWN0ZWR9KS5tYXAoZnVuY3Rpb24obyl7dmFyIHZhbCA9IFwiX3ZhbHVlXCIgaW4gbyA/IG8uX3ZhbHVlIDogby52YWx1ZTtyZXR1cm4gdmFsfSk7IF92bS4kc2V0KF92bS5mb3JtLnVzZXIucHJvZmlsZSwgXCJjb3VudHJ5X2lkXCIsICRldmVudC50YXJnZXQubXVsdGlwbGUgPyAkJHNlbGVjdGVkVmFsIDogJCRzZWxlY3RlZFZhbFswXSl9fX0sW19jKCdvcHRpb24nLHthdHRyczp7XCJzZWxlY3RlZFwiOlwiXCIsXCJkaXNhYmxlZFwiOlwiXCIsXCJ2YWx1ZVwiOlwiXCJ9fSxbX3ZtLl92KFwiUGF5c1wiKV0pLF92bS5fbCgoX3ZtLmNvdW50cmllcyksZnVuY3Rpb24oY291bnRyeSl7cmV0dXJuIF9jKCdvcHRpb24nLHtrZXk6Y291bnRyeS5pZCxkb21Qcm9wczp7XCJ2YWx1ZVwiOmNvdW50cnkuaWR9fSxbX3ZtLl92KF92bS5fcyhjb3VudHJ5Lm5hbWUuZW4pKV0pfSldLDIpXSldKSxfYygnZGl2Jyx7c3RhdGljQ2xhc3M6XCJyb3dcIn0sW19jKCdkaXYnLHtzdGF0aWNDbGFzczpcImNvbC1tZC02XCJ9LFtfYygnZGl2Jyx7c3RhdGljQ2xhc3M6XCJmb3JtLWdyb3VwXCJ9LFtfYygnbGFiZWwnLFtfdm0uX3YoXCJWaWxsZVwiKV0pLF9jKCdzZWxlY3QnLHtzdGF0aWNDbGFzczpcImZvcm0tY29udHJvbCBzZWxlY3QtZmllbGQgaW5wLWNvbXBhbnktY2l0eVwiLHN0YXRpY1N0eWxlOntcInBhZGRpbmctbGVmdFwiOlwiMnB4XCJ9LGF0dHJzOntcIm5hbWVcIjpcImNpdHlcIixcImlkXCI6XCJzZWxfY2l0eVwiLFwiZGF0YS1ydWxlLXJlcXVpcmVkXCI6XCJ0cnVlXCIsXCJkYXRhLW1zZy1yZXF1aXJlZFwiOlwiPD89ICR0aGlzLT5sYW5nLT5saW5lKCdjaXR5JykgY2hhbXAgZXN0IG9ibGlnYXRvaXJlLlwifX0sW19jKCdvcHRpb24nLHthdHRyczp7XCJzZWxlY3RlZFwiOlwiXCIsXCJkaXNhYmxlZFwiOlwiXCIsXCJ2YWx1ZVwiOlwiXCJ9fSxbX3ZtLl92KFwiVmlsbGVcIildKSxfdm0uX2woKF92bS5jaXRpZXMpLGZ1bmN0aW9uKGNpdHkpe3JldHVybiBfYygnb3B0aW9uJyx7a2V5OmNpdHkuaWQsZG9tUHJvcHM6e1widmFsdWVcIjpjaXR5LmlkfX0sW192bS5fdihfdm0uX3MoY2l0eS5uYW1lLmVuKSldKX0pXSwyKV0pXSldKSxfYygnZGl2Jyx7c3RhdGljQ2xhc3M6XCJyb3dcIn0sW192bS5fbSgxKSxfYygnZGl2Jyx7c3RhdGljQ2xhc3M6XCJjb2wtbWQtNlwifSxbX2MoJ2Rpdicse3N0YXRpY0NsYXNzOlwiZm9ybS1ncm91cFwifSxbX2MoJ2xhYmVsJyxbX3ZtLl92KFwiRGF0ZSBkZSBuYWlzc2FuY2VcIildKSxfYygnaW5wdXQnLHtkaXJlY3RpdmVzOlt7bmFtZTpcIm1vZGVsXCIscmF3TmFtZTpcInYtbW9kZWxcIix2YWx1ZTooX3ZtLmZvcm0udXNlci5wcm9maWxlLmRhdGVfb2ZfYmlydGgpLGV4cHJlc3Npb246XCJmb3JtLnVzZXIucHJvZmlsZS5kYXRlX29mX2JpcnRoXCJ9XSxzdGF0aWNDbGFzczpcImZvcm0tY29udHJvbCBmbGF0cGlja3IgZmxhdHBpY2tyLWlucHV0IGFjdGl2ZSBkYXRlX29mX2JpcnRoXCIsYXR0cnM6e1widHlwZVwiOlwidGV4dFwiLFwiaWRcIjpcImRhdGVfb2ZfYmlydGhcIixcIm5hbWVcIjpcImRhdGVfb2ZfYmlydGhcIixcInBsYWNlaG9sZGVyXCI6XCJEYXRlIGRlIG5haXNzYW5jZVwiLFwiZGF0YS1ydWxlLXJlcXVpcmVkXCI6XCJ0cnVlXCIsXCJkYXRhLW1zZy1yZXF1aXJlZFwiOlwiRGF0ZSBjaGFtcCBlc3Qgb2JsaWdhdG9pcmUuXCJ9LGRvbVByb3BzOntcInZhbHVlXCI6KF92bS5mb3JtLnVzZXIucHJvZmlsZS5kYXRlX29mX2JpcnRoKX0sb246e1wiaW5wdXRcIjpmdW5jdGlvbigkZXZlbnQpe2lmKCRldmVudC50YXJnZXQuY29tcG9zaW5nKXsgcmV0dXJuOyB9X3ZtLiRzZXQoX3ZtLmZvcm0udXNlci5wcm9maWxlLCBcImRhdGVfb2ZfYmlydGhcIiwgJGV2ZW50LnRhcmdldC52YWx1ZSl9fX0pXSldKV0pLF92bS5fbSgyKSxfdm0uX20oMyksX3ZtLl9tKDQpLF92bS5fbSg1KSxfYygnZGl2Jyx7c3RhdGljQ2xhc3M6XCJyb3dcIn0sW19jKCdkaXYnLHtzdGF0aWNDbGFzczpcImNvbC1tZC0xMlwifSxbX2MoJ2NlbnRlcicsW19jKCdzcGFuJyx7c3RhdGljQ2xhc3M6XCJiYW5rX3ZhbGlkYXRpb25zIGVycm9yXCJ9KV0pXSwxKV0pLF9jKCdkaXYnLHtzdGF0aWNDbGFzczpcInJvdyBib3R0b20tYnV0dG9uLXJvd1wifSxbX2MoJ2Rpdicse3N0YXRpY0NsYXNzOlwiY29sLW1kLTEyIHRleHQtY2VudGVyIHB0LTVcIn0sW19jKCdpbnB1dCcse2F0dHJzOntcInR5cGVcIjpcImhpZGRlblwiLFwibmFtZVwiOlwic3RyaXBlX2JhbmtfYWNjb3VudFwiLFwiaWRcIjpcInN0cmlwZV9iYW5rX2FjY291bnRcIn19KSxfYygnaW5wdXQnLHthdHRyczp7XCJ0eXBlXCI6XCJoaWRkZW5cIixcIm5hbWVcIjpcInRva2VuLWFjY291bnRcIixcImlkXCI6XCJ0b2tlbi1hY2NvdW50XCJ9fSksX2MoJ2J1dHRvbicse3N0YXRpY0NsYXNzOlwiYnRuIGJ0bi1wcmltYXJ5IGN1c3RvbS1zdWJtaXQtYnRuIGFkZC1idG5cIixhdHRyczp7XCJ0eXBlXCI6XCJzdWJtaXRcIn19LFtfdm0uX3YoXCJTb3VtZXR0cmVcIildKSxfYygnYnV0dG9uJyx7c3RhdGljQ2xhc3M6XCJidG4gYnRuLW91dGxpbmUtc3VjY2VzcyBidG4tcm91bmRlZCByZXNldC1idG5cIixhdHRyczp7XCJ0eXBlXCI6XCJyZXNldFwifX0sW192bS5fdihcIlLDqWluaXRpYWxpc2VyXCIpXSksX2MoJ3JvdXRlci1saW5rJyx7c3RhdGljQ2xhc3M6XCJidG4gYnRuLW91dGxpbmUtZGFyayBidG4tcm91bmRlZCBiYWNrLWJ0bi13aWR0aFwiLGF0dHJzOntcInRvXCI6XCIvc3VwZXJhZG1pbi9zcGVjaWFsaXN0XCJ9fSxbX3ZtLl92KFwiUmV0b3VyXCIpXSldLDEpXSldKV0pXSldKV0pXSldKX1cbnZhciBzdGF0aWNSZW5kZXJGbnMgPSBbZnVuY3Rpb24gKCkge3ZhciBfdm09dGhpczt2YXIgX2g9X3ZtLiRjcmVhdGVFbGVtZW50O3ZhciBfYz1fdm0uX3NlbGYuX2N8fF9oO3JldHVybiBfYygnZGl2Jyx7c3RhdGljQ2xhc3M6XCJyb3dcIn0sW19jKCdkaXYnLHtzdGF0aWNDbGFzczpcImNvbC1tZC0xMiBjb2wtbGctMTIgY29sLXNtLTEyIGNvbC14cy0xMlwifSxbX2MoJ2Rpdicse3N0YXRpY0NsYXNzOlwidXBsb2FkIHByLW1kLTRcIn0sW19jKCdpbnB1dCcse3N0YXRpY0NsYXNzOlwiZHJvcGlmeVwiLGF0dHJzOntcInR5cGVcIjpcImZpbGVcIixcImlkXCI6XCJzcGVjaWFsaXN0X3BpY3R1cmVcIixcIm5hbWVcIjpcInNwZWNpYWxpc3RfcGljdHVyZVwiLFwiZGF0YS1tYXgtZmlsZS1zaXplXCI6XCIyTVwifX0pLF9jKCdwJyx7c3RhdGljQ2xhc3M6XCJtdC0yIHRleHQtY2VudGVyIHRleHQtY2FwaXRhbGl6ZVwifSxbX2MoJ2knLHtzdGF0aWNDbGFzczpcImZsYXRpY29uLWNsb3VkLXVwbG9hZCBtci0xIFwifSksX3ZtLl92KFwiUGhvdG8gZHUgc3DDqWNpYWxpc3RlXCIpXSldKV0pXSl9LGZ1bmN0aW9uICgpIHt2YXIgX3ZtPXRoaXM7dmFyIF9oPV92bS4kY3JlYXRlRWxlbWVudDt2YXIgX2M9X3ZtLl9zZWxmLl9jfHxfaDtyZXR1cm4gX2MoJ2Rpdicse3N0YXRpY0NsYXNzOlwiY29sLW1kLTZcIn0sW19jKCdkaXYnLHtzdGF0aWNDbGFzczpcImZvcm0tZ3JvdXBcIn0sW19jKCdsYWJlbCcsW192bS5fdihcIkNvZGUgcG9zdGFsXCIpXSksX2MoJ2lucHV0Jyx7c3RhdGljQ2xhc3M6XCJmb3JtLWNvbnRyb2wgaW5wLXBlcnNvbi16aXBcIixhdHRyczp7XCJ0eXBlXCI6XCJ0ZXh0XCIsXCJwbGFjZWhvbGRlclwiOlwiQ29kZSBwb3N0YWxcIixcIm5hbWVcIjpcInBvc3RhbF9jb2RlXCIsXCJkYXRhLXJ1bGUtcmVxdWlyZWRcIjpcInRydWVcIixcImRhdGEtbXNnLXJlcXVpcmVkXCI6XCJwb3N0YWwgY29kZSBjaGFtcCBlc3Qgb2JsaWdhdG9pcmUuXCJ9fSldKV0pfSxmdW5jdGlvbiAoKSB7dmFyIF92bT10aGlzO3ZhciBfaD1fdm0uJGNyZWF0ZUVsZW1lbnQ7dmFyIF9jPV92bS5fc2VsZi5fY3x8X2g7cmV0dXJuIF9jKCdkaXYnLHtzdGF0aWNDbGFzczpcInJvd1wifSxbX2MoJ2Rpdicse3N0YXRpY0NsYXNzOlwiY29sLW1kLTZcIn0sW19jKCdkaXYnLHtzdGF0aWNDbGFzczpcImZvcm0tZ3JvdXBcIn0sW19jKCdsYWJlbCcsW192bS5fdihcIk51bcOpcm8gZGUgcGnDqGNlIGQnaWRlbnRpdMOpKlwiKV0pLF9jKCdpbnB1dCcse3N0YXRpY0NsYXNzOlwiZm9ybS1jb250cm9sXCIsYXR0cnM6e1widHlwZVwiOlwidGV4dFwiLFwiaWRcIjpcImlkX251bWJlclwiLFwibmFtZVwiOlwiaWRfbnVtYmVyXCIsXCJwbGFjZWhvbGRlclwiOlwiTnVtw6lybyBkZSBwacOoY2UgZCdpZGVudGl0w6kqXCJ9fSldKV0pLF9jKCdkaXYnLHtzdGF0aWNDbGFzczpcImNvbC1tZC02XCJ9LFtfYygnZGl2Jyx7c3RhdGljQ2xhc3M6XCJmb3JtLWdyb3VwXCJ9LFtfYygnbGFiZWwnLFtfdm0uX3YoXCJOb20gZHUgdGl0dWxhaXJlIGR1IGNvbXB0ZVwiKV0pLF9jKCdpbnB1dCcse3N0YXRpY0NsYXNzOlwiZm9ybS1jb250cm9sXCIsYXR0cnM6e1widHlwZVwiOlwidGV4dFwiLFwiaWRcIjpcImFjY291bnRfaG9sZGVyX25hbWVcIixcIm5hbWVcIjpcImFjY291bnRfaG9sZGVyX25hbWVcIixcInBsYWNlaG9sZGVyXCI6XCJOb20gZHUgdGl0dWxhaXJlIGR1IGNvbXB0ZVwiLFwiZGF0YS1ydWxlLXJlcXVpcmVkXCI6XCJ0cnVlXCIsXCJkYXRhLW1zZy1yZXF1aXJlZFwiOlwiTGUgY2hhbXAgZHUgbm9tIGR1IHRpdHVsYWlyZSBkdSBjb21wdGUgZXN0IG9ibGlnYXRvaXJlXCJ9fSldKV0pXSl9LGZ1bmN0aW9uICgpIHt2YXIgX3ZtPXRoaXM7dmFyIF9oPV92bS4kY3JlYXRlRWxlbWVudDt2YXIgX2M9X3ZtLl9zZWxmLl9jfHxfaDtyZXR1cm4gX2MoJ2Rpdicse3N0YXRpY0NsYXNzOlwicm93XCJ9LFtfYygnZGl2Jyx7c3RhdGljQ2xhc3M6XCJjb2wtbWQtNlwifSxbX2MoJ2Rpdicse3N0YXRpY0NsYXNzOlwiZm9ybS1ncm91cFwifSxbX2MoJ2xhYmVsJyxbX3ZtLl92KFwiSUJBTiDigJMgc2FucyBlc3BhY2UqXCIpXSksX2MoJ2lucHV0Jyx7c3RhdGljQ2xhc3M6XCJmb3JtLWNvbnRyb2wgSUJBTlwiLGF0dHJzOntcInR5cGVcIjpcInRleHRcIixcImlkXCI6XCJcIixcInBsYWNlaG9sZGVyXCI6XCJJQkFOIOKAkyBzYW5zIGVzcGFjZSpcIixcIm5hbWVcIjpcIklCQU5cIixcImRhdGEtcnVsZS1yZXF1aXJlZFwiOlwidHJ1ZVwiLFwiZGF0YS1tc2ctcmVxdWlyZWRcIjpcIklCQU4g4oCTIHNhbnMgZXNwYWNlKiBjaGFtcCBlc3Qgb2JsaWdhdG9pcmUuXCJ9fSldKV0pLF9jKCdkaXYnLHtzdGF0aWNDbGFzczpcImNvbC1tZC02XCJ9LFtfYygnZGl2Jyx7c3RhdGljQ2xhc3M6XCJmb3JtLWdyb3VwXCJ9LFtfYygnbGFiZWwnLFtfdm0uX3YoXCJSZWN0byBwacOoY2UgZCdpZGVudGl0w6kgKGZvcm1hdCBqcGcpKlwiKV0pLF9jKCdkaXYnLHthdHRyczp7XCJpZFwiOlwiZmlsZVVwbG9hZFwifX0sW19jKCdwJyx7c3RhdGljQ2xhc3M6XCJjaG9vc2VfYnRuXCJ9LFtfdm0uX3YoXCJJbXBvcnRlclwiKV0pXSksX2MoJ2lucHV0Jyx7YXR0cnM6e1widHlwZVwiOlwiZmlsZVwiLFwiaWRcIjpcImRvY19mcm9udFwiLFwibmFtZVwiOlwiZG9jX2Zyb250XCIsXCJkYXRhLXJ1bGUtcmVxdWlyZWRcIjpcInRydWVcIixcImRhdGEtbXNnLXJlcXVpcmVkXCI6XCJEb2N1bWVudCBmcm9udCBjaGFtcCBlc3Qgb2JsaWdhdG9pcmUuXCJ9fSksX2MoJ3NwYW4nLHtzdGF0aWNDbGFzczpcImRvY19mcm9udFwifSksX2MoJ3AnLHtzdGF0aWNDbGFzczpcImVycm9yX2ZpbGVcIn0sW192bS5fdihcIlZldWlsbGV6IHPDqWxlY3Rpb25uZXIgdW4gZG9jdW1lbnRcIildKV0pXSldKX0sZnVuY3Rpb24gKCkge3ZhciBfdm09dGhpczt2YXIgX2g9X3ZtLiRjcmVhdGVFbGVtZW50O3ZhciBfYz1fdm0uX3NlbGYuX2N8fF9oO3JldHVybiBfYygnZGl2Jyx7c3RhdGljQ2xhc3M6XCJyb3dcIn0sW19jKCdkaXYnLHtzdGF0aWNDbGFzczpcImNvbC1tZC02XCJ9LFtfYygnZGl2Jyx7c3RhdGljQ2xhc3M6XCJmb3JtLWdyb3VwXCJ9LFtfYygnbGFiZWwnLFtfdm0uX3YoXCJWZXJzbyBwacOoY2UgZCdpZGVudGl0w6kgKGZvcm1hdCBqcGcpKlwiKV0pLF9jKCdkaXYnLHthdHRyczp7XCJpZFwiOlwiZmlsZVVwbG9hZF8yXCJ9fSxbX2MoJ3AnLHtzdGF0aWNDbGFzczpcImNob29zZV9idG5cIn0sW192bS5fdihcIkltcG9ydGVyXCIpXSldKSxfYygnaW5wdXQnLHthdHRyczp7XCJ0eXBlXCI6XCJmaWxlXCIsXCJpZFwiOlwiZG9jX2JhY2tcIixcIm5hbWVcIjpcImRvY19iYWNrXCIsXCJkYXRhLXJ1bGUtcmVxdWlyZWRcIjpcInRydWVcIixcImRhdGEtbXNnLXJlcXVpcmVkXCI6XCJEb2N1bWVudCBiYWNrIGNoYW1wIGVzdCBvYmxpZ2F0b2lyZS5cIn19KSxfYygncCcse3N0YXRpY0NsYXNzOlwiZXJyb3JfZmlsZV8xXCJ9LFtfdm0uX3YoXCJWZXVpbGxleiBzw6lsZWN0aW9ubmVyIHVuIGRvY3VtZW50XCIpXSksX2MoJ3NwYW4nLHtzdGF0aWNDbGFzczpcImRvY19iYWNrXCJ9KV0pXSksX2MoJ2Rpdicse3N0YXRpY0NsYXNzOlwiY29sLW1kLTZcIn0sW19jKCdkaXYnLHtzdGF0aWNDbGFzczpcImZvcm0tZ3JvdXBcIn0sW19jKCdsYWJlbCcsW192bS5fdihcIlJlY3RvIGRvY3VtZW50IGNvbXBsw6ltZW50YWlyZSAow6AgZMOpZmF1dCByZW1ldHRyZSBsYSBwacOoY2UgZCdpZGVudGl0w6kgcmVjdG8pKlwiKV0pLF9jKCdkaXYnLHthdHRyczp7XCJpZFwiOlwiZmlsZVVwbG9hZF8zXCJ9fSxbX2MoJ3AnLHtzdGF0aWNDbGFzczpcImNob29zZV9idG5cIn0sW192bS5fdihcIkltcG9ydGVyXCIpXSldKSxfYygnaW5wdXQnLHthdHRyczp7XCJ0eXBlXCI6XCJmaWxlXCIsXCJpZFwiOlwiYWRkaXRpb25hbF9kb2NfZnJvbnRcIixcIm5hbWVcIjpcImFkZGl0aW9uYWxfZG9jX2Zyb250XCIsXCJkYXRhLXJ1bGUtcmVxdWlyZWRcIjpcInRydWVcIixcImRhdGEtbXNnLXJlcXVpcmVkXCI6XCJBZGRpdGlvbmFsIERvY3VtZW50IGJhY2sgY2hhbXAgZXN0IG9ibGlnYXRvaXJlLlwifX0pLF9jKCdwJyx7c3RhdGljQ2xhc3M6XCJlcnJvcl9maWxlXzJcIn0sW192bS5fdihcIlZldWlsbGV6IHPDqWxlY3Rpb25uZXIgdW4gZG9jdW1lbnRcIildKSxfYygnc3Bhbicse3N0YXRpY0NsYXNzOlwiYWRkaXRpb25hbF9kb2NfZnJvbnRcIn0pXSldKV0pfSxmdW5jdGlvbiAoKSB7dmFyIF92bT10aGlzO3ZhciBfaD1fdm0uJGNyZWF0ZUVsZW1lbnQ7dmFyIF9jPV92bS5fc2VsZi5fY3x8X2g7cmV0dXJuIF9jKCdkaXYnLHtzdGF0aWNDbGFzczpcInJvd1wifSxbX2MoJ2Rpdicse3N0YXRpY0NsYXNzOlwiY29sLW1kLTZcIn0sW19jKCdkaXYnLHtzdGF0aWNDbGFzczpcImZvcm0tZ3JvdXBcIn0sW19jKCdkaXYnLHtzdGF0aWNDbGFzczpcInF1Zm9ybS1pbnB1dFwifSxbX2MoJ2xhYmVsJyxbX3ZtLl92KFwiVmVyc28gZG9jdW1lbnQgY29tcGzDqW1lbnRhaXJlICjDoCBkw6lmYXV0IHJlbWV0dHJlIGxhIHBpw6hjZSBkJ2lkZW50aXTDqSB2ZXJzbykqXCIpXSksX2MoJ2Rpdicse2F0dHJzOntcImlkXCI6XCJmaWxlVXBsb2FkXzRcIn19LFtfYygncCcse3N0YXRpY0NsYXNzOlwiY2hvb3NlX2J0blwifSxbX3ZtLl92KFwiSW1wb3J0ZXJcIildKV0pLF9jKCdpbnB1dCcse2F0dHJzOntcInR5cGVcIjpcImZpbGVcIixcImlkXCI6XCJhZGRpdGlvbmFsX2RvY19iYWNrXCIsXCJuYW1lXCI6XCJhZGRpdGlvbmFsX2RvY19iYWNrXCIsXCJkYXRhLXJ1bGUtcmVxdWlyZWRcIjpcInRydWVcIixcImRhdGEtbXNnLXJlcXVpcmVkXCI6XCJBZGRpdGlvbmFsIERvY3VtZW50IGJhY2sgY2hhbXAgZXN0IG9ibGlnYXRvaXJlLlwifX0pLF9jKCdwJyx7c3RhdGljQ2xhc3M6XCJlcnJvcl9maWxlXzNcIn0sW192bS5fdihcIlZldWlsbGV6IHPDqWxlY3Rpb25uZXIgdW4gZG9jdW1lbnRcIildKSxfYygnc3Bhbicse3N0YXRpY0NsYXNzOlwiYWRkaXRpb25hbF9kb2NfYmFja1wifSldKV0pLF9jKCdkaXYnLHtzdGF0aWNDbGFzczpcImNvbC1tZC02XCJ9LFtfYygnZGl2Jyx7c3RhdGljQ2xhc3M6XCJmb3JtLWdyb3VwXCJ9KV0pXSldKX1dXG5cbmV4cG9ydCB7IHJlbmRlciwgc3RhdGljUmVuZGVyRm5zIH0iLCI8dGVtcGxhdGU+XHJcbiAgPGRpdj5cclxuICAgIDxkaXYgY2xhc3M9XCJhamF4LWxvYWRlclwiPlxyXG4gICAgPCEtLSA8aW1nIHNyYz1cIjw/PWJhc2VfdXJsKCk7Pz51cGxvYWRpbWFnZXMvYWpheC1sb2FkZXIuZ2lmXCIgY2xhc3M9XCJpbWctcmVzcG9uc2l2ZVwiIC8+LS0+XHJcbiAgICA8c3ZnIHdpZHRoPVwiMTM1XCIgaGVpZ2h0PVwiMTM1XCIgdmlld0JveD1cIjAgMCAxMzUgMTM1XCIgeG1sbnM9XCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1wiIGZpbGw9XCIjQTdEMDhFXCIgc3R5bGU9XCJwb3NpdGlvbjogZml4ZWQ7IHRvcDogNTAlO1xyXG4gICAgICBsZWZ0OiA1MCU7dHJhbnNmb3JtOnRyYW5zbGF0ZSgtNTAlLCAtNTAlKTtcIj5cclxuICAgICAgPHBhdGggZD1cIk02Ny40NDcgNThjNS41MjMgMCAxMC00LjQ3NyAxMC0xMHMtNC40NzctMTAtMTAtMTAtMTAgNC40NzctMTAgMTAgNC40NzcgMTAgMTAgMTB6bTkuNDQ4IDkuNDQ3YzAgNS41MjMgNC40NzcgMTAgMTAgMTAgNS41MjIgMCAxMC00LjQ3NyAxMC0xMHMtNC40NzgtMTAtMTAtMTBjLTUuNTIzIDAtMTAgNC40NzctMTAgMTB6bS05LjQ0OCA5LjQ0OGMtNS41MjMgMC0xMCA0LjQ3Ny0xMCAxMCAwIDUuNTIyIDQuNDc3IDEwIDEwIDEwczEwLTQuNDc4IDEwLTEwYzAtNS41MjMtNC40NzctMTAtMTAtMTB6TTU4IDY3LjQ0N2MwLTUuNTIzLTQuNDc3LTEwLTEwLTEwcy0xMCA0LjQ3Ny0xMCAxMCA0LjQ3NyAxMCAxMCAxMCAxMC00LjQ3NyAxMC0xMHpcIj5cclxuICAgICAgICA8YW5pbWF0ZVRyYW5zZm9ybVxyXG4gICAgICAgICAgICBhdHRyaWJ1dGVOYW1lPVwidHJhbnNmb3JtXCJcclxuICAgICAgICAgICAgdHlwZT1cInJvdGF0ZVwiXHJcbiAgICAgICAgICAgIGZyb209XCIwIDY3IDY3XCJcclxuICAgICAgICAgICAgdG89XCItMzYwIDY3IDY3XCJcclxuICAgICAgICAgICAgZHVyPVwiMi41c1wiXHJcbiAgICAgICAgICAgIHJlcGVhdENvdW50PVwiaW5kZWZpbml0ZVwiLz5cclxuICAgICAgPC9wYXRoPlxyXG4gICAgICA8cGF0aCBkPVwiTTI4LjE5IDQwLjMxYzYuNjI3IDAgMTItNS4zNzQgMTItMTIgMC02LjYyOC01LjM3My0xMi0xMi0xMi02LjYyOCAwLTEyIDUuMzcyLTEyIDEyIDAgNi42MjYgNS4zNzIgMTIgMTIgMTJ6bTMwLjcyLTE5LjgyNWM0LjY4NiA0LjY4NyAxMi4yODQgNC42ODcgMTYuOTcgMCA0LjY4Ni00LjY4NiA0LjY4Ni0xMi4yODQgMC0xNi45Ny00LjY4Ni00LjY4Ny0xMi4yODQtNC42ODctMTYuOTcgMC00LjY4NyA0LjY4Ni00LjY4NyAxMi4yODQgMCAxNi45N3ptMzUuNzQgNy43MDVjMCA2LjYyNyA1LjM3IDEyIDEyIDEyIDYuNjI2IDAgMTItNS4zNzMgMTItMTIgMC02LjYyOC01LjM3NC0xMi0xMi0xMi02LjYzIDAtMTIgNS4zNzItMTIgMTJ6bTE5LjgyMiAzMC43MmMtNC42ODYgNC42ODYtNC42ODYgMTIuMjg0IDAgMTYuOTcgNC42ODcgNC42ODYgMTIuMjg1IDQuNjg2IDE2Ljk3IDAgNC42ODctNC42ODYgNC42ODctMTIuMjg0IDAtMTYuOTctNC42ODUtNC42ODctMTIuMjgzLTQuNjg3LTE2Ljk3IDB6bS03LjcwNCAzNS43NGMtNi42MjcgMC0xMiA1LjM3LTEyIDEyIDAgNi42MjYgNS4zNzMgMTIgMTIgMTJzMTItNS4zNzQgMTItMTJjMC02LjYzLTUuMzczLTEyLTEyLTEyem0tMzAuNzIgMTkuODIyYy00LjY4Ni00LjY4Ni0xMi4yODQtNC42ODYtMTYuOTcgMC00LjY4NiA0LjY4Ny00LjY4NiAxMi4yODUgMCAxNi45NyA0LjY4NiA0LjY4NyAxMi4yODQgNC42ODcgMTYuOTcgMCA0LjY4Ny00LjY4NSA0LjY4Ny0xMi4yODMgMC0xNi45N3ptLTM1Ljc0LTcuNzA0YzAtNi42MjctNS4zNzItMTItMTItMTItNi42MjYgMC0xMiA1LjM3My0xMiAxMnM1LjM3NCAxMiAxMiAxMmM2LjYyOCAwIDEyLTUuMzczIDEyLTEyem0tMTkuODIzLTMwLjcyYzQuNjg3LTQuNjg2IDQuNjg3LTEyLjI4NCAwLTE2Ljk3LTQuNjg2LTQuNjg2LTEyLjI4NC00LjY4Ni0xNi45NyAwLTQuNjg3IDQuNjg2LTQuNjg3IDEyLjI4NCAwIDE2Ljk3IDQuNjg2IDQuNjg3IDEyLjI4NCA0LjY4NyAxNi45NyAwelwiPlxyXG4gICAgICAgIDxhbmltYXRlVHJhbnNmb3JtXHJcbiAgICAgICAgICAgIGF0dHJpYnV0ZU5hbWU9XCJ0cmFuc2Zvcm1cIlxyXG4gICAgICAgICAgICB0eXBlPVwicm90YXRlXCJcclxuICAgICAgICAgICAgZnJvbT1cIjAgNjcgNjdcIlxyXG4gICAgICAgICAgICB0bz1cIjM2MCA2NyA2N1wiXHJcbiAgICAgICAgICAgIGR1cj1cIjhzXCJcclxuICAgICAgICAgICAgcmVwZWF0Q291bnQ9XCJpbmRlZmluaXRlXCIvPlxyXG4gICAgICA8L3BhdGg+XHJcbiAgICA8L3N2Zz5cclxuICA8L2Rpdj5cclxuICAgIDxkaXYgY2xhc3M9XCJsYXlvdXQtcHgtc3BhY2luZ1wiPlxyXG4gICAgPGRpdiBjbGFzcz1cInJvdyBsYXlvdXQtdG9wLXNwYWNpbmdcIj48L2Rpdj5cclxuICAgIDxkaXYgY2xhc3M9XCJ3aWRnZXQtY29udGVudCB3aWRnZXQtY29udGVudC1hcmVhIGN1c3RvbS1ib3JkZXItcmFkaXVzXCI+XHJcbiAgICAgIDxmb3JtIGlkPVwicmVnaXN0ZXJfc3BlY2lhbGlzdF9mbVwiIGNsYXNzPVwiY29udGFjdFwiPlxyXG4gICAgICAgIDxkaXYgY2xhc3M9XCJpbmZvXCI+XHJcbiAgICAgICAgICA8ZGl2IGNsYXNzPVwicm93XCI+XHJcbiAgICAgICAgICAgIDxkaXYgY2xhc3M9XCJjb2wtbWQtMTIgY29sLWxnLTEyIGNvbC1zbS0xMiBjb2wteHMtMTJcIj5cclxuICAgICAgICAgICAgICA8ZGl2IGNsYXNzPVwidXBsb2FkIHByLW1kLTRcIj5cclxuICAgICAgICAgICAgICAgIDxpbnB1dCB0eXBlPVwiZmlsZVwiIGlkPVwic3BlY2lhbGlzdF9waWN0dXJlXCIgbmFtZT1cInNwZWNpYWxpc3RfcGljdHVyZVwiIGNsYXNzPVwiZHJvcGlmeVwiIGRhdGEtbWF4LWZpbGUtc2l6ZT1cIjJNXCIgLz5cclxuICAgICAgICAgICAgICAgIDxwIGNsYXNzPVwibXQtMiB0ZXh0LWNlbnRlciB0ZXh0LWNhcGl0YWxpemVcIj48aSBjbGFzcz1cImZsYXRpY29uLWNsb3VkLXVwbG9hZCBtci0xIFwiPjwvaT5QaG90byBkdSBzcMOpY2lhbGlzdGU8L3A+XHJcbiAgICAgICAgICAgICAgPC9kaXY+XHJcbiAgICAgICAgICAgIDwvZGl2PlxyXG4gICAgICAgICAgPC9kaXY+XHJcbiAgICAgICAgICA8ZGl2IGNsYXNzPVwicm93XCI+XHJcbiAgICAgICAgICAgIDxkaXYgY2xhc3M9XCJjb2wtbWQtMTJcIiB2LWlmPVwiT2JqZWN0LmtleXMoZXJyb3JzKS5sZW5ndGhcIj5cclxuICAgICAgICAgICAgICA8ZGl2IGNsYXNzPVwiYWxlcnQgYWxlcnQtZGFuZ2VyXCI+XHJcbiAgICAgICAgICAgICAgICBXaG9vcHMsIHNvbWV0aGluZyB3ZW50IHdyb25nIVxyXG4gICAgICAgICAgICAgICAgPHVsPlxyXG4gICAgICAgICAgICAgICAgICA8bGkgc3R5bGU9XCJsaXN0LXN0eWxlOiB1bnNldDtcIiB2LWZvcj1cImVycm9yIGluIE9iamVjdC5rZXlzKGVycm9ycylcIiA6a2V5PVwiZXJyb3JcIj57e2Vycm9yc1tlcnJvcl1bMF19fTwvbGk+XHJcbiAgICAgICAgICAgICAgICA8L3VsPlxyXG4gICAgICAgICAgICAgIDwvZGl2PlxyXG4gICAgICAgICAgICA8L2Rpdj5cclxuXHJcbiAgICAgICAgICAgIDxkaXYgY2xhc3M9XCJjb2wtbWQtMTJcIj5cclxuICAgICAgICAgICAgICA8aDMgY2xhc3M9XCJzcGVjaWFsaXN0LWluZm8tdGV4dFwiPkluZm9ybWF0aW9uIHNww6ljaWFsaXPDqWU8L2gzPlxyXG4gICAgICAgICAgICAgIDxkaXYgY2xhc3M9XCJyb3dcIj5cclxuICAgICAgICAgICAgICAgIDxkaXYgY2xhc3M9XCJjb2wtbWQtNlwiPlxyXG4gICAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzPVwiZm9ybS1ncm91cFwiPlxyXG4gICAgICAgICAgICAgICAgICAgIDxsYWJlbCBmb3I9XCJmaXJzdF9uYW1lXCI+UHLDqW5vbSBkdSBzcMOpY2lhbGlzdGU8L2xhYmVsPlxyXG4gICAgICAgICAgICAgICAgICAgIDxpbnB1dCB0eXBlPVwidGV4dFwiIGNsYXNzPVwiZm9ybS1jb250cm9sIG1iLTQgaW5wLXBlcnNvbi1maXJzdC1uYW1lXCIgaWQ9XCJmaXJzdF9uYW1lXCIgbmFtZT1cImZpcnN0X25hbWVcIiBwbGFjZWhvbGRlcj1cIlByw6lub20gZHUgc3DDqWNpYWxpc3RlXCIgdi1tb2RlbD1cImZvcm0udXNlci5maXJzdG5hbWVcIj5cclxuICAgICAgICAgICAgICAgICAgPC9kaXY+XHJcbiAgICAgICAgICAgICAgICA8L2Rpdj5cclxuICAgICAgICAgICAgICAgIDxkaXYgY2xhc3M9XCJjb2wtbWQtNlwiPlxyXG4gICAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzPVwiZm9ybS1ncm91cFwiPlxyXG4gICAgICAgICAgICAgICAgICAgIDxsYWJlbCBmb3I9XCJsYXN0X25hbWVcIj5Ob20gZGUgZmFtaWxsZSBkdSBzcMOpY2lhbGlzdGU8L2xhYmVsPlxyXG4gICAgICAgICAgICAgICAgICAgIDxpbnB1dCB0eXBlPVwidGV4dFwiIGNsYXNzPVwiaW5wLXBlcnNvbi1sYXN0LW5hbWUgZm9ybS1jb250cm9sIG1iLTRcIiBpZD1cImxhc3RfbmFtZVwiIG5hbWU9XCJsYXN0X25hbWVcIiBwbGFjZWhvbGRlcj1cIk5vbSBkZSBmYW1pbGxlIGR1IHNww6ljaWFsaXN0ZVwiIHYtbW9kZWw9XCJmb3JtLnVzZXIubGFzdG5hbWVcIj5cclxuICAgICAgICAgICAgICAgICAgPC9kaXY+XHJcbiAgICAgICAgICAgICAgICA8L2Rpdj5cclxuICAgICAgICAgICAgICA8L2Rpdj5cclxuICAgICAgICAgICAgICA8ZGl2IGNsYXNzPVwicm93XCI+XHJcbiAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzPVwiY29sLW1kLTZcIj5cclxuICAgICAgICAgICAgICAgICAgPGRpdiBjbGFzcz1cImZvcm0tZ3JvdXBcIj5cclxuICAgICAgICAgICAgICAgICAgICA8bGFiZWwgZm9yPVwic3BlY2lhbGl0eWNhdGVnb3J5X2lkX2ZrXCI+U3DDqWNpYWxpc3RlPC9sYWJlbD5cclxuICAgICAgICAgICAgICAgICAgICA8c2VsZWN0IGNsYXNzPVwiZm9ybS1jb250cm9sIHNwZWNpYWxpc3RfY2F0ZWdvcnkgdGFnZ2luZ1wiIGlkPVwic3BlY2lhbGl0eWNhdGVnb3J5X2lkX2ZrXCIgbmFtZT1cInNwZWNpYWxpdHljYXRlZ29yeV9pZF9ma1wiIG11bHRpcGxlPVwidHJ1ZVwiPlxyXG4gICAgICAgICAgICAgICAgICAgICAgPG9wdGlvbiB2LWZvcj1cInNwZWNpYWxpdHkgaW4gc3BlY2lhbGl0aWVzXCIgOnZhbHVlPVwic3BlY2lhbGl0eS5zcGVjaWFsaXR5X2lkXCI+e3tzcGVjaWFsaXR5Lm5hbWV9fTwvb3B0aW9uPlxyXG4gICAgICAgICAgICAgICAgICAgIDwvc2VsZWN0PlxyXG4gICAgICAgICAgICAgICAgICAgIDxici8+XHJcbiAgICAgICAgICAgICAgICAgIDwvZGl2PlxyXG4gICAgICAgICAgICAgICAgPC9kaXY+XHJcbiAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzPVwiY29sLW1kLTZcIj5cclxuICAgICAgICAgICAgICAgICAgPGRpdiBjbGFzcz1cImZvcm0tZ3JvdXBcIj5cclxuICAgICAgICAgICAgICAgICAgICA8bGFiZWwgZm9yPVwiZW1haWxcIj5BZHJlc3NlIMOpbGVjdHJvbmlxdWU8L2xhYmVsPlxyXG4gICAgICAgICAgICAgICAgICAgIDxpbnB1dCB0eXBlPVwiZW1haWxcIiBjbGFzcz1cImZvcm0tY29udHJvbCBtYi00IGlucC1lbWFpbFwiIGlkPVwiZW1haWxcIiBuYW1lPVwiZW1haWxcIiBwbGFjZWhvbGRlcj1cIkFkcmVzc2Ugw6lsZWN0cm9uaXF1ZVwiIHYtbW9kZWw9XCJmb3JtLnVzZXIuZW1haWxcIj5cclxuICAgICAgICAgICAgICAgICAgICA8c3BhbiBpZD1cImVtYWlsX2Vycm9yXCI+PC9zcGFuPlxyXG4gICAgICAgICAgICAgICAgICA8L2Rpdj5cclxuICAgICAgICAgICAgICAgIDwvZGl2PlxyXG4gICAgICAgICAgICAgIDwvZGl2PlxyXG4gICAgICAgICAgICAgIDxkaXYgY2xhc3M9XCJyb3dcIj5cclxuICAgICAgICAgICAgICAgIDxkaXYgY2xhc3M9XCJjb2wtbWQtNlwiPlxyXG4gICAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzPVwiZm9ybS1ncm91cFwiPlxyXG4gICAgICAgICAgICAgICAgICAgIDxsYWJlbCBmb3I9XCJtb2JpbGVfbnVtYmVyXCI+TnVtw6lybyBkZSBwb3J0YWJsZTwvbGFiZWw+XHJcbiAgICAgICAgICAgICAgICAgICAgPGlucHV0IHR5cGU9XCJ0ZXh0XCIgY2xhc3M9XCJmb3JtLWNvbnRyb2wgbWItNCBpbnAtcGhvbmVcIiBpZD1cIm1vYmlsZV9udW1iZXJcIiBuYW1lPVwibW9iaWxlX251bWJlclwiIG1heGxlbmd0aD1cIjEwXCIgcGxhY2Vob2xkZXI9XCJOdW3DqXJvIGRlIHBvcnRhYmxlXCIgdi1tb2RlbD1cImZvcm0udXNlci5waG9uZV9udW1iZXJcIiBkYXRhLXJ1bGUtbWlubGVuZ3RoPVwiMTBcIiBkYXRhLW1zZy1taW5sZW5ndGggPVwiTnVtw6lybyBkZSBwb3J0YWJsZSBMYSBsb25ndWV1ciBlc3QgZGUgMTBcIj5cclxuICAgICAgICAgICAgICAgICAgICA8c3BhbiBpZD1cIm1vYmlsZV9lcnJvclwiPjwvc3Bhbj5cclxuICAgICAgICAgICAgICAgICAgPC9kaXY+XHJcbiAgICAgICAgICAgICAgICA8L2Rpdj5cclxuICAgICAgICAgICAgICAgIDxkaXYgY2xhc3M9XCJjb2wtbWQtNlwiID5cclxuICAgICAgICAgICAgICAgICAgPGRpdiBjbGFzcz1cImZvcm0tZ3JvdXBcIj5cclxuICAgICAgICAgICAgICAgICAgICA8bGFiZWwgZm9yPVwicHJhY3RpY2Vfc3RhcnRfZGF0ZVwiPkRhdGUgZGUgZMOpYnV0PC9sYWJlbD5cclxuICAgICAgICAgICAgICAgICAgICA8aW5wdXQgdHlwZT1cInRleHRcIiBpZD1cInByYWN0aWNlX3N0YXJ0X2RhdGUxXCIgbmFtZT1cInByYWN0aWNlX3N0YXJ0X2RhdGVcIiBjbGFzcz1cImZvcm0tY29udHJvbCBmbGF0cGlja3IgZmxhdHBpY2tyLWlucHV0IGFjdGl2ZVwiICBwbGFjZWhvbGRlcj1cIkRhdGUgZGUgZMOpYnV0XCIgdi1tb2RlbD1cImZvcm0ucHJhY3RpY2Vfc3RhcnRfZGF0ZVwiPlxyXG4gICAgICAgICAgICAgICAgICA8L2Rpdj5cclxuICAgICAgICAgICAgICAgIDwvZGl2PlxyXG4gICAgICAgICAgICAgIDwvZGl2PlxyXG4gICAgICAgICAgICAgIDxkaXYgY2xhc3M9XCJyb3dcIj5cclxuPCEtLSAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzPVwiY29sLW1kLTZcIiA+XHJcbiAgICAgICAgICAgICAgICAgIDxkaXYgY2xhc3M9XCJmb3JtLWdyb3VwXCI+XHJcbiAgICAgICAgICAgICAgICAgICAgPGxhYmVsPk5vbSBjb21wbGV0PC9sYWJlbD5cclxuICAgICAgICAgICAgICAgICAgICA8aW5wdXQgdHlwZT1cInRleHRcIiBpZD1cImZ1bGxuYW1lXCIgIGNsYXNzPVwiZm9ybS1jb250cm9sXCIgcGxhY2Vob2xkZXI9XCJOb20gY29tcGxldFwiIG5hbWU9XCJmdWxsbmFtZVwiIGRhdGEtcnVsZS1yZXF1aXJlZD1cInRydWVcIiBkYXRhLW1zZy1yZXF1aXJlZD1cIk5vbSBjb21wbGV0IGNoYW1wIGVzdCBvYmxpZ2F0b2lyZS5cIi8+XHJcbiAgICAgICAgICAgICAgICAgIDwvZGl2PlxyXG4gICAgICAgICAgICAgICAgPC9kaXY+LS0+XHJcbiAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzPVwiY29sLW1kLTZcIiA+XHJcbiAgICAgICAgICAgICAgICAgIDxkaXYgY2xhc3M9XCJmb3JtLWdyb3VwXCI+XHJcbiAgICAgICAgICAgICAgICAgICAgPGxhYmVsPkFkcmVzc2Ugc3DDqWNpYWxpc3RlIOKAkyBMaWduZSAxIChleGVtcGxlIDogMzMgcnVlIGNlbnNpZXIpKjwvbGFiZWw+XHJcbiAgICAgICAgICAgICAgICAgICAgPGlucHV0IHR5cGU9XCJ0ZXh0XCIgY2xhc3M9XCJmb3JtLWNvbnRyb2wgaW5wLWNvbXBhbnktc3RyZWV0LWFkZHJlc3MxXCIgcGxhY2Vob2xkZXI9XCJBZHJlc3NlIHNww6ljaWFsaXN0ZSDigJMgTGlnbmUgMSAoZXhlbXBsZSA6IDMzIHJ1ZSBjZW5zaWVyKSpcIiBuYW1lID1cIm93bmVyX2FkZHJlc3NfbGluZTFcIiBkYXRhLXJ1bGUtcmVxdWlyZWQ9XCJ0cnVlXCIgZGF0YS1tc2ctcmVxdWlyZWQ9XCJBZHJlc3NlIHNww6ljaWFsaXN0ZSDigJMgTGlnbmUgMSAoZXhlbXBsZSA6IDMzIHJ1ZSBjZW5zaWVyKSogY2hhbXAgZXN0IG9ibGlnYXRvaXJlLlwiIHYtbW9kZWw9XCJmb3JtLmFkZHJlc3Nlc1swXS5zdHJlZXRfYWRkcmVzc1wiIC8+XHJcbiAgICAgICAgICAgICAgICAgIDwvZGl2PlxyXG4gICAgICAgICAgICAgICAgPC9kaXY+XHJcbiAgICAgICAgICAgICAgPC9kaXY+XHJcbiAgICAgICAgICAgICAgPGRpdiBjbGFzcz1cInJvd1wiPlxyXG4gICAgICAgICAgICAgICAgPGRpdiBjbGFzcz1cImNvbC1tZC02XCIgPlxyXG4gICAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzPVwiZm9ybS1ncm91cFwiPlxyXG4gICAgICAgICAgICAgICAgICAgIDxsYWJlbD5BZHJlc3NlIHNww6ljaWFsaXN0ZSDigJMgTGlnbmUgMiAoZXhlbXBsZTogUsOpc2lkZW5jZSwgbWFpc29uLCBldGMuLikqPC9sYWJlbD5cclxuICAgICAgICAgICAgICAgICAgICA8aW5wdXQgdHlwZT1cInRleHRcIiBjbGFzcz1cImZvcm0tY29udHJvbCBhZGRfMlwiIHBsYWNlaG9sZGVyPVwiQWRyZXNzZSBzcMOpY2lhbGlzdGUg4oCTIExpZ25lIDIgKGV4ZW1wbGU6IFLDqXNpZGVuY2UsIG1haXNvbiwgZXRjLi4pKlwiIG5hbWUgPVwib3duZXJfYWRkcmVzc19saW5lMlwiIGRhdGEtcnVsZS1yZXF1aXJlZD1cInRydWVcIiBkYXRhLW1zZy1yZXF1aXJlZD1cIkFkcmVzc2Ugc3DDqWNpYWxpc3RlIOKAkyBMaWduZSAyIChleGVtcGxlOiBSw6lzaWRlbmNlLCBtYWlzb24sIGV0Yy4uKSogY2hhbXAgZXN0IG9ibGlnYXRvaXJlLlwiIHYtbW9kZWw9XCJmb3JtLmFkZHJlc3Nlc1sxXS5zdHJlZXRfYWRkcmVzc1wiIC8+XHJcbiAgICAgICAgICAgICAgICAgIDwvZGl2PlxyXG4gICAgICAgICAgICAgICAgPC9kaXY+XHJcbiAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzPVwiY29sLW1kLTZcIiA+XHJcbiAgICAgICAgICAgICAgICAgIDxsYWJlbD5QYXlzPC9sYWJlbD5cclxuICAgICAgICAgICAgICAgICAgPHNlbGVjdCBjbGFzcz1cImZvcm0tY29udHJvbCBpbml0LXNlbGVjdDIgc2VsZWN0LWZpZWxkXCIgbmFtZT1cImNvdW50cnlcIiBpZD1cInNlbF9jb3VudHJ5XCIgZGF0YS1ydWxlLXJlcXVpcmVkPVwidHJ1ZVwiIGRhdGEtbXNnLXJlcXVpcmVkPVwiUGF5cyBjaGFtcCBlc3Qgb2JsaWdhdG9pcmUuXCIgdi1tb2RlbD1cImZvcm0udXNlci5wcm9maWxlLmNvdW50cnlfaWRcIiBzdHlsZT1cInBhZGRpbmctbGVmdDoycHg7XCI+XHJcbiAgICAgICAgICAgICAgICAgICAgPG9wdGlvbiBzZWxlY3RlZCBkaXNhYmxlZCB2YWx1ZT1cIlwiPlBheXM8L29wdGlvbj5cclxuICAgICAgICAgICAgICAgICAgICA8b3B0aW9uIHYtZm9yPVwiY291bnRyeSBpbiBjb3VudHJpZXNcIiA6a2V5PVwiY291bnRyeS5pZFwiIDp2YWx1ZT1cImNvdW50cnkuaWRcIj57e2NvdW50cnkubmFtZS5lbn19PC9vcHRpb24+XHJcbiAgICAgICAgICAgICAgICAgIDwvc2VsZWN0PlxyXG4gICAgICAgICAgICAgICAgPC9kaXY+XHJcbiAgICAgICAgICAgICAgPC9kaXY+XHJcbiAgICAgICAgICAgICAgPGRpdiBjbGFzcz1cInJvd1wiPlxyXG48IS0tICAgICAgICAgICAgICAgIDxkaXYgY2xhc3M9XCJjb2wtbWQtNlwiID5cclxuICAgICAgICAgICAgICAgICAgPGRpdiBjbGFzcz1cImZvcm0tZ3JvdXBcIj5cclxuICAgICAgICAgICAgICAgICAgICA8bGFiZWw+Q29kZSBkw6lwYXJ0ZW1lbnQgKGV4ZW1wbGUgOiA3NSkqPC9sYWJlbD5cclxuICAgICAgICAgICAgICAgICAgICA8aW5wdXQgdHlwZT1cInRleHRcIiBjbGFzcz1cImZvcm0tY29udHJvbCBpbnAtY29tcGFueS1zdGF0ZVwiIHBsYWNlaG9sZGVyPVwiQ29kZSBkw6lwYXJ0ZW1lbnQgKGV4ZW1wbGUgOiA3NSkqXCIgbmFtZSA9XCJzdGF0ZVwiIGRhdGEtcnVsZS1yZXF1aXJlZD1cInRydWVcIiBkYXRhLW1zZy1yZXF1aXJlZD1cInN0YXRlIGNoYW1wIGVzdCBvYmxpZ2F0b2lyZS5cIiB2LW1vZGVsPVwiZm9ybS5wb3N0YWxfY29kZVwiIC8+XHJcbiAgICAgICAgICAgICAgICAgIDwvZGl2PlxyXG4gICAgICAgICAgICAgICAgPC9kaXY+LS0+XHJcbiAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzPVwiY29sLW1kLTZcIj5cclxuICAgICAgICAgICAgICAgICAgPGRpdiBjbGFzcz1cImZvcm0tZ3JvdXBcIj5cclxuICAgICAgICAgICAgICAgICAgICA8bGFiZWw+VmlsbGU8L2xhYmVsPlxyXG4gICAgICAgICAgICAgICAgICAgIDxzZWxlY3QgY2xhc3M9XCJmb3JtLWNvbnRyb2wgc2VsZWN0LWZpZWxkIGlucC1jb21wYW55LWNpdHlcIiBuYW1lPVwiY2l0eVwiIGlkPVwic2VsX2NpdHlcIiBkYXRhLXJ1bGUtcmVxdWlyZWQ9XCJ0cnVlXCIgZGF0YS1tc2ctcmVxdWlyZWQ9XCI8Pz0gJHRoaXMtPmxhbmctPmxpbmUoJ2NpdHknKSBjaGFtcCBlc3Qgb2JsaWdhdG9pcmUuXCJcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0eWxlPVwicGFkZGluZy1sZWZ0OjJweDtcIj5cclxuICAgICAgICAgICAgICAgICAgICAgIDxvcHRpb24gc2VsZWN0ZWQgZGlzYWJsZWQgdmFsdWU9XCJcIj5WaWxsZTwvb3B0aW9uPlxyXG4gICAgICAgICAgICAgICAgICAgICAgPG9wdGlvbiB2LWZvcj1cImNpdHkgaW4gY2l0aWVzXCIgOmtleT1cImNpdHkuaWRcIiA6dmFsdWU9XCJjaXR5LmlkXCI+e3tjaXR5Lm5hbWUuZW59fTwvb3B0aW9uPlxyXG4gICAgICAgICAgICAgICAgICAgIDwvc2VsZWN0PlxyXG4gICAgICAgICAgICAgICAgICA8L2Rpdj5cclxuICAgICAgICAgICAgICAgIDwvZGl2PlxyXG4gICAgICAgICAgICAgIDwvZGl2PlxyXG4gICAgICAgICAgICAgIDxkaXYgY2xhc3M9XCJyb3dcIj5cclxuICAgICAgICAgICAgICAgIDxkaXYgY2xhc3M9XCJjb2wtbWQtNlwiID5cclxuICAgICAgICAgICAgICAgICAgPGRpdiBjbGFzcz1cImZvcm0tZ3JvdXBcIj5cclxuICAgICAgICAgICAgICAgICAgICA8bGFiZWw+Q29kZSBwb3N0YWw8L2xhYmVsPlxyXG4gICAgICAgICAgICAgICAgICAgIDxpbnB1dCB0eXBlPVwidGV4dFwiIGNsYXNzPVwiZm9ybS1jb250cm9sIGlucC1wZXJzb24temlwXCIgcGxhY2Vob2xkZXI9XCJDb2RlIHBvc3RhbFwiIG5hbWU9XCJwb3N0YWxfY29kZVwiIGRhdGEtcnVsZS1yZXF1aXJlZD1cInRydWVcIiBkYXRhLW1zZy1yZXF1aXJlZD1cInBvc3RhbCBjb2RlIGNoYW1wIGVzdCBvYmxpZ2F0b2lyZS5cIiAvPlxyXG4gICAgICAgICAgICAgICAgICA8L2Rpdj5cclxuICAgICAgICAgICAgICAgIDwvZGl2PlxyXG4gICAgICAgICAgICAgICAgPGRpdiBjbGFzcz1cImNvbC1tZC02XCIgPlxyXG4gICAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzPVwiZm9ybS1ncm91cFwiPlxyXG4gICAgICAgICAgICAgICAgICAgIDxsYWJlbD5EYXRlIGRlIG5haXNzYW5jZTwvbGFiZWw+XHJcbiAgICAgICAgICAgICAgICAgICAgPGlucHV0IHR5cGU9XCJ0ZXh0XCIgaWQ9XCJkYXRlX29mX2JpcnRoXCIgbmFtZT1cImRhdGVfb2ZfYmlydGhcIiBjbGFzcz1cImZvcm0tY29udHJvbCBmbGF0cGlja3IgZmxhdHBpY2tyLWlucHV0IGFjdGl2ZSBkYXRlX29mX2JpcnRoXCIgIHBsYWNlaG9sZGVyPVwiRGF0ZSBkZSBuYWlzc2FuY2VcIiAgZGF0YS1ydWxlLXJlcXVpcmVkPVwidHJ1ZVwiIGRhdGEtbXNnLXJlcXVpcmVkPVwiRGF0ZSBjaGFtcCBlc3Qgb2JsaWdhdG9pcmUuXCIgdi1tb2RlbD1cImZvcm0udXNlci5wcm9maWxlLmRhdGVfb2ZfYmlydGhcIiAvPlxyXG4gICAgICAgICAgICAgICAgICA8L2Rpdj5cclxuICAgICAgICAgICAgICAgIDwvZGl2PlxyXG4gICAgICAgICAgICAgIDwvZGl2PlxyXG4gICAgICAgICAgICAgIDxkaXYgY2xhc3M9XCJyb3dcIj5cclxuICAgICAgICAgICAgICAgIDxkaXYgY2xhc3M9XCJjb2wtbWQtNlwiID5cclxuICAgICAgICAgICAgICAgICAgPGRpdiBjbGFzcz1cImZvcm0tZ3JvdXBcIj5cclxuICAgICAgICAgICAgICAgICAgICA8bGFiZWw+TnVtw6lybyBkZSBwacOoY2UgZCdpZGVudGl0w6kqPC9sYWJlbD5cclxuICAgICAgICAgICAgICAgICAgICA8aW5wdXQgdHlwZT1cInRleHRcIiBpZD1cImlkX251bWJlclwiIG5hbWU9XCJpZF9udW1iZXJcIiBjbGFzcz1cImZvcm0tY29udHJvbFwiICBwbGFjZWhvbGRlcj1cIk51bcOpcm8gZGUgcGnDqGNlIGQnaWRlbnRpdMOpKlwiICAvPlxyXG4gICAgICAgICAgICAgICAgICA8L2Rpdj5cclxuICAgICAgICAgICAgICAgIDwvZGl2PlxyXG4gICAgICAgICAgICAgICAgPGRpdiBjbGFzcz1cImNvbC1tZC02XCIgPlxyXG4gICAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzPVwiZm9ybS1ncm91cFwiPlxyXG4gICAgICAgICAgICAgICAgICAgIDxsYWJlbD5Ob20gZHUgdGl0dWxhaXJlIGR1IGNvbXB0ZTwvbGFiZWw+XHJcbiAgICAgICAgICAgICAgICAgICAgPGlucHV0IHR5cGU9XCJ0ZXh0XCIgaWQ9XCJhY2NvdW50X2hvbGRlcl9uYW1lXCIgbmFtZT1cImFjY291bnRfaG9sZGVyX25hbWVcIiBjbGFzcz1cImZvcm0tY29udHJvbFwiICBwbGFjZWhvbGRlcj1cIk5vbSBkdSB0aXR1bGFpcmUgZHUgY29tcHRlXCIgZGF0YS1ydWxlLXJlcXVpcmVkPVwidHJ1ZVwiIGRhdGEtbXNnLXJlcXVpcmVkPVwiTGUgY2hhbXAgZHUgbm9tIGR1IHRpdHVsYWlyZSBkdSBjb21wdGUgZXN0IG9ibGlnYXRvaXJlXCIgIC8+XHJcbiAgICAgICAgICAgICAgICAgIDwvZGl2PlxyXG4gICAgICAgICAgICAgICAgPC9kaXY+XHJcbiAgICAgICAgICAgICAgPC9kaXY+XHJcbiAgICAgICAgICAgICAgPGRpdiBjbGFzcz1cInJvd1wiPlxyXG4gICAgICAgICAgICAgICAgPGRpdiBjbGFzcz1cImNvbC1tZC02XCIgPlxyXG4gICAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzPVwiZm9ybS1ncm91cFwiPlxyXG4gICAgICAgICAgICAgICAgICAgIDxsYWJlbD5JQkFOIOKAkyBzYW5zIGVzcGFjZSo8L2xhYmVsPlxyXG4gICAgICAgICAgICAgICAgICAgIDxpbnB1dCB0eXBlPVwidGV4dFwiIGlkPVwiXCIgY2xhc3M9XCJmb3JtLWNvbnRyb2wgSUJBTlwiIHBsYWNlaG9sZGVyPVwiSUJBTiDigJMgc2FucyBlc3BhY2UqXCIgbmFtZT1cIklCQU5cIiBkYXRhLXJ1bGUtcmVxdWlyZWQ9XCJ0cnVlXCIgZGF0YS1tc2ctcmVxdWlyZWQ9XCJJQkFOIOKAkyBzYW5zIGVzcGFjZSogY2hhbXAgZXN0IG9ibGlnYXRvaXJlLlwiLz5cclxuICAgICAgICAgICAgICAgICAgPC9kaXY+XHJcbiAgICAgICAgICAgICAgICA8L2Rpdj5cclxuICAgICAgICAgICAgICAgIDxkaXYgY2xhc3M9XCJjb2wtbWQtNlwiID5cclxuICAgICAgICAgICAgICAgICAgPGRpdiBjbGFzcz1cImZvcm0tZ3JvdXBcIj5cclxuICAgICAgICAgICAgICAgICAgICA8bGFiZWw+UmVjdG8gcGnDqGNlIGQnaWRlbnRpdMOpIChmb3JtYXQganBnKSo8L2xhYmVsPlxyXG4gICAgICAgICAgICAgICAgICAgIDxkaXYgaWQ9XCJmaWxlVXBsb2FkXCI+XHJcbiAgICAgICAgICAgICAgICAgICAgICA8cCBjbGFzcz1cImNob29zZV9idG5cIj5JbXBvcnRlcjwvcD5cclxuICAgICAgICAgICAgICAgICAgICA8L2Rpdj5cclxuICAgICAgICAgICAgICAgICAgICA8aW5wdXQgdHlwZT1cImZpbGVcIiBpZD1cImRvY19mcm9udFwiIG5hbWU9XCJkb2NfZnJvbnRcIiBkYXRhLXJ1bGUtcmVxdWlyZWQ9XCJ0cnVlXCIgZGF0YS1tc2ctcmVxdWlyZWQ9XCJEb2N1bWVudCBmcm9udCBjaGFtcCBlc3Qgb2JsaWdhdG9pcmUuXCIvPlxyXG4gICAgICAgICAgICAgICAgICAgIDxzcGFuIGNsYXNzPVwiZG9jX2Zyb250XCI+PC9zcGFuPlxyXG4gICAgICAgICAgICAgICAgICAgIDxwIGNsYXNzPVwiZXJyb3JfZmlsZVwiPlZldWlsbGV6IHPDqWxlY3Rpb25uZXIgdW4gZG9jdW1lbnQ8L3A+XHJcbiAgICAgICAgICAgICAgICAgIDwvZGl2PlxyXG4gICAgICAgICAgICAgICAgPC9kaXY+XHJcbiAgICAgICAgICAgICAgPC9kaXY+XHJcbiAgICAgICAgICAgICAgPGRpdiBjbGFzcz1cInJvd1wiPlxyXG4gICAgICAgICAgICAgICAgPGRpdiBjbGFzcz1cImNvbC1tZC02XCIgPlxyXG4gICAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzPVwiZm9ybS1ncm91cFwiPlxyXG4gICAgICAgICAgICAgICAgICAgIDxsYWJlbD5WZXJzbyBwacOoY2UgZCdpZGVudGl0w6kgKGZvcm1hdCBqcGcpKjwvbGFiZWw+XHJcbiAgICAgICAgICAgICAgICAgICAgPGRpdiBpZD1cImZpbGVVcGxvYWRfMlwiPlxyXG4gICAgICAgICAgICAgICAgICAgICAgPHAgY2xhc3M9XCJjaG9vc2VfYnRuXCI+SW1wb3J0ZXI8L3A+XHJcbiAgICAgICAgICAgICAgICAgICAgPC9kaXY+XHJcbiAgICAgICAgICAgICAgICAgICAgPGlucHV0IHR5cGU9XCJmaWxlXCIgaWQ9XCJkb2NfYmFja1wiIG5hbWU9XCJkb2NfYmFja1wiIGRhdGEtcnVsZS1yZXF1aXJlZD1cInRydWVcIiBkYXRhLW1zZy1yZXF1aXJlZD1cIkRvY3VtZW50IGJhY2sgY2hhbXAgZXN0IG9ibGlnYXRvaXJlLlwiLz5cclxuICAgICAgICAgICAgICAgICAgICA8cCBjbGFzcz1cImVycm9yX2ZpbGVfMVwiPlZldWlsbGV6IHPDqWxlY3Rpb25uZXIgdW4gZG9jdW1lbnQ8L3A+XHJcbiAgICAgICAgICAgICAgICAgICAgPHNwYW4gY2xhc3M9XCJkb2NfYmFja1wiPjwvc3Bhbj5cclxuICAgICAgICAgICAgICAgICAgPC9kaXY+XHJcbiAgICAgICAgICAgICAgICA8L2Rpdj5cclxuICAgICAgICAgICAgICAgIDxkaXYgY2xhc3M9XCJjb2wtbWQtNlwiID5cclxuICAgICAgICAgICAgICAgICAgPGRpdiBjbGFzcz1cImZvcm0tZ3JvdXBcIj5cclxuICAgICAgICAgICAgICAgICAgICA8bGFiZWwgPlJlY3RvIGRvY3VtZW50IGNvbXBsw6ltZW50YWlyZSAow6AgZMOpZmF1dCByZW1ldHRyZSBsYSBwacOoY2UgZCdpZGVudGl0w6kgcmVjdG8pKjwvbGFiZWw+XHJcbiAgICAgICAgICAgICAgICAgICAgPGRpdiBpZD1cImZpbGVVcGxvYWRfM1wiPlxyXG4gICAgICAgICAgICAgICAgICAgICAgPHAgY2xhc3M9XCJjaG9vc2VfYnRuXCI+SW1wb3J0ZXI8L3A+XHJcbiAgICAgICAgICAgICAgICAgICAgPC9kaXY+XHJcbiAgICAgICAgICAgICAgICAgICAgPGlucHV0IHR5cGU9XCJmaWxlXCIgaWQ9XCJhZGRpdGlvbmFsX2RvY19mcm9udFwiIG5hbWU9XCJhZGRpdGlvbmFsX2RvY19mcm9udFwiIGRhdGEtcnVsZS1yZXF1aXJlZD1cInRydWVcIiBkYXRhLW1zZy1yZXF1aXJlZD1cIkFkZGl0aW9uYWwgRG9jdW1lbnQgYmFjayBjaGFtcCBlc3Qgb2JsaWdhdG9pcmUuXCIvPlxyXG4gICAgICAgICAgICAgICAgICAgIDxwIGNsYXNzPVwiZXJyb3JfZmlsZV8yXCI+VmV1aWxsZXogc8OpbGVjdGlvbm5lciB1biBkb2N1bWVudDwvcD5cclxuICAgICAgICAgICAgICAgICAgICA8c3BhbiBjbGFzcz1cImFkZGl0aW9uYWxfZG9jX2Zyb250XCI+PC9zcGFuPlxyXG4gICAgICAgICAgICAgICAgICA8L2Rpdj5cclxuICAgICAgICAgICAgICAgIDwvZGl2PlxyXG4gICAgICAgICAgICAgIDwvZGl2PlxyXG4gICAgICAgICAgICAgIDxkaXYgY2xhc3M9XCJyb3dcIj5cclxuICAgICAgICAgICAgICAgIDxkaXYgY2xhc3M9XCJjb2wtbWQtNlwiID5cclxuICAgICAgICAgICAgICAgICAgPGRpdiBjbGFzcz1cImZvcm0tZ3JvdXBcIj5cclxuICAgICAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzPVwicXVmb3JtLWlucHV0XCI+XHJcbiAgICAgICAgICAgICAgICAgICAgICA8bGFiZWw+VmVyc28gZG9jdW1lbnQgY29tcGzDqW1lbnRhaXJlICjDoCBkw6lmYXV0IHJlbWV0dHJlIGxhIHBpw6hjZSBkJ2lkZW50aXTDqSB2ZXJzbykqPC9sYWJlbD5cclxuICAgICAgICAgICAgICAgICAgICAgIDxkaXYgaWQ9XCJmaWxlVXBsb2FkXzRcIj5cclxuICAgICAgICAgICAgICAgICAgICAgICAgPHAgY2xhc3M9XCJjaG9vc2VfYnRuXCI+SW1wb3J0ZXI8L3A+XHJcbiAgICAgICAgICAgICAgICAgICAgICA8L2Rpdj5cclxuICAgICAgICAgICAgICAgICAgICAgIDxpbnB1dCB0eXBlPVwiZmlsZVwiIGlkPVwiYWRkaXRpb25hbF9kb2NfYmFja1wiIG5hbWU9XCJhZGRpdGlvbmFsX2RvY19iYWNrXCIgZGF0YS1ydWxlLXJlcXVpcmVkPVwidHJ1ZVwiIGRhdGEtbXNnLXJlcXVpcmVkPVwiQWRkaXRpb25hbCBEb2N1bWVudCBiYWNrIGNoYW1wIGVzdCBvYmxpZ2F0b2lyZS5cIi8+XHJcbiAgICAgICAgICAgICAgICAgICAgICA8cCBjbGFzcz1cImVycm9yX2ZpbGVfM1wiPlZldWlsbGV6IHPDqWxlY3Rpb25uZXIgdW4gZG9jdW1lbnQ8L3A+XHJcbiAgICAgICAgICAgICAgICAgICAgICA8c3BhbiBjbGFzcz1cImFkZGl0aW9uYWxfZG9jX2JhY2tcIj48L3NwYW4+XHJcbiAgICAgICAgICAgICAgICAgICAgPC9kaXY+XHJcbiAgICAgICAgICAgICAgICAgIDwvZGl2PlxyXG4gICAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzPVwiY29sLW1kLTZcIiA+XHJcbiAgICAgICAgICAgICAgICAgICAgPGRpdiBjbGFzcz1cImZvcm0tZ3JvdXBcIj5cclxuICAgICAgICAgICAgICAgICAgICA8L2Rpdj5cclxuICAgICAgICAgICAgICAgICAgPC9kaXY+XHJcbiAgICAgICAgICAgICAgICA8L2Rpdj5cclxuICAgICAgICAgICAgICA8L2Rpdj5cclxuICAgICAgICAgICAgICA8ZGl2IGNsYXNzPVwicm93XCI+XHJcbiAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzPVwiY29sLW1kLTEyXCI+XHJcbiAgICAgICAgICAgICAgICAgIDxjZW50ZXI+PHNwYW4gY2xhc3M9XCJiYW5rX3ZhbGlkYXRpb25zIGVycm9yXCI+PC9zcGFuPjwvY2VudGVyPlxyXG4gICAgICAgICAgICAgICAgPC9kaXY+XHJcbiAgICAgICAgICAgICAgPC9kaXY+XHJcbiAgICAgICAgICAgICAgPGRpdiBjbGFzcz1cInJvdyBib3R0b20tYnV0dG9uLXJvd1wiPlxyXG4gICAgICAgICAgICAgICAgPGRpdiBjbGFzcz1cImNvbC1tZC0xMiB0ZXh0LWNlbnRlciBwdC01XCI+XHJcbiAgICAgICAgICAgICAgICAgIDxpbnB1dCB0eXBlPVwiaGlkZGVuXCIgbmFtZT1cInN0cmlwZV9iYW5rX2FjY291bnRcIiBpZD1cInN0cmlwZV9iYW5rX2FjY291bnRcIiAvPlxyXG4gICAgICAgICAgICAgICAgICA8aW5wdXQgdHlwZT1cImhpZGRlblwiIG5hbWU9XCJ0b2tlbi1hY2NvdW50XCIgaWQ9XCJ0b2tlbi1hY2NvdW50XCI+XHJcbiAgICAgICAgICAgICAgICAgIDxidXR0b24gdHlwZT1cInN1Ym1pdFwiIGNsYXNzPVwiYnRuIGJ0bi1wcmltYXJ5IGN1c3RvbS1zdWJtaXQtYnRuIGFkZC1idG5cIj5Tb3VtZXR0cmU8L2J1dHRvbj5cclxuICAgICAgICAgICAgICAgICAgPGJ1dHRvbiB0eXBlPVwicmVzZXRcIiBjbGFzcz1cImJ0biBidG4tb3V0bGluZS1zdWNjZXNzIGJ0bi1yb3VuZGVkIHJlc2V0LWJ0blwiPlLDqWluaXRpYWxpc2VyPC9idXR0b24+XHJcbiAgICAgICAgICAgICAgICAgIDxyb3V0ZXItbGluayB0bz1cIi9zdXBlcmFkbWluL3NwZWNpYWxpc3RcIiBjbGFzcz1cImJ0biBidG4tb3V0bGluZS1kYXJrIGJ0bi1yb3VuZGVkIGJhY2stYnRuLXdpZHRoXCI+UmV0b3VyPC9yb3V0ZXItbGluaz5cclxuICAgICAgICAgICAgICAgIDwvZGl2PlxyXG4gICAgICAgICAgICAgIDwvZGl2PlxyXG4gICAgICAgICAgICA8L2Rpdj5cclxuICAgICAgICAgIDwvZGl2PlxyXG4gICAgICAgIDwvZGl2PlxyXG4gICAgICA8L2Zvcm0+XHJcbiAgICA8L2Rpdj5cclxuICA8L2Rpdj5cclxuICA8L2Rpdj5cclxuPC90ZW1wbGF0ZT5cclxuXHJcbjxzY3JpcHQ+XHJcbmltcG9ydCByZXF1ZXN0RmFjdG9yeSBmcm9tIFwiQC9tb2R1bGVzL2h0dHAvYXBpL3JlcXVlc3RGYWN0b3J5XCI7XHJcbmltcG9ydCBzZWxlY3QyIGZyb20gJ3NlbGVjdDInXHJcbmltcG9ydCBkcm9waWZ5IGZyb20gJ2Ryb3BpZnknXHJcbmltcG9ydCB2YWxpZGF0ZSBmcm9tICdqcXVlcnktdmFsaWRhdGlvbic7XHJcbmltcG9ydCAnZHJvcGlmeS9kaXN0L2Nzcy9kcm9waWZ5LmNzcydcclxuaW1wb3J0IGZsYXRwaWNrciBmcm9tIFwiZmxhdHBpY2tyL2Rpc3QvZmxhdHBpY2tyXCI7XHJcbmltcG9ydCBcImZsYXRwaWNrci9kaXN0L2wxMG4vZnJcIlxyXG5pbXBvcnQgJ2ZsYXRwaWNrci9kaXN0L2ZsYXRwaWNrci5taW4uY3NzJ1xyXG5pbXBvcnQge21hcEFjdGlvbnMsIG1hcEdldHRlcnN9IGZyb20gXCJ2dWV4XCI7XHJcblxyXG5cclxuZXhwb3J0IGRlZmF1bHQge1xyXG4gIG5hbWU6ICdhZGQtc3BlY2lhbGlzdCcsXHJcbiAgbWV0aG9kczoge1xyXG4gICAgdmFsaWRhdGVNb2JpbGUodmFsdWUpIHtcclxuXHJcbiAgICAgIHZhciBtb2JpbGUgPSBcIlwiO1xyXG4gICAgICAvL0ZpcnN0IHJlbW92ZSBhbGwgc3BhY2VzOlxyXG4gICAgICB2YWx1ZSA9IHZhbHVlLnJlcGxhY2UoL1xccy9nLCAnJyk7XHJcblxyXG4gICAgICBpZih2YWx1ZS5zdGFydHNXaXRoKFwiMFwiKSl7XHJcbiAgICAgICAgdmFyIHRlbXAgPSB2YWx1ZS5zdWJzdHJpbmcoMSwgdmFsdWUubGVuZ3RoKTtcclxuICAgICAgICBtb2JpbGUgPSBcIiszM1wiK3RlbXA7XHJcbiAgICAgICAgLy9Nb2JpbGUgbnVtYmVyOlxyXG4gICAgICAgIHJldHVybiBtb2JpbGU7XHJcbiAgICAgICAgY29uc29sZS5sb2coJ21vYmlsZScrbW9iaWxlKTtcclxuICAgICAgfSBlbHNlIGlmKHZhbHVlLnN0YXJ0c1dpdGgoXCIrXCIpKXtcclxuICAgICAgICB2YXIgdGVtcCA9IHZhbHVlLnN1YnN0cmluZygzLCB2YWx1ZS5sZW5ndGgpO1xyXG4gICAgICAgIG1vYmlsZSA9IFwiKzMzXCIrdGVtcDtcclxuICAgICAgICAvL01vYmlsZSBudW1iZXI6XHJcbiAgICAgICAgY29uc29sZS5sb2coJ21vYmlsZTonK21vYmlsZSk7XHJcbiAgICAgICAgcmV0dXJuIG1vYmlsZTtcclxuICAgICAgfVxyXG4gICAgICBlbHNle1xyXG4gICAgICAgIG1vYmlsZSA9IHZhbHVlO1xyXG4gICAgICAgIC8vTW9iaWxlIG51bWJlcjpcclxuICAgICAgICBjb25zb2xlLmxvZyhtb2JpbGUpO1xyXG4gICAgICAgIHJldHVybiBtb2JpbGU7XHJcbiAgICAgIH1cclxuICAgIH0sXHJcbiAgICAuLi5tYXBBY3Rpb25zKCdhcHAvc3VwZXJBZG1pblNwZWNpYWxpc3RTdG9yZScsIFtcclxuICAgICAgICAnc2V0Q291bnRyaWVzJyxcclxuICAgICAgICAnc2V0U3BlY2lhbGl0aWVzJyxcclxuICAgICAgICAncG9zdCdcclxuICAgIF0pLFxyXG4gICAgLypoYW5kbGVTdWJtaXQoKSB7XHJcblxyXG4gICAgICBjb25zdCBmb3JtX2RhdGEgPSBuZXcgRm9ybURhdGEoJCgnLmNvbnRhY3QnKS5nZXQoMCkpXHJcbiAgICAgIC8hKmNvbnN0IGZvcm1fZGF0YSA9IG5ldyBGb3JtRGF0YTtcclxuICAgICAgZm9ybV9kYXRhLmFwcGVuZCgnZmlyc3RuYW1lJywgdGhpcy5mb3JtLnVzZXIuZmlyc3RuYW1lKVxyXG4gICAgICBmb3JtX2RhdGEuYXBwZW5kKCdsYXN0bmFtZScsIHRoaXMuZm9ybS51c2VyLmxhc3RuYW1lKVxyXG4gICAgICBmb3JtX2RhdGEuYXBwZW5kKCdzcGVjaWFsaXR5X2lkJywgdGhpcy5mb3JtLnNwZWNpYWxpdHlfaWQpXHJcbiAgICAgIGZvcm1fZGF0YS5hcHBlbmQoJ3ByYWN0aWNlX2lkJywgdGhpcy5mb3JtLnByYWN0aWNlX2lkKVxyXG4gICAgICBmb3JtX2RhdGEuYXBwZW5kKCdzcGVjaWFsaXN0cycsIEpTT04uc3RyaW5naWZ5KHRoaXMuZm9ybS5zZWxlY3RlZF9zcGVjaWFsaXN0cykpXHJcbiAgICAgIGlmKHRoaXMuZm9ybS5wcm9maWxlX3BpY3R1cmUpIHsgZm9ybV9kYXRhLmFwcGVuZCgncHJvZmlsZV9waWN0dXJlJywgdGhpcy5mb3JtLnByb2ZpbGVfcGljdHVyZSkgfSohL1xyXG5cclxuICAgICAgcmVxdWVzdEZhY3RvcnkoKS5wb3N0KCcvYXBpL3YxL3N1cGVyYWRtaW4vc3BlY2lhbGlzdCcsIGZvcm1fZGF0YSlcclxuICAgICAgICAgIC50aGVuKHJlcyA9PiB7XHJcblxyXG4gICAgICAgICAgICAvL3RoaXMuJHJvdXRlci5wdXNoKCcvc3VwZXJhZG1pbi9wcm9ncmFtcycpXHJcbiAgICAgICAgICB9KVxyXG4gICAgICAgICAgLmNhdGNoKGUgPT4ge1xyXG5cclxuICAgICAgICAgICAgaWYoZS5yZXNwb25zZS5zdGF0dXMgPT09IDQyMikgdGhpcy5lcnJvcnMgPSBlLnJlc3BvbnNlLmRhdGEuZXJyb3JzO1xyXG4gICAgICAgICAgfSlcclxuICAgIH0qL1xyXG4gIH0sXHJcbiAgZGF0YSgpIHtcclxuICAgIHJldHVybiB7XHJcbiAgICAgIGVycm9yczoge30sXHJcbiAgICAgIGZvcm06IHtcclxuICAgICAgICBwcmFjdGljZV9zdGFydF9kYXRlOiAnJyxcclxuICAgICAgICBzcGVjaWFsaXR5X2lkOiBbXSxcclxuICAgICAgICBhZGRyZXNzZXM6IFtcclxuICAgICAgICAgIHtzdHJlZXRfYWRkcmVzczogJyd9LFxyXG4gICAgICAgICAge3N0cmVldF9hZGRyZXNzOiAnJ31cclxuICAgICAgICBdLFxyXG4gICAgICAgIHBvc3RhbF9jb2RlOiAnJyxcclxuICAgICAgICB1c2VyOiB7XHJcbiAgICAgICAgICBlbWFpbDogJycsXHJcbiAgICAgICAgICBmaXJzdG5hbWU6ICcnLFxyXG4gICAgICAgICAgbGFzdG5hbWU6ICcnLFxyXG4gICAgICAgICAgcGhvbmVfbnVtYmVyOiAnJyxcclxuICAgICAgICAgIHByb2ZpbGU6IHtcclxuICAgICAgICAgICAgcHJvZmlsZV9pbWFnZTogJydcclxuICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgIH0sXHJcblxyXG4gICAgICBjaXRpZXM6IFtdXHJcbiAgICB9XHJcbiAgfSxcclxuICBjb21wdXRlZDoge1xyXG4gICAgLi4ubWFwR2V0dGVycygnYXBwL3N1cGVyQWRtaW5TcGVjaWFsaXN0U3RvcmUnLCBbXHJcbiAgICAgICAgJ2NvdW50cmllcycsXHJcbiAgICAgICAgJ3NwZWNpYWxpdGllcydcclxuICAgIF0pXHJcbiAgfSxcclxuICBtb3VudGVkKCkge1xyXG5cclxuICAgIGNvbnN0IHRoYXQgPSB0aGlzXHJcbiAgICAkKFwiLnRhZ2dpbmdcIikuc2VsZWN0Mih7IHRhZ3M6IHRydWUgfSk7XHJcbiAgICAvLyQoJy5pbml0LXNlbGVjdDInKS5zZWxlY3QyKCk7XHJcblxyXG4gICAgcmVxdWVzdEZhY3RvcnkoKS5nZXQoJy9hcGkvdjEvc3VwZXJhZG1pbi9zcGVjaWFsaXRpZXMnKVxyXG4gICAgICAgIC50aGVuKGRhdGEgPT4geyB0aGF0LnNldFNwZWNpYWxpdGllcyhkYXRhKX0pXHJcblxyXG4gICAgcmVxdWVzdEZhY3RvcnkoKS5nZXQoJy9hcGkvdjEvc3VwZXJhZG1pbi9jb3VudHJpZXMnKVxyXG4gICAgLnRoZW4ocmVzcG9uc2UgPT4gdGhpcy5zZXRDb3VudHJpZXMocmVzcG9uc2UuZGF0YSkpXHJcblxyXG5cclxuICAgICQoJy5kcm9waWZ5JykuZHJvcGlmeSh7XHJcbiAgICAgIG1lc3NhZ2VzOiB7ICdkZWZhdWx0JzogJ0NsaWNrIHRvIFVwbG9hZCBvciBEcmFnIG4gRHJvcCcsICdyZW1vdmUnOiAgJzxpIGNsYXNzPVwiZmEgZmEtdGltZXNcIj48L2k+JywgJ3JlcGxhY2UnOiAnVXBsb2FkIG9yIERyYWcgbiBEcm9wJyB9XHJcbiAgICB9KTtcclxuXHJcbiAgICAkKCcjZmlsZVVwbG9hZF80Jykub24oJ2NsaWNrJyxmdW5jdGlvbigpe1xyXG4gICAgICAkKCcjYWRkaXRpb25hbF9kb2NfYmFjaycpLmNsaWNrKCk7XHJcbiAgICB9KTtcclxuXHJcbiAgICAkKCcjYWRkaXRpb25hbF9kb2NfYmFjaycpLm9uKCdjaGFuZ2UnLGZ1bmN0aW9uKCl7XHJcbiAgICAgIGlmKCQoJyNhZGRpdGlvbmFsX2RvY19iYWNrJykudmFsKCkhPScnKXtcclxuICAgICAgICAkKCcjZmlsZVVwbG9hZF80JykuaHRtbCgkKCcjYWRkaXRpb25hbF9kb2NfYmFjaycpLnZhbCgpLnJlcGxhY2UoLy4qKFxcL3xcXFxcKS8sICcnKSk7XHJcbiAgICAgIH1lbHNle1xyXG4gICAgICAgICQoJyNmaWxlVXBsb2FkXzQnKS5odG1sKCQoJ0ltcG9ydGVyJykudmFsKCkpO1xyXG4gICAgICB9XHJcbiAgICB9KTtcclxuXHJcbiAgICAkKCcuYWRkLWJ0bicpLm9uKCdjbGljaycsIGZ1bmN0aW9uKCkge1xyXG4gICAgICAkKFwiI3JlZ2lzdGVyX3NwZWNpYWxpc3RfZm1cIikudmFsaWQoKTtcclxuICAgIH0pO1xyXG5cclxuICAgICQoJyNmaWxlVXBsb2FkJykub24oJ2NsaWNrJyxmdW5jdGlvbigpe1xyXG4gICAgICAkKCcjZG9jX2Zyb250JykuY2xpY2soKTtcclxuICAgIH0pO1xyXG5cclxuICAgICQoJyNkb2NfZnJvbnQnKS5vbignY2hhbmdlJyxmdW5jdGlvbigpe1xyXG4gICAgICBpZigkKCcjZG9jX2Zyb250JykudmFsKCkhPScnKXtcclxuICAgICAgICAkKCcjZmlsZVVwbG9hZCcpLmh0bWwoJCgnI2RvY19mcm9udCcpLnZhbCgpLnJlcGxhY2UoLy4qKFxcL3xcXFxcKS8sICcnKSk7XHJcbiAgICAgIH1lbHNle1xyXG4gICAgICAgICQoJyNmaWxlVXBsb2FkJykuaHRtbCgkKCdJbXBvcnRlcicpLnZhbCgpKTtcclxuICAgICAgfVxyXG4gICAgfSk7XHJcblxyXG4gICAgJCgnI2ZpbGVVcGxvYWRfMicpLm9uKCdjbGljaycsZnVuY3Rpb24oKXtcclxuICAgICAgJCgnI2RvY19iYWNrJykuY2xpY2soKTtcclxuICAgIH0pO1xyXG5cclxuICAgICQoJyNkb2NfYmFjaycpLm9uKCdjaGFuZ2UnLGZ1bmN0aW9uKCl7XHJcbiAgICAgIGlmKCQoJyNkb2NfYmFjaycpLnZhbCgpIT0nJyl7XHJcbiAgICAgICAgJCgnI2ZpbGVVcGxvYWRfMicpLmh0bWwoJCgnI2RvY19iYWNrJykudmFsKCkucmVwbGFjZSgvLiooXFwvfFxcXFwpLywgJycpKTtcclxuICAgICAgfWVsc2V7XHJcbiAgICAgICAgJCgnI2ZpbGVVcGxvYWRfMicpLmh0bWwoJCgnSW1wb3J0ZXInKS52YWwoKSk7XHJcbiAgICAgIH1cclxuICAgIH0pO1xyXG5cclxuICAgICQoJyNmaWxlVXBsb2FkXzMnKS5vbignY2xpY2snLGZ1bmN0aW9uKCl7XHJcbiAgICAgICQoJyNhZGRpdGlvbmFsX2RvY19mcm9udCcpLmNsaWNrKCk7XHJcbiAgICB9KTtcclxuXHJcbiAgICAkKCcjYWRkaXRpb25hbF9kb2NfZnJvbnQnKS5vbignY2hhbmdlJyxmdW5jdGlvbigpe1xyXG4gICAgICBpZigkKCcjYWRkaXRpb25hbF9kb2NfZnJvbnQnKS52YWwoKSE9Jycpe1xyXG4gICAgICAgICQoJyNmaWxlVXBsb2FkXzMnKS5odG1sKCQoJyNhZGRpdGlvbmFsX2RvY19mcm9udCcpLnZhbCgpLnJlcGxhY2UoLy4qKFxcL3xcXFxcKS8sICcnKSk7XHJcbiAgICAgIH1lbHNle1xyXG4gICAgICAgICQoJyNmaWxlVXBsb2FkXzMnKS5odG1sKCQoJ0ltcG9ydGVyJykudmFsKCkpO1xyXG4gICAgICB9XHJcbiAgICB9KTtcclxuXHJcbiAgICBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnZGF0ZV9vZl9iaXJ0aCcpLmZsYXRwaWNrcih7IGlubGluZTpmYWxzZSxkYXRlRm9ybWF0OlwiZC9tL1lcIixtYXhEYXRlOlwidG9kYXlcIixsb2NhbGU6XCJmclwiIH0pO1xyXG4gICAgZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ3ByYWN0aWNlX3N0YXJ0X2RhdGUxJykuZmxhdHBpY2tyKHsgaW5saW5lOmZhbHNlLGRhdGVGb3JtYXQ6XCJkL20vWVwiLG1pbkRhdGU6XCJ0b2RheVwiLGxvY2FsZTpcImZyXCIgfSk7XHJcblxyXG4gICAgJCgnI3JlZ2lzdGVyX3NwZWNpYWxpc3RfZm0nKS52YWxpZGF0ZSh7XHJcbiAgICAgIHJ1bGVzOiB7XHJcbiAgICAgICAgZmlyc3RfbmFtZToge1xyXG4gICAgICAgICAgcmVxdWlyZWQ6IHRydWUsXHJcbiAgICAgICAgICAvL2xldHRlcnNvbmx5OiB0cnVlLFxyXG4gICAgICAgIH0sXHJcbiAgICAgICAgbGFzdF9uYW1lOiB7XHJcbiAgICAgICAgICByZXF1aXJlZDogdHJ1ZSxcclxuICAgICAgICAgIC8vIGxldHRlcnNvbmx5OiB0cnVlLFxyXG4gICAgICAgIH0sXHJcbiAgICAgICAgc3BlY2lhbGl0eWNhdGVnb3J5X2lkX2ZrOiB7XHJcbiAgICAgICAgICByZXF1aXJlZDogdHJ1ZSxcclxuICAgICAgICAgIC8vIGxldHRlcnNvbmx5OiB0cnVlLFxyXG4gICAgICAgIH0sXHJcbiAgICAgICAgcHJhY3RpY2Vfc3RhcnRfZGF0ZToge1xyXG4gICAgICAgICAgcmVxdWlyZWQ6IHRydWUsXHJcbiAgICAgICAgICAvLyBsZXR0ZXJzb25seTogdHJ1ZSxcclxuICAgICAgICB9LFxyXG4gICAgICAgIGVtYWlsOntcclxuICAgICAgICAgIHJlcXVpcmVkOiB0cnVlLFxyXG4gICAgICAgICAgLy8gbGV0dGVyc29ubHk6IHRydWUsXHJcbiAgICAgICAgfSxcclxuICAgICAgICBtb2JpbGVfbnVtYmVyOntcclxuICAgICAgICAgIHJlcXVpcmVkOiB0cnVlLFxyXG4gICAgICAgICAgLy8gbGV0dGVyc29ubHk6IHRydWUsXHJcbiAgICAgICAgfSxcclxuXHJcblxyXG4gICAgICB9LFxyXG4gICAgICBtZXNzYWdlczoge1xyXG4gICAgICAgIGZpcnN0X25hbWU6eyByZXF1aXJlZDogXCJjaGFtcCBlc3Qgb2JsaWdhdG9pcmUuXCIsIH0sXHJcbiAgICAgICAgbGFzdF9uYW1lOnsgcmVxdWlyZWQ6IFwiY2hhbXAgZXN0IG9ibGlnYXRvaXJlLlwiLCB9LFxyXG4gICAgICAgIHNwZWNpYWxpdHljYXRlZ29yeV9pZF9mazp7IHJlcXVpcmVkOiBcImNoYW1wIGVzdCBvYmxpZ2F0b2lyZS5cIiwgfSxcclxuICAgICAgICBwcmFjdGljZV9zdGFydF9kYXRlOnsgcmVxdWlyZWQ6IFwiY2hhbXAgZXN0IG9ibGlnYXRvaXJlLlwiLCB9LFxyXG4gICAgICAgIGVtYWlsOnsgcmVxdWlyZWQ6IFwiY2hhbXAgZXN0IG9ibGlnYXRvaXJlLlwiLCB9LFxyXG4gICAgICAgIG1vYmlsZV9udW1iZXI6eyByZXF1aXJlZDogXCJjaGFtcCBlc3Qgb2JsaWdhdG9pcmUuXCIsIH0sXHJcbiAgICAgIH0sXHJcbiAgICAgIGVycm9yRWxlbWVudDogJ3NwYW4nLFxyXG4gICAgICBlcnJvclBsYWNlbWVudDogZnVuY3Rpb24gKGVycm9yLCBlbGVtZW50KSB7XHJcbiAgICAgICAgY29uc29sZS5sb2coZXJyb3IsIGVsZW1lbnQpXHJcbiAgICAgICAgZXJyb3IuYWRkQ2xhc3MoJ2ludmFsaWQtZmVlZGJhY2snKTtcclxuICAgICAgICBlcnJvci5pbnNlcnRBZnRlciggZWxlbWVudCApO1xyXG4gICAgICB9LFxyXG4gICAgICBoaWdobGlnaHQ6IGZ1bmN0aW9uIChlbGVtZW50LCBlcnJvckNsYXNzLCB2YWxpZENsYXNzKSB7XHJcbiAgICAgICAgJChlbGVtZW50KS5hZGRDbGFzcygnaXMtaW52YWxpZCcpO1xyXG4gICAgICB9LFxyXG4gICAgICB1bmhpZ2hsaWdodDogZnVuY3Rpb24gKGVsZW1lbnQsIGVycm9yQ2xhc3MsIHZhbGlkQ2xhc3MpIHtcclxuICAgICAgICAkKGVsZW1lbnQpLnJlbW92ZUNsYXNzKCdpcy1pbnZhbGlkJyk7XHJcbiAgICAgIH0sXHJcbiAgICAgIHN1Ym1pdEhhbmRsZXI6IGZ1bmN0aW9uIChmb3JtKSB7XHJcblxyXG4gICAgICAgIGNvbnNvbGUubG9nKGZvcm0pXHJcbiAgICAgICAgdGhhdC5wb3N0KG5ldyBGb3JtRGF0YShmb3JtKSkudGhlbihyZXNwb25zZSA9PiB7XHJcblxyXG4gICAgICAgICAgLyppZihyZXNwb25zZS5zdWNjZXNzKSB7XHJcblxyXG4gICAgICAgICAgICB0b2FzdHIuc3VjY2Vzcygnb25uw6llcyBham91dMOpZXMgYXZlYyBzdWNjw6hzLicsICdTdWNjw6hzJyk7XHJcbiAgICAgICAgICAgIHRoYXQuJHJvdXRlci5wdXNoKHtuYW1lOiAnc3VwZXJhZG1pbi5lbnRlcnByaXNlcyd9KTtcclxuICAgICAgICAgIH0qL1xyXG4gICAgICAgIH0pO1xyXG4gICAgICB9XHJcbiAgICB9KTtcclxuXHJcbiAgICAkKFwiI2ZpcnN0X25hbWUsI2xhc3RfbmFtZSwjZnVsbG5hbWUsI2FjY291bnRfaG9sZGVyX25hbWVcIikua2V5cHJlc3MoZnVuY3Rpb24oZXZlbnQpe1xyXG4gICAgICB2YXIgaW5wdXRWYWx1ZSA9IGV2ZW50LmNoYXJDb2RlO1xyXG4gICAgICBpZighKGlucHV0VmFsdWUgPj0gNjUgJiYgaW5wdXRWYWx1ZSA8PSAxMjApICYmIChpbnB1dFZhbHVlICE9IDMyICYmIGlucHV0VmFsdWUgIT0gMCkpe1xyXG4gICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XHJcbiAgICAgIH1cclxuICAgIH0pO1xyXG5cclxuICAgIGpRdWVyeS52YWxpZGF0b3IuYWRkTWV0aG9kKFwibGV0dGVyc29ubHlcIiwgZnVuY3Rpb24odmFsdWUsIGVsZW1lbnQpIHtcclxuICAgICAgcmV0dXJuIHRoaXMub3B0aW9uYWwoZWxlbWVudCkgfHwgL15bYS16XSskL2kudGVzdCh2YWx1ZSk7XHJcbiAgICB9LCBcIjw/PSR0aGlzLT5sYW5nLT5saW5lKCdsZXR0ZXJzX2Vycm9yJyk7Pz5cIik7XHJcblxyXG4gICAgJC52YWxpZGF0b3IuYWRkTWV0aG9kKFwiY3VzdG9tX251bWJlclwiLCBmdW5jdGlvbih2YWx1ZSwgZWxlbWVudCkge1xyXG4gICAgICByZXR1cm4gdGhpcy5vcHRpb25hbChlbGVtZW50KSB8fCB2YWx1ZSA9PT0gXCJOQVwiIHx8XHJcbiAgICAgICAgICB2YWx1ZS5tYXRjaCgvXlswLTksXFwqLV0rJC8pO1xyXG4gICAgfSwgXCJQbGVhc2UgZW50ZXIgYSB2YWxpZCBudW1iZXJcIik7XHJcbiAgfSxcclxuICB3YXRjaDoge1xyXG4gICAgJ2Zvcm0udXNlci5wcm9maWxlLmNvdW50cnlfaWQnKG5ld1ZhbHVlKSB7XHJcblxyXG4gICAgICBpZihuZXdWYWx1ZSkge1xyXG5cclxuICAgICAgICB0aGlzLmNpdGllcyA9IHRoaXMuY291bnRyaWVzLmZpbHRlcihjb3VudHJ5ID0+IGNvdW50cnkuaWQgPT0gbmV3VmFsdWUpWzBdLmNpdGllcztcclxuICAgICAgfVxyXG4gICAgfVxyXG4gIH1cclxufVxyXG48L3NjcmlwdD5cclxuXHJcbjxzdHlsZT5cclxuLmRyb3BpZnktd3JhcHBlciB7XHJcbiAgd2lkdGg6IDE1MHB4IWltcG9ydGFudDtcclxuICBoZWlnaHQ6IDE1MHB4IWltcG9ydGFudDs7XHJcbiAgYm9yZGVyOiAycHggc29saWQgd2hpdGUhaW1wb3J0YW50OztcclxuICBib3JkZXItcmFkaXVzOiA1MCUhaW1wb3J0YW50OztcclxuICBwYWRkaW5nOiAxMHB4IWltcG9ydGFudDtcclxuICBtYXJnaW46IGF1dG8haW1wb3J0YW50O1xyXG59XHJcblxyXG4uZXJyb3ItbWVzc2FnZXtcclxuICBjb2xvcjogcmVkO1xyXG59XHJcbi5hamF4LWxvYWRlciB7XHJcbiAgdmlzaWJpbGl0eTogaGlkZGVuO1xyXG4gIGJhY2tncm91bmQtY29sb3I6IHJnYmEoMjU1LDI1NSwyNTUsMC43KTtcclxuICBwb3NpdGlvbjphYnNvbHV0ZTtcclxuICB6LWluZGV4OiA5OSFpbXBvcnRhbnQ7XHJcbiAgd2lkdGg6IDEwMCU7XHJcbiAgaGVpZ2h0OjEwMCU7XHJcbn1cclxuLmFqYXgtbG9hZGVyIGltZyB7XHJcbiAgcG9zaXRpb246IHJlbGF0aXZlO1xyXG4gIHRvcDo1MCU7XHJcbiAgbGVmdDo1MCU7XHJcbn1cclxuLmRvY19mcm9udCwgLmRvY19iYWNrLCAuYWRkaXRpb25hbF9kb2NfZnJvbnQsIC5hZGRpdGlvbmFsX2RvY19iYWNre1xyXG4gIGNvbG9yOnJlZDtcclxufVxyXG5cclxuLmVycm9yX2ZpbGV7XHJcbiAgZm9udC1zaXplOiAxM3B4O1xyXG4gIGNvbG9yOiByZWQhaW1wb3J0YW50O1xyXG4gIGRpc3BsYXk6bm9uZTtcclxufVxyXG4uZXJyb3JfZmlsZV8xe1xyXG4gIGZvbnQtc2l6ZTogMTNweDtcclxuICBjb2xvcjogcmVkIWltcG9ydGFudDtcclxuICBkaXNwbGF5Om5vbmU7XHJcbn1cclxuLmVycm9yX2ZpbGVfMntcclxuICBmb250LXNpemU6IDEzcHg7XHJcbiAgY29sb3I6IHJlZCFpbXBvcnRhbnQ7XHJcbiAgZGlzcGxheTpub25lO1xyXG59XHJcbi5lcnJvcl9maWxlXzN7XHJcbiAgZm9udC1zaXplOiAxM3B4O1xyXG4gIGNvbG9yOiByZWQhaW1wb3J0YW50O1xyXG4gIGRpc3BsYXk6bm9uZTtcclxufVxyXG4uY3VzdG9tLWNvbnRyb2x7XHJcbiAgcG9zaXRpb246IHJlbGF0aXZlO1xyXG4gIGRpc3BsYXk6IGJsb2NrO1xyXG4gIG1pbi1oZWlnaHQ6IDEuNXJlbTtcclxuICBwYWRkaW5nLWxlZnQ6IDJyZW07XHJcbiAgbGVmdDogMHB4O1xyXG4gIHJpZ2h0OiAwcHg7XHJcbiAgbWFyZ2luOiAwIGF1dG87XHJcbn1cclxuLmRvYy1zaXple1xyXG4gIGZvbnQtc2l6ZTogMTNweDtcclxuICBjb2xvcjogYmxhY2shaW1wb3J0YW50O1xyXG4gIHBhZGRpbmctdG9wOiA1cHg7XHJcbn1cclxuXHJcbkBtZWRpYSBzY3JlZW4gYW5kIChvcmllbnRhdGlvbjpwb3J0cmFpdCl7XHJcbiAgLmFkZC1idG57XHJcbiAgICBtYXJnaW4tYm90dG9tOiAxMXB4O1xyXG4gIH1cclxuICAucmVzZXQtYnRue1xyXG4gICAgbWFyZ2luLWJvdHRvbTogMTVweDtcclxuICB9XHJcbiAgLmNob29zZV9idG57XHJcbiAgICB3aWR0aDogNDIlIWltcG9ydGFudDtcclxuICB9XHJcbn1cclxuQG1lZGlhICh3aWR0aDoyODBweCl7XHJcbiAgLmNob29zZV9idG4ge1xyXG4gICAgd2lkdGg6IDU5JSFpbXBvcnRhbnQ7XHJcbiAgfVxyXG4gIC5yZXNldC1idG57XHJcbiAgICBtYXJnaW4tbGVmdDogMHB4O1xyXG4gIH1cclxufVxyXG5pbnB1dDotd2Via2l0LWF1dG9maWxsIHtcclxuICAtd2Via2l0LWJveC1zaGFkb3c6MCAwIDAgNTBweCB3aGl0ZSBpbnNldDsgLyogQ2hhbmdlIHRoZSBjb2xvciB0byB5b3VyIG93biBiYWNrZ3JvdW5kIGNvbG9yICovXHJcbiAgLXdlYmtpdC10ZXh0LWZpbGwtY29sb3I6ICNmOWY5Zjk7XHJcbn1cclxuaW5wdXQ6LXdlYmtpdC1hdXRvZmlsbDpmb2N1cyB7XHJcbiAgLXdlYmtpdC1ib3gtc2hhZG93OiAvKnlvdXIgYm94LXNoYWRvdyovLDAgMCAwIDUwcHggd2hpdGUgaW5zZXQ7XHJcbiAgLXdlYmtpdC10ZXh0LWZpbGwtY29sb3I6I2Y5ZjlmOTtcclxufVxyXG4uc2VsZWN0LWZpZWxke1xyXG4gIGZvbnQtd2VpZ2h0OiAxMDA7XHJcbiAgZm9udC1zaXplOiAxM3B4O1xyXG4gIGNvbG9yOmJsYWNrO1xyXG59XHJcbnNlbGVjdDpmb2N1cywgaW5wdXQ6Zm9jdXN7XHJcbiAgb3V0bGluZTogbm9uZTtcclxufVxyXG4jc2VsX2NvdW50cnl7XHJcbiAgYm9yZGVyOiAwICFpbXBvcnRhbnQ7XHJcbiAgYm94LXNoYWRvdzogbm9uZTtcclxufVxyXG4jc2VsX2NpdHl7XHJcbiAgYm9yZGVyOiAwICFpbXBvcnRhbnQ7XHJcbiAgYm94LXNoYWRvdzogbm9uZTtcclxufVxyXG4jZmlsZVVwbG9hZHtcclxuICBwb3NpdGlvbjogcmVsYXRpdmU7XHJcbiAgdG9wOiAwcmVtO1xyXG4gIGxlZnQ6MHB4O1xyXG4gIHdpZHRoOjEwMCU7XHJcbiAgaGVpZ2h0OiAxMjBweDtcclxuICBtYXJnaW46IDAgYXV0bztcclxuICBoZWlnaHQ6IDM5cHg7XHJcbiAgY29sb3I6ICNBN0QwOEU7XHJcbiAgcGFkZGluZy10b3A6IDVweDtcclxuICBwYWRkaW5nLWxlZnQ6IDEwcHg7XHJcbiAgYm9yZGVyLXJhZGl1czogMnB4O1xyXG4gIGN1cnNvcjogcG9pbnRlcjtcclxuICBiYWNrZ3JvdW5kOiAjRjlGOUY5O1xyXG59XHJcbiNkb2NfZnJvbnR7XHJcbiAgZGlzcGxheTpub25lXHJcbn1cclxuLmNob29zZV9idG57XHJcbiAgcGFkZGluZy1sZWZ0OjBweDtcclxuICB0ZXh0LWFsaWduOiBjZW50ZXI7XHJcbiAgdG9wOiA3cmVtO1xyXG4gIGxlZnQ6IDBweDtcclxuICByaWdodDogMHB4O1xyXG4gIHdpZHRoOjI3JTtcclxuICBoZWlnaHQ6IDEyMHB4O1xyXG4gIGhlaWdodDogMjlweDtcclxuICBiYWNrZ3JvdW5kOiAjZWZlZmVmO1xyXG4gIGNvbG9yOiAjMzMyYjJiIWltcG9ydGFudDtcclxuICBwYWRkaW5nLXRvcDogM3B4O1xyXG4gIGJvcmRlci1yYWRpdXM6IDJweDtcclxuICBib3JkZXI6IDFweCBzb2xpZCAjNzY3Njc2O1xyXG4gIGN1cnNvcjogcG9pbnRlcjtcclxufVxyXG4vKlNlY29uZCBmaWxlIHVwbG9hZCovXHJcbiNmaWxlVXBsb2FkXzJ7XHJcbiAgcG9zaXRpb246IHJlbGF0aXZlO1xyXG4gIHRvcDogMHJlbTtcclxuICBsZWZ0OjBweDtcclxuICB3aWR0aDoxMDAlO1xyXG4gIGhlaWdodDogMTIwcHg7XHJcbiAgbWFyZ2luOiAwIGF1dG87XHJcbiAgaGVpZ2h0OiAzOXB4O1xyXG4gIGNvbG9yOiAgI0E3RDA4RTtcclxuICBwYWRkaW5nLXRvcDogNXB4O1xyXG4gIHBhZGRpbmctbGVmdDogMTBweDtcclxuICBib3JkZXItcmFkaXVzOiAycHg7XHJcbiAgY3Vyc29yOiBwb2ludGVyO1xyXG4gIGJhY2tncm91bmQ6ICNGOUY5Rjk7XHJcbn1cclxuI2RvY19iYWNre1xyXG4gIGRpc3BsYXk6bm9uZTtcclxufVxyXG4vKnRoaXJkIGZpbGUgdXBsb2FkICovXHJcbiNhZGRpdGlvbmFsX2RvY19mcm9udHtcclxuICBkaXNwbGF5Om5vbmU7XHJcbn1cclxuI2ZpbGVVcGxvYWRfM3tcclxuICBwb3NpdGlvbjogcmVsYXRpdmU7XHJcbiAgdG9wOiAwcmVtO1xyXG4gIGxlZnQ6MHB4O1xyXG4gIHdpZHRoOjEwMCU7XHJcbiAgaGVpZ2h0OiAxMjBweDtcclxuICBtYXJnaW46IDAgYXV0bztcclxuICBoZWlnaHQ6IDM5cHg7XHJcbiAgY29sb3I6ICNBN0QwOEU7XHJcbiAgcGFkZGluZy10b3A6IDVweDtcclxuICBwYWRkaW5nLWxlZnQ6IDEwcHg7XHJcbiAgYm9yZGVyLXJhZGl1czogMnB4O1xyXG4gIGN1cnNvcjogcG9pbnRlcjtcclxuICBiYWNrZ3JvdW5kOiAjRjlGOUY5O1xyXG59XHJcbi8qZm91cnRoIGZpbGUgKi9cclxuI2FkZGl0aW9uYWxfZG9jX2JhY2t7XHJcbiAgZGlzcGxheTpub25lO1xyXG59XHJcbiNmaWxlVXBsb2FkXzR7XHJcbiAgcG9zaXRpb246IHJlbGF0aXZlO1xyXG4gIHRvcDogMHJlbTtcclxuICBsZWZ0OjBweDtcclxuICB3aWR0aDoxMDAlO1xyXG4gIGhlaWdodDogMTIwcHg7XHJcbiAgbWFyZ2luOiAwIGF1dG87XHJcbiAgaGVpZ2h0OiAzOXB4O1xyXG4gIGNvbG9yOiAjQTdEMDhFO1xyXG4gIHBhZGRpbmctdG9wOiA1cHg7XHJcbiAgcGFkZGluZy1sZWZ0OiAxMHB4O1xyXG4gIGJvcmRlci1yYWRpdXM6IDJweDtcclxuICBjdXJzb3I6IHBvaW50ZXI7XHJcbiAgYmFja2dyb3VuZDogI0Y5RjlGOTtcclxufVxyXG48L3N0eWxlPlxyXG5cclxuPCEtLVxyXG48c2NyaXB0IHR5cGU9XCJ0ZXh0L2phdmFzY3JpcHRcIj5cclxuZnVuY3Rpb24gdmFsaWRhdGVGaWxlVHlwZShlbGVtZW50X2lkKXtcclxuICB2YXIgZmlsZU5hbWUgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChlbGVtZW50X2lkKS52YWx1ZTtcclxuICB2YXIgaWR4RG90ID0gZmlsZU5hbWUubGFzdEluZGV4T2YoXCIuXCIpICsgMTtcclxuICB2YXIgZXh0RmlsZSA9IGZpbGVOYW1lLnN1YnN0cihpZHhEb3QsIGZpbGVOYW1lLmxlbmd0aCkudG9Mb3dlckNhc2UoKTtcclxuICBpZiAoZXh0RmlsZT09XCJqcGdcIiB8fCBleHRGaWxlPT1cImpwZWdcIiB8fCBleHRGaWxlPT1cInBuZ1wiKXtcclxuICAgIHJldHVybiB0cnVlO1xyXG4gIH1lbHNle1xyXG4gICAgcmV0dXJuIGZhbHNlO1xyXG4gIH1cclxufVxyXG5cclxuXHJcbjwvc2NyaXB0Pi0tPlxyXG5cclxuPCEtLVxyXG48c2NyaXB0IHR5cGU9XCJ0ZXh0L2phdmFzY3JpcHRcIj5cclxuJChcIiNzZWxfY291bnRyeVwiKS5jaGFuZ2UoZnVuY3Rpb24gKCl7XHJcbiAgdmFyIGNvdW50cnkgPSAgICQodGhpcykudmFsKCk7XHJcbiAgLy9hbGVydChjb3VudHJ5KTtcclxuICB2YXIgY3NyZl9oYXNoID0gXCI8Pz0gJHRoaXMtPnNlY3VyaXR5LT5nZXRfY3NyZl9oYXNoKClcIjtcclxuICAkLmFqYXgoe1xyXG4gICAgdXJsOlwiPD9waHAgZWNobyBiYXNlX3VybCgpd2Vic2l0ZS9zcGVjaWFsaXN0cmVnaXN0ZXIvZ2V0X2NpdHlcIixcclxuICAgIG1ldGhvZDpcIlBPU1RcIixcclxuICAgIGRhdGE6e2NvdW50cnk6Y291bnRyeSxjc3JmX3RlbGV0aWNrX3Rrbjpjc3JmX2hhc2ggfSxcclxuICAgIHN1Y2Nlc3M6ZnVuY3Rpb24ocmVzcG9uc2UxKXtcclxuICAgICAgdmFyIG9iaiA9IEpTT04ucGFyc2UocmVzcG9uc2UxKTtcclxuICAgICAgY29uc29sZS5sb2cob2JqKTtcclxuICAgICAgaWYob2JqLmVycm9yKVxyXG4gICAgICB7XHJcbiAgICAgICAgdG9hc3RyLm9wdGlvbnMudGltZU91dCA9IDUwMDA7XHJcbiAgICAgICAgdG9hc3RyLmVycm9yKG9iai5lcnJvcik7XHJcbiAgICAgIH1lbHNlIHtcclxuICAgICAgICB2YXIgb3B0aW9uID0gJzxvcHRpb24gdmFsdWU9XCJcIj48Pz0gJHRoaXMtPmxhbmctPmxpbmUoJ2NpdHknKTwvb3B0aW9uPic7XHJcbiAgICAgICAgZm9yKHZhciBqPTAgOyBqPCBvYmouY2l0eS5sZW5ndGggO2orKylcclxuICAgICAgICB7XHJcbiAgICAgICAgICBcIjw/cGhwIGlmKCR0aGlzLT5zZXNzaW9uLT51c2VyZGF0YSgnc2l0ZV9sYW5nJykgPT0gJ2ZyZW5jaCcpIHsgPz5cIlxyXG4gICAgICAgICAgb3B0aW9uICs9IFwiPG9wdGlvbiB2YWx1ZT1cIitvYmouY2l0eVtqXS5jaXR5X2VuZ2xpc2grXCI+XCIrb2JqLmNpdHlbal0uY2l0eV9mcmVuY2grXCIgPC9vcHRpb24+XCI7XHJcbiAgICAgICAgICBcIjw/cGhwIH0gZWxzZSB7ID8+XCJcclxuICAgICAgICAgIG9wdGlvbiArPSBcIjxvcHRpb24gdmFsdWU9XCIrb2JqLmNpdHlbal0uY2l0eV9lbmdsaXNoK1wiPlwiK29iai5jaXR5W2pdLmNpdHlfZW5nbGlzaCtcIiA8L29wdGlvbj5cIjtcclxuICAgICAgICAgIFwiPD9waHAgfSA/PlwiXHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNvbnNvbGUubG9nKG9wdGlvbilcclxuICAgICAgICAkKFwiI3NlbF9jaXR5XCIpLmZpbmQoJ29wdGlvbicpLnJlbW92ZSgpLmVuZCgpLmFwcGVuZCggb3B0aW9uKTtcclxuICAgICAgICAkKFwiI3NlbF9jaXR5XCIpLnJlbW92ZUF0dHIoXCJkaXNhYmxlZFwiKTtcclxuICAgICAgfVxyXG4gICAgfVxyXG4gIH0pO1xyXG5cclxufSk7XHJcblxyXG5cclxuaGVsbG8gPSBmdW5jdGlvbigpIHtcclxuICAkKCcuYmFua192YWxpZGF0aW9ucycpLmh0bWwoJycpO1xyXG4gIGlmKCBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChcImRvY19mcm9udFwiKS5maWxlcy5sZW5ndGggPT0gMCB8fCBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChcImRvY19iYWNrXCIpLmZpbGVzLmxlbmd0aCA9PSAwIHx8IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKFwiYWRkaXRpb25hbF9kb2NfZnJvbnRcIikuZmlsZXMubGVuZ3RoID09IDAgfHwgZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoXCJhZGRpdGlvbmFsX2RvY19iYWNrXCIpLmZpbGVzLmxlbmd0aCA9PSAwKXtcclxuICAgICQoJy5iYW5rX3ZhbGlkYXRpb25zJykuaHRtbChcIjw/cGhwIGVjaG8gJHRoaXMtPmxhbmctPmxpbmUoJ3VwbG9kZV9yZXEnKTs/PlwiKTtcclxuICAgIHJldHVybiBmYWxzZTtcclxuICB9XHJcbiAgZWxzZXtcclxuXHJcbiAgICAkKCcuYWpheC1sb2FkZXInKS5jc3MoXCJ2aXNpYmlsaXR5XCIsIFwidmlzaWJsZVwiKTtcclxuICAgIHZhciBmb3JtRGF0YSA9IG5ldyBGb3JtRGF0YSgkKCBcIiNyZWdpc3Rlcl9zcGVjaWFsaXN0X2ZtXCIgKVswXSk7XHJcbiAgICAkLmFqYXgoe1xyXG4gICAgICBwcm9jZXNzRGF0YTogZmFsc2UsXHJcbiAgICAgIGNvbnRlbnRUeXBlOiBmYWxzZSxcclxuICAgICAgdHlwZTogXCJQT1NUXCIsXHJcbiAgICAgIHVybDogXCI8P3BocCBlY2hvIGJhc2VfdXJsKClzcGVjaWFsaXN0cmVnaXN0ZXIvY3JlYXRlSW5kaXZpc3VhbEFjY291bnRcIixcclxuICAgICAgZGF0YTpmb3JtRGF0YSxcclxuICAgICAgc3VjY2VzczpmdW5jdGlvbihyZXNwb25zZSl7XHJcbiAgICAgICAgdmFyIG9iaiA9IEpTT04ucGFyc2UocmVzcG9uc2UpO1xyXG4gICAgICAgIGlmKG9iai5zdWVjY2VzcyA9PT0gJ3RydWUnKXtcclxuICAgICAgICAgICQoXCIjdGVybXNfYW5kX2NvbmRpdGlvblwiKS5hdHRyKFwiZGlzYWJsZWRcIiwgdHJ1ZSk7XHJcbiAgICAgICAgICAkKCcjc3RyaXBlX2JhbmtfYWNjb3VudCcpLnZhbChvYmouYWNjb3VudF9pZCk7XHJcbiAgICAgICAgICBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgncmVnaXN0ZXJfc3BlY2lhbGlzdF9mbScpLnN1Ym1pdCgpO1xyXG4gICAgICAgICAgdG9hc3RyLm9wdGlvbnMudGltZU91dCA9IDUwMDA7XHJcbiAgICAgICAgICB0b2FzdHIuc3VjY2VzcyhcInN1Y2Nlc3NcIixvYmouc3RyaXBlX3Jlc3Bvc25lKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZXtcclxuICAgICAgICAgICQoJy5hamF4LWxvYWRlcicpLmNzcyhcInZpc2liaWxpdHlcIiwgXCJoaWRkZW5cIik7XHJcbiAgICAgICAgICB0b2FzdHIub3B0aW9ucy50aW1lT3V0ID0gNTAwMDtcclxuICAgICAgICAgIHRvYXN0ci5lcnJvcihcImVycm9yXCIsb2JqLnN0cmlwZV9yZXNwb3NuZSk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgfVxyXG4gICAgfSk7XHJcbiAgfVxyXG59XHJcbjwvc2NyaXB0PlxyXG48c2NyaXB0IHR5cGU9XCJ0ZXh0L2phdmFzY3JpcHRcIj5cclxuXHJcbiQoXCIuc3BlY2lhbGlzdF9jYXRlZ29yeVwiKS5zZWxlY3QyKHtcclxuICBtYXhpbXVtU2VsZWN0aW9uTGVuZ3RoOiAyXHJcbn0pO1xyXG5cclxuJCgnLmJhbmtfdmFsaWRhdGlvbnMnKS5oaWRlKCk7XHJcbmNvbnN0IHN0cmlwZSA9IFN0cmlwZSgncGtfbGl2ZV8yTXpDMmlZNE4yY0h6R2tHelZrWnp4cXkwMFdvSFVoNkZCJyk7XHJcbmNvbnN0IG15Rm9ybSA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoJy5hZGQtYnRuJyk7XHJcbm15Rm9ybS5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsIGhhbmRsZUZvcm0pO1xyXG52YXIgdXBsb2FkX3JlcSA9IFwiPD9waHAgZWNobyAkdGhpcy0+bGFuZy0+bGluZSgndXBsb2RlX3JlcScpOz8+XCI7XHJcbmFzeW5jIGZ1bmN0aW9uIGhhbmRsZUZvcm0oZXZlbnQpIHtcclxuICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xyXG4gIGlmKCBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChcImRvY19mcm9udFwiKS5maWxlcy5sZW5ndGggPT0gMCB8fCBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChcImRvY19iYWNrXCIpLmZpbGVzLmxlbmd0aCA9PSAwIHx8IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKFwiYWRkaXRpb25hbF9kb2NfZnJvbnRcIikuZmlsZXMubGVuZ3RoID09IDAgfHwgZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoXCJhZGRpdGlvbmFsX2RvY19iYWNrXCIpLmZpbGVzLmxlbmd0aCA9PSAwKXtcclxuICAgICQoJy5iYW5rX3ZhbGlkYXRpb25zJykuaHRtbCh1cGxvYWRfcmVxKTtcclxuICAgICQoJy5iYW5rX3ZhbGlkYXRpb25zJykuc2hvdygpO1xyXG4gICAgcmV0dXJuIGZhbHNlO1xyXG4gIH1cclxuICBlbHNle1xyXG4gICAgJCgnLmFqYXgtbG9hZGVyJykuY3NzKFwidmlzaWJpbGl0eVwiLCBcInZpc2libGVcIik7XHJcbiAgICBpZighdmFsaWRhdGVGaWxlVHlwZShlbGVtZW50X2lkID0gJ2RvY19mcm9udCcpKXtcclxuICAgICAgJCgnLmFqYXgtbG9hZGVyJykuY3NzKFwidmlzaWJpbGl0eVwiLCBcImhpZGRlblwiKTtcclxuICAgICAgJCgnLmRvY19mcm9udCcpLmh0bWwodXBsb2FkX2pwZWdfcG5nKTtcclxuICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgfVxyXG4gICAgZWxzZSBpZighdmFsaWRhdGVGaWxlVHlwZShlbGVtZW50X2lkID0gJ2RvY19iYWNrJykpe1xyXG4gICAgICAkKCcuYWpheC1sb2FkZXInKS5jc3MoXCJ2aXNpYmlsaXR5XCIsIFwiaGlkZGVuXCIpO1xyXG4gICAgICAkKCcuZG9jX2Zyb250JykuaHRtbCgnJyk7XHJcbiAgICAgICQoJy5kb2NfYmFjaycpLmh0bWwodXBsb2FkX2pwZWdfcG5nKTtcclxuICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgfVxyXG4gICAgZWxzZSBpZighdmFsaWRhdGVGaWxlVHlwZShlbGVtZW50X2lkID0gJ2FkZGl0aW9uYWxfZG9jX2Zyb250Jykpe1xyXG4gICAgICAkKCcuYWpheC1sb2FkZXInKS5jc3MoXCJ2aXNpYmlsaXR5XCIsIFwiaGlkZGVuXCIpO1xyXG4gICAgICAkKCcuZG9jX2JhY2snKS5odG1sKCcnKTtcclxuICAgICAgJCgnLmFkZGl0aW9uYWxfZG9jX2Zyb250JykuaHRtbCh1cGxvYWRfanBlZ19wbmcpO1xyXG4gICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICB9XHJcbiAgICBlbHNlIGlmKCF2YWxpZGF0ZUZpbGVUeXBlKGVsZW1lbnRfaWQgPSAnYWRkaXRpb25hbF9kb2NfYmFjaycpKXtcclxuICAgICAgJCgnLmFqYXgtbG9hZGVyJykuY3NzKFwidmlzaWJpbGl0eVwiLCBcImhpZGRlblwiKTtcclxuICAgICAgJCgnLmFkZGl0aW9uYWxfZG9jX2Zyb250JykuaHRtbCgnJyk7XHJcbiAgICAgICQoJy5hZGRpdGlvbmFsX2RvY19iYWNrJykuaHRtbCh1cGxvYWRfanBlZ19wbmcpO1xyXG4gICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICB9XHJcbiAgICBlbHNle1xyXG5cclxuICAgICAgLy8gZG9jdW1lbnQgZnJvbnQgZmlsZSB1cGxvYWQgMVxyXG4gICAgICBjb25zdCBkYXRhXzEgPSBuZXcgRm9ybURhdGEoKTtcclxuICAgICAgZGF0YV8xLmFwcGVuZCgnZmlsZScsIGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoJyNkb2NfZnJvbnQnKS5maWxlc1swXSk7XHJcbiAgICAgIGRhdGFfMS5hcHBlbmQoJ3B1cnBvc2UnLCAnaWRlbnRpdHlfZG9jdW1lbnQnKTtcclxuICAgICAgY29uc3QgZmlsZVJlc3VsdF8xID0gYXdhaXQgZmV0Y2goJ2h0dHBzOi8vdXBsb2Fkcy5zdHJpcGUuY29tL3YxL2ZpbGVzJywge1xyXG4gICAgICAgIG1ldGhvZDogJ1BPU1QnLFxyXG4gICAgICAgIGhlYWRlcnM6IHsnQXV0aG9yaXphdGlvbic6ICdCZWFyZXIgcGtfbGl2ZV8yTXpDMmlZNE4yY0h6R2tHelZrWnp4cXkwMFdvSFVoNkZCJ30sXHJcbiAgICAgICAgYm9keTogZGF0YV8xLFxyXG4gICAgICB9KTtcclxuICAgICAgY29uc3QgZmlsZURhdGFfMSA9IGF3YWl0IGZpbGVSZXN1bHRfMS5qc29uKCk7XHJcbiAgICAgIC8vIGRvY3VtZW50IGJhY2sgZmlsZSB1cGxvYWQgMlxyXG4gICAgICBjb25zdCBkYXRhXzIgPSBuZXcgRm9ybURhdGEoKTtcclxuICAgICAgZGF0YV8yLmFwcGVuZCgnZmlsZScsIGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoJyNkb2NfYmFjaycpLmZpbGVzWzBdKTtcclxuICAgICAgZGF0YV8yLmFwcGVuZCgncHVycG9zZScsICdpZGVudGl0eV9kb2N1bWVudCcpO1xyXG4gICAgICBjb25zdCBmaWxlUmVzdWx0XzIgPSBhd2FpdCBmZXRjaCgnaHR0cHM6Ly91cGxvYWRzLnN0cmlwZS5jb20vdjEvZmlsZXMnLCB7XHJcbiAgICAgICAgbWV0aG9kOiAnUE9TVCcsXHJcbiAgICAgICAgaGVhZGVyczogeydBdXRob3JpemF0aW9uJzogJ0JlYXJlciBwa19saXZlXzJNekMyaVk0TjJjSHpHa0d6VmtaenhxeTAwV29IVWg2RkInfSxcclxuICAgICAgICBib2R5OiBkYXRhXzIsXHJcbiAgICAgIH0pO1xyXG4gICAgICBjb25zdCBmaWxlRGF0YV8yID0gYXdhaXQgZmlsZVJlc3VsdF8yLmpzb24oKTtcclxuXHJcbiAgICAgIC8vIGFkZF9kb2MgZnJvbnQgZmlsZSB1cGxvYWQgM1xyXG4gICAgICBjb25zdCBkYXRhXzMgPSBuZXcgRm9ybURhdGEoKTtcclxuICAgICAgZGF0YV8zLmFwcGVuZCgnZmlsZScsIGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoJyNhZGRpdGlvbmFsX2RvY19mcm9udCcpLmZpbGVzWzBdKTtcclxuICAgICAgZGF0YV8zLmFwcGVuZCgncHVycG9zZScsICdpZGVudGl0eV9kb2N1bWVudCcpO1xyXG4gICAgICBjb25zdCBmaWxlUmVzdWx0XzMgPSBhd2FpdCBmZXRjaCgnaHR0cHM6Ly91cGxvYWRzLnN0cmlwZS5jb20vdjEvZmlsZXMnLCB7XHJcbiAgICAgICAgbWV0aG9kOiAnUE9TVCcsXHJcbiAgICAgICAgaGVhZGVyczogeydBdXRob3JpemF0aW9uJzogJ0JlYXJlciBwa19saXZlXzJNekMyaVk0TjJjSHpHa0d6VmtaenhxeTAwV29IVWg2RkInfSxcclxuICAgICAgICBib2R5OiBkYXRhXzMsXHJcbiAgICAgIH0pO1xyXG4gICAgICBjb25zdCBmaWxlRGF0YV8zID0gYXdhaXQgZmlsZVJlc3VsdF8zLmpzb24oKTtcclxuICAgICAgLy8gYWRkX2RvYyBiYWNrIGZpbGUgdXBsb2FkIDRcclxuICAgICAgY29uc3QgZGF0YV80ID0gbmV3IEZvcm1EYXRhKCk7XHJcbiAgICAgIGRhdGFfNC5hcHBlbmQoJ2ZpbGUnLCBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKCcjYWRkaXRpb25hbF9kb2NfYmFjaycpLmZpbGVzWzBdKTtcclxuICAgICAgZGF0YV80LmFwcGVuZCgncHVycG9zZScsICdpZGVudGl0eV9kb2N1bWVudCcpO1xyXG4gICAgICBjb25zdCBmaWxlUmVzdWx0XzQgPSBhd2FpdCBmZXRjaCgnaHR0cHM6Ly91cGxvYWRzLnN0cmlwZS5jb20vdjEvZmlsZXMnLCB7XHJcbiAgICAgICAgbWV0aG9kOiAnUE9TVCcsXHJcbiAgICAgICAgaGVhZGVyczogeydBdXRob3JpemF0aW9uJzogJ0JlYXJlciBwa19saXZlXzJNekMyaVk0TjJjSHpHa0d6VmtaenhxeTAwV29IVWg2RkInfSxcclxuICAgICAgICBib2R5OiBkYXRhXzQsXHJcbiAgICAgIH0pO1xyXG4gICAgICBjb25zdCBmaWxlRGF0YV80ID0gYXdhaXQgZmlsZVJlc3VsdF80Lmpzb24oKTtcclxuXHJcbiAgICAgIHZhciBkYXRlID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvcignLmRhdGVfb2ZfYmlydGgnKS52YWx1ZTtcclxuICAgICAgdmFyIGFycjEgPSBkYXRlLnNwbGl0KCcvJyk7XHJcblxyXG4gICAgICB2YXIgdmFsdWUgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKCcuaW5wLXBob25lJykudmFsdWU7XHJcbiAgICAgIHZhciBtb2JpbGUgPSBcIlwiO1xyXG4gICAgICAvL0ZpcnN0IHJlbW92ZSBhbGwgc3BhY2VzOlxyXG4gICAgICB2YWx1ZSA9IHZhbHVlLnJlcGxhY2UoL1xccy9nLCAnJyk7XHJcbiAgICAgIC8vIHJlbW92ZSB6ZXJvXHJcbiAgICAgIGlmKHZhbHVlLnN0YXJ0c1dpdGgoXCIwXCIpKXtcclxuICAgICAgICB2YXIgdGVtcCA9IHZhbHVlLnN1YnN0cmluZygxLCB2YWx1ZS5sZW5ndGgpO1xyXG4gICAgICAgIG1vYmlsZSA9IHRlbXA7XHJcbiAgICAgICAgLy9Nb2JpbGUgbnVtYmVyOlxyXG4gICAgICAgIGNvbnNvbGUubG9nKG1vYmlsZSk7XHJcbiAgICAgIH0gZWxzZSBpZih2YWx1ZS5zdGFydHNXaXRoKFwiK1wiKSl7XHJcbiAgICAgICAgLy8gcmVtb3ZlIGNvdW50cnkgY29kZVxyXG4gICAgICAgIHZhciB0ZW1wID0gdmFsdWUuc3Vic3RyaW5nKDMsIHZhbHVlLmxlbmd0aCk7XHJcbiAgICAgICAgbW9iaWxlID0gdGVtcDtcclxuICAgICAgICAvL01vYmlsZSBudW1iZXI6XHJcbiAgICAgICAgY29uc29sZS5sb2cobW9iaWxlKTtcclxuICAgICAgfVxyXG4gICAgICBlbHNle1xyXG4gICAgICAgIG1vYmlsZSA9IHZhbHVlO1xyXG4gICAgICAgIC8vTW9iaWxlIG51bWJlcjpcclxuICAgICAgICBjb25zb2xlLmxvZyhtb2JpbGUpO1xyXG4gICAgICB9XHJcbiAgICAgIGNvbnN0IGFjY291bnRSZXN1bHQgPSBhd2FpdCBzdHJpcGUuY3JlYXRlVG9rZW4oJ2FjY291bnQnLCB7XHJcbiAgICAgICAgYnVzaW5lc3NfdHlwZTogJ2luZGl2aWR1YWwnLFxyXG4gICAgICAgIGluZGl2aWR1YWw6IHtcclxuICAgICAgICAgIGZpcnN0X25hbWU6IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoJy5pbnAtcGVyc29uLWZpcnN0LW5hbWUnKS52YWx1ZSxcclxuICAgICAgICAgIGxhc3RfbmFtZTogZG9jdW1lbnQucXVlcnlTZWxlY3RvcignLmlucC1wZXJzb24tbGFzdC1uYW1lJykudmFsdWUsXHJcbiAgICAgICAgICBhZGRyZXNzOiB7XHJcbiAgICAgICAgICAgIGxpbmUxOiBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKCcuaW5wLWNvbXBhbnktc3RyZWV0LWFkZHJlc3MxJykudmFsdWUsXHJcbiAgICAgICAgICAgIGNpdHk6IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoJy5pbnAtY29tcGFueS1jaXR5JykudmFsdWUsXHJcbiAgICAgICAgICAgIHN0YXRlOiBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKCcuaW5wLWNvbXBhbnktc3RhdGUnKS52YWx1ZSxcclxuICAgICAgICAgICAgcG9zdGFsX2NvZGU6IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoJy5pbnAtcGVyc29uLXppcCcpLnZhbHVlLFxyXG4gICAgICAgICAgfSxcclxuICAgICAgICAgIGVtYWlsOmRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoJy5pbnAtZW1haWwnKS52YWx1ZSxcclxuICAgICAgICAgIGRvYjp7XHJcbiAgICAgICAgICAgIGRheTphcnIxWzBdLFxyXG4gICAgICAgICAgICBtb250aDphcnIxWzFdLFxyXG4gICAgICAgICAgICB5ZWFyOmFycjFbMl1cclxuICAgICAgICAgIH0sXHJcbiAgICAgICAgICBwaG9uZTonKzMzJyttb2JpbGUsXHJcbiAgICAgICAgICB2ZXJpZmljYXRpb246IHtcclxuICAgICAgICAgICAgZG9jdW1lbnQ6IHtcclxuICAgICAgICAgICAgICBmcm9udDogZmlsZURhdGFfMS5pZCxcclxuICAgICAgICAgICAgICBiYWNrOiAgZmlsZURhdGFfMi5pZCxcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgYWRkaXRpb25hbF9kb2N1bWVudDoge1xyXG4gICAgICAgICAgICAgIGZyb250OiBmaWxlRGF0YV8zLmlkLFxyXG4gICAgICAgICAgICAgIGJhY2s6IGZpbGVEYXRhXzQuaWQsXHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICB9LFxyXG4gICAgICAgIH0sXHJcbiAgICAgICAgdG9zX3Nob3duX2FuZF9hY2NlcHRlZDogdHJ1ZSxcclxuICAgICAgfSk7XHJcblxyXG4gICAgICBpZiAoYWNjb3VudFJlc3VsdC50b2tlbikge1xyXG4gICAgICAgIGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoJyN0b2tlbi1hY2NvdW50JykudmFsdWUgPSBhY2NvdW50UmVzdWx0LnRva2VuLmlkO1xyXG4gICAgICAgICQoXCIjdGVybXNfYW5kX2NvbmRpdGlvblwiKS5hdHRyKFwiZGlzYWJsZWRcIiwgdHJ1ZSk7XHJcbiAgICAgICAgLy8vJCgnLmFqYXgtbG9hZGVyJykuY3NzKFwidmlzaWJpbGl0eVwiLCBcImhpZGRlblwiKTtcclxuICAgICAgICBoZWxsbygpO1xyXG4gICAgICB9XHJcbiAgICAgIGVsc2V7XHJcbiAgICAgICAgJCgnLmFqYXgtbG9hZGVyJykuY3NzKFwidmlzaWJpbGl0eVwiLCBcImhpZGRlblwiKTtcclxuICAgICAgICB0b2FzdHIub3B0aW9ucy50aW1lT3V0ID0gNTAwMDtcclxuICAgICAgICB0b2FzdHIuZXJyb3IoXCJlcnJvclwiLCBhY2NvdW50UmVzdWx0LmVycm9yLm1lc3NhZ2UpO1xyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgfVxyXG59XHJcbjwvc2NyaXB0PlxyXG5cclxuPHNjcmlwdCB0eXBlPVwidGV4dC9qYXZhc2NyaXB0XCI+XHJcbiQoZG9jdW1lbnQpLnJlYWR5KGZ1bmN0aW9uKCl7XHJcbiAgJChcIiNtb2JpbGVfbnVtYmVyXCIpLmtleXByZXNzKGZ1bmN0aW9uKGV2ZW50KXtcclxuICAgIHZhciBpbnB1dFZhbHVlID0gZXZlbnQuY2hhckNvZGU7XHJcbiAgICBpZighKGlucHV0VmFsdWUgPj0gNDggJiYgaW5wdXRWYWx1ZSA8PSA1NykgJiYgKGlucHV0VmFsdWUgIT0gMzIgJiYgaW5wdXRWYWx1ZSAhPSAwKSl7XHJcbiAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XHJcbiAgICB9XHJcbiAgfSk7XHJcbn0pO1xyXG5cclxuPC9zY3JpcHQ+XHJcblxyXG48c2NyaXB0PlxyXG5cclxuJCgnI3JlZ2lzdGVyX3NwZWNpYWxpc3RfZm0nKS5jbGljayhmdW5jdGlvbigpe1xyXG4gIG15RGl2T2JqID1kb2N1bWVudC5nZXRFbGVtZW50QnlJZChcImZpbGVVcGxvYWRcIik7XHJcbiAgaWYgKG15RGl2T2JqLmlubmVyVGV4dD09J0Nob29zZSBmaWxlJyB8fCBteURpdk9iai5pbm5lclRleHQ9PSdJbXBvcnRlcicgKSB7XHJcbiAgICAkKCcuZXJyb3JfZmlsZScpLnNob3coKTtcclxuICAgICQoJy5kb2Mtc2l6ZScpLmhpZGUoKTtcclxuICB9ZWxzZXtcclxuICAgICQoJy5lcnJvcl9maWxlJykuaGlkZSgpO1xyXG4gICAgJCgnLmRvYy1zaXplJykuc2hvdygpO1xyXG5cclxuICB9XHJcbiAgbXlEaXZPYmoxID1kb2N1bWVudC5nZXRFbGVtZW50QnlJZChcImZpbGVVcGxvYWRfMlwiKTtcclxuICBpZiAobXlEaXZPYmoxLmlubmVyVGV4dD09J0Nob29zZSBmaWxlJyB8fCBteURpdk9iajEuaW5uZXJUZXh0PT0nSW1wb3J0ZXInICkge1xyXG4gICAgJCgnLmVycm9yX2ZpbGVfMScpLnNob3coKTtcclxuICB9ZWxzZXtcclxuICAgICQoJy5lcnJvcl9maWxlXzEnKS5oaWRlKCk7XHJcbiAgfVxyXG5cclxuICBteURpdk9iajIgPWRvY3VtZW50LmdldEVsZW1lbnRCeUlkKFwiZmlsZVVwbG9hZF8zXCIpO1xyXG4gIGlmIChteURpdk9iajIuaW5uZXJUZXh0PT0nQ2hvb3NlIGZpbGUnIHx8IG15RGl2T2JqMi5pbm5lclRleHQ9PSdJbXBvcnRlcicpIHtcclxuICAgICQoJy5lcnJvcl9maWxlXzInKS5zaG93KCk7XHJcbiAgfWVsc2V7XHJcbiAgICAkKCcuZXJyb3JfZmlsZV8yJykuaGlkZSgpO1xyXG5cclxuICB9XHJcblxyXG4gIG15RGl2T2JqMyA9ZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoXCJmaWxlVXBsb2FkXzRcIik7XHJcbiAgaWYgKG15RGl2T2JqMy5pbm5lclRleHQ9PSdDaG9vc2UgZmlsZScgfHwgbXlEaXZPYmozLmlubmVyVGV4dD09J0ltcG9ydGVyJyApIHtcclxuICAgICQoJy5lcnJvcl9maWxlXzMnKS5zaG93KCk7XHJcbiAgICAkKFwiI3Rlcm1zX2FuZF9jb25kaXRpb25cIikuYXR0cihcImNoZWNrZWRcIiwgZmFsc2UpO1xyXG4gIH1lbHNle1xyXG4gICAgJCgnLmVycm9yX2ZpbGVfMycpLmhpZGUoKTtcclxuICB9XHJcbn0pO1xyXG48L3NjcmlwdD4tLT5cclxuIiwiaW1wb3J0IG1vZCBmcm9tIFwiLSEuLi8uLi8uLi8uLi8uLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvY2FjaGUtbG9hZGVyL2Rpc3QvY2pzLmpzPz9yZWYtLTEzLTAhLi4vLi4vLi4vLi4vLi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3RocmVhZC1sb2FkZXIvZGlzdC9janMuanMhLi4vLi4vLi4vLi4vLi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2JhYmVsLWxvYWRlci9saWIvaW5kZXguanMhLi4vLi4vLi4vLi4vLi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2NhY2hlLWxvYWRlci9kaXN0L2Nqcy5qcz8/cmVmLS0xLTAhLi4vLi4vLi4vLi4vLi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL0B2dWUvY2xpLXNlcnZpY2Uvbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvbGliL2luZGV4LmpzPz92dWUtbG9hZGVyLW9wdGlvbnMhLi9BZGQudnVlP3Z1ZSZ0eXBlPXNjcmlwdCZsYW5nPWpzJlwiOyBleHBvcnQgZGVmYXVsdCBtb2Q7IGV4cG9ydCAqIGZyb20gXCItIS4uLy4uLy4uLy4uLy4uLy4uLy4uLy4uL25vZGVfbW9kdWxlcy9jYWNoZS1sb2FkZXIvZGlzdC9janMuanM/P3JlZi0tMTMtMCEuLi8uLi8uLi8uLi8uLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvdGhyZWFkLWxvYWRlci9kaXN0L2Nqcy5qcyEuLi8uLi8uLi8uLi8uLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvYmFiZWwtbG9hZGVyL2xpYi9pbmRleC5qcyEuLi8uLi8uLi8uLi8uLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvY2FjaGUtbG9hZGVyL2Rpc3QvY2pzLmpzPz9yZWYtLTEtMCEuLi8uLi8uLi8uLi8uLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvQHZ1ZS9jbGktc2VydmljZS9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9saWIvaW5kZXguanM/P3Z1ZS1sb2FkZXItb3B0aW9ucyEuL0FkZC52dWU/dnVlJnR5cGU9c2NyaXB0Jmxhbmc9anMmXCIiLCJpbXBvcnQgeyByZW5kZXIsIHN0YXRpY1JlbmRlckZucyB9IGZyb20gXCIuL0FkZC52dWU/dnVlJnR5cGU9dGVtcGxhdGUmaWQ9MDhjNDlkN2YmXCJcbmltcG9ydCBzY3JpcHQgZnJvbSBcIi4vQWRkLnZ1ZT92dWUmdHlwZT1zY3JpcHQmbGFuZz1qcyZcIlxuZXhwb3J0ICogZnJvbSBcIi4vQWRkLnZ1ZT92dWUmdHlwZT1zY3JpcHQmbGFuZz1qcyZcIlxuaW1wb3J0IHN0eWxlMCBmcm9tIFwiLi9BZGQudnVlP3Z1ZSZ0eXBlPXN0eWxlJmluZGV4PTAmbGFuZz1jc3MmXCJcblxuXG4vKiBub3JtYWxpemUgY29tcG9uZW50ICovXG5pbXBvcnQgbm9ybWFsaXplciBmcm9tIFwiIS4uLy4uLy4uLy4uLy4uLy4uLy4uLy4uL25vZGVfbW9kdWxlcy9AdnVlL2NsaS1zZXJ2aWNlL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2xpYi9ydW50aW1lL2NvbXBvbmVudE5vcm1hbGl6ZXIuanNcIlxudmFyIGNvbXBvbmVudCA9IG5vcm1hbGl6ZXIoXG4gIHNjcmlwdCxcbiAgcmVuZGVyLFxuICBzdGF0aWNSZW5kZXJGbnMsXG4gIGZhbHNlLFxuICBudWxsLFxuICBudWxsLFxuICBudWxsXG4gIFxuKVxuXG5leHBvcnQgZGVmYXVsdCBjb21wb25lbnQuZXhwb3J0cyJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///8758\n')},a9fb:function(module,exports,__webpack_require__){eval("var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*!\n * =============================================================\n * dropify v0.2.1 - Override your input files with style.\n * https://github.com/JeremyFagis/dropify\n *\n * (c) 2017 - Jeremy FAGIS <jeremy@fagis.fr> (http://fagis.fr)\n * =============================================================\n */\n\n;(function(root, factory) {\n  if (true) {\n    !(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(\"1157\")], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?\n\t\t\t\t(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n  } else {}\n}(this, function($) {\nvar pluginName = \"dropify\";\n\n/**\n * Dropify plugin\n *\n * @param {Object} element\n * @param {Array} options\n */\nfunction Dropify(element, options) {\n    if (!(window.File && window.FileReader && window.FileList && window.Blob)) {\n        return;\n    }\n\n    var defaults = {\n        defaultFile: '',\n        maxFileSize: 0,\n        minWidth: 0,\n        maxWidth: 0,\n        minHeight: 0,\n        maxHeight: 0,\n        showRemove: true,\n        showLoader: true,\n        showErrors: true,\n        errorTimeout: 3000,\n        errorsPosition: 'overlay',\n        imgFileExtensions: ['png', 'jpg', 'jpeg', 'gif', 'bmp'],\n        maxFileSizePreview: \"5M\",\n        allowedFormats: ['portrait', 'square', 'landscape'],\n        allowedFileExtensions: ['*'],\n        messages: {\n            'default': 'Drag and drop a file here or click',\n            'replace': 'Drag and drop or click to replace',\n            'remove':  'Remove',\n            'error':   'Ooops, something wrong happended.'\n        },\n        error: {\n            'fileSize': 'The file size is too big ({{ value }} max).',\n            'minWidth': 'The image width is too small ({{ value }}}px min).',\n            'maxWidth': 'The image width is too big ({{ value }}}px max).',\n            'minHeight': 'The image height is too small ({{ value }}}px min).',\n            'maxHeight': 'The image height is too big ({{ value }}px max).',\n            'imageFormat': 'The image format is not allowed ({{ value }} only).',\n            'fileExtension': 'The file is not allowed ({{ value }} only).'\n        },\n        tpl: {\n            wrap:            '<div class=\"dropify-wrapper\"></div>',\n            loader:          '<div class=\"dropify-loader\"></div>',\n            message:         '<div class=\"dropify-message\"><span class=\"file-icon\" /> <p>{{ default }}</p></div>',\n            preview:         '<div class=\"dropify-preview\"><span class=\"dropify-render\"></span><div class=\"dropify-infos\"><div class=\"dropify-infos-inner\"><p class=\"dropify-infos-message\">{{ replace }}</p></div></div></div>',\n            filename:        '<p class=\"dropify-filename\"><span class=\"dropify-filename-inner\"></span></p>',\n            clearButton:     '<button type=\"button\" class=\"dropify-clear\">{{ remove }}</button>',\n            errorLine:       '<p class=\"dropify-error\">{{ error }}</p>',\n            errorsContainer: '<div class=\"dropify-errors-container\"><ul></ul></div>'\n        }\n    };\n\n    this.element            = element;\n    this.input              = $(this.element);\n    this.wrapper            = null;\n    this.preview            = null;\n    this.filenameWrapper    = null;\n    this.settings           = $.extend(true, defaults, options, this.input.data());\n    this.errorsEvent        = $.Event('dropify.errors');\n    this.isDisabled         = false;\n    this.isInit             = false;\n    this.file               = {\n        object: null,\n        name: null,\n        size: null,\n        width: null,\n        height: null,\n        type: null\n    };\n\n    if (!Array.isArray(this.settings.allowedFormats)) {\n        this.settings.allowedFormats = this.settings.allowedFormats.split(' ');\n    }\n\n    if (!Array.isArray(this.settings.allowedFileExtensions)) {\n        this.settings.allowedFileExtensions = this.settings.allowedFileExtensions.split(' ');\n    }\n\n    this.onChange     = this.onChange.bind(this);\n    this.clearElement = this.clearElement.bind(this);\n    this.onFileReady  = this.onFileReady.bind(this);\n\n    this.translateMessages();\n    this.createElements();\n    this.setContainerSize();\n\n    this.errorsEvent.errors = [];\n\n    this.input.on('change', this.onChange);\n}\n\n/**\n * On change event\n */\nDropify.prototype.onChange = function()\n{\n    this.resetPreview();\n    this.readFile(this.element);\n};\n\n/**\n * Create dom elements\n */\nDropify.prototype.createElements = function()\n{\n    this.isInit = true;\n    this.input.wrap($(this.settings.tpl.wrap));\n    this.wrapper = this.input.parent();\n\n    var messageWrapper = $(this.settings.tpl.message).insertBefore(this.input);\n    $(this.settings.tpl.errorLine).appendTo(messageWrapper);\n\n    if (this.isTouchDevice() === true) {\n        this.wrapper.addClass('touch-fallback');\n    }\n\n    if (this.input.attr('disabled')) {\n        this.isDisabled = true;\n        this.wrapper.addClass('disabled');\n    }\n\n    if (this.settings.showLoader === true) {\n        this.loader = $(this.settings.tpl.loader);\n        this.loader.insertBefore(this.input);\n    }\n\n    this.preview = $(this.settings.tpl.preview);\n    this.preview.insertAfter(this.input);\n\n    if (this.isDisabled === false && this.settings.showRemove === true) {\n        this.clearButton = $(this.settings.tpl.clearButton);\n        this.clearButton.insertAfter(this.input);\n        this.clearButton.on('click', this.clearElement);\n    }\n\n    this.filenameWrapper = $(this.settings.tpl.filename);\n    this.filenameWrapper.prependTo(this.preview.find('.dropify-infos-inner'));\n\n    if (this.settings.showErrors === true) {\n        this.errorsContainer = $(this.settings.tpl.errorsContainer);\n\n        if (this.settings.errorsPosition === 'outside') {\n            this.errorsContainer.insertAfter(this.wrapper);\n        } else {\n            this.errorsContainer.insertBefore(this.input);\n        }\n    }\n\n    var defaultFile = this.settings.defaultFile || '';\n\n    if (defaultFile.trim() !== '') {\n        this.file.name = this.cleanFilename(defaultFile);\n        this.setPreview(this.isImage(), defaultFile);\n    }\n};\n\n/**\n * Read the file using FileReader\n *\n * @param  {Object} input\n */\nDropify.prototype.readFile = function(input)\n{\n    if (input.files && input.files[0]) {\n        var reader         = new FileReader();\n        var image          = new Image();\n        var file           = input.files[0];\n        var srcBase64      = null;\n        var _this          = this;\n        var eventFileReady = $.Event(\"dropify.fileReady\");\n\n        this.clearErrors();\n        this.showLoader();\n        this.setFileInformations(file);\n        this.errorsEvent.errors = [];\n        this.checkFileSize();\n\t\tthis.isFileExtensionAllowed();\n\n        if (this.isImage() && this.file.size < this.sizeToByte(this.settings.maxFileSizePreview)) {\n            this.input.on('dropify.fileReady', this.onFileReady);\n            reader.readAsDataURL(file);\n            reader.onload = function(_file) {\n                srcBase64 = _file.target.result;\n                image.src = _file.target.result;\n                image.onload = function() {\n                    _this.setFileDimensions(this.width, this.height);\n                    _this.validateImage();\n                    _this.input.trigger(eventFileReady, [true, srcBase64]);\n                };\n\n            }.bind(this);\n        } else {\n            this.onFileReady(false);\n        }\n    }\n};\n\n/**\n * On file ready to show\n *\n * @param  {Event} event\n * @param  {Bool} previewable\n * @param  {String} src\n */\nDropify.prototype.onFileReady = function(event, previewable, src)\n{\n    this.input.off('dropify.fileReady', this.onFileReady);\n\n    if (this.errorsEvent.errors.length === 0) {\n        this.setPreview(previewable, src);\n    } else {\n        this.input.trigger(this.errorsEvent, [this]);\n        for (var i = this.errorsEvent.errors.length - 1; i >= 0; i--) {\n            var errorNamespace = this.errorsEvent.errors[i].namespace;\n            var errorKey = errorNamespace.split('.').pop();\n            this.showError(errorKey);\n        }\n\n        if (typeof this.errorsContainer !== \"undefined\") {\n            this.errorsContainer.addClass('visible');\n\n            var errorsContainer = this.errorsContainer;\n            setTimeout(function(){ errorsContainer.removeClass('visible'); }, this.settings.errorTimeout);\n        }\n\n        this.wrapper.addClass('has-error');\n        this.resetPreview();\n        this.clearElement();\n    }\n};\n\n/**\n * Set file informations\n *\n * @param {File} file\n */\nDropify.prototype.setFileInformations = function(file)\n{\n    this.file.object = file;\n    this.file.name   = file.name;\n    this.file.size   = file.size;\n    this.file.type   = file.type;\n    this.file.width  = null;\n    this.file.height = null;\n};\n\n/**\n * Set file dimensions\n *\n * @param {Int} width\n * @param {Int} height\n */\nDropify.prototype.setFileDimensions = function(width, height)\n{\n    this.file.width  = width;\n    this.file.height = height;\n};\n\n/**\n * Set the preview and animate it\n *\n * @param {String} src\n */\nDropify.prototype.setPreview = function(previewable, src)\n{\n    this.wrapper.removeClass('has-error').addClass('has-preview');\n    this.filenameWrapper.children('.dropify-filename-inner').html(this.file.name);\n    var render = this.preview.children('.dropify-render');\n\n    this.hideLoader();\n\n    if (previewable === true) {\n        var imgTag = $('<img />').attr('src', src);\n\n        if (this.settings.height) {\n            imgTag.css(\"max-height\", this.settings.height);\n        }\n\n        imgTag.appendTo(render);\n    } else {\n        $('<i />').attr('class', 'dropify-font-file').appendTo(render);\n        $('<span class=\"dropify-extension\" />').html(this.getFileType()).appendTo(render);\n    }\n    this.preview.fadeIn();\n};\n\n/**\n * Reset the preview\n */\nDropify.prototype.resetPreview = function()\n{\n    this.wrapper.removeClass('has-preview');\n    var render = this.preview.children('.dropify-render');\n    render.find('.dropify-extension').remove();\n    render.find('i').remove();\n    render.find('img').remove();\n    this.preview.hide();\n    this.hideLoader();\n};\n\n/**\n * Clean the src and get the filename\n *\n * @param  {String} src\n *\n * @return {String} filename\n */\nDropify.prototype.cleanFilename = function(src)\n{\n    var filename = src.split('\\\\').pop();\n    if (filename == src) {\n        filename = src.split('/').pop();\n    }\n\n    return src !== \"\" ? filename : '';\n};\n\n/**\n * Clear the element, events are available\n */\nDropify.prototype.clearElement = function()\n{\n    if (this.errorsEvent.errors.length === 0) {\n        var eventBefore = $.Event(\"dropify.beforeClear\");\n        this.input.trigger(eventBefore, [this]);\n\n        if (eventBefore.result !== false) {\n            this.resetFile();\n            this.input.val('');\n            this.resetPreview();\n\n            this.input.trigger($.Event(\"dropify.afterClear\"), [this]);\n        }\n    } else {\n        this.resetFile();\n        this.input.val('');\n        this.resetPreview();\n    }\n};\n\n/**\n * Reset file informations\n */\nDropify.prototype.resetFile = function()\n{\n    this.file.object = null;\n    this.file.name   = null;\n    this.file.size   = null;\n    this.file.type   = null;\n    this.file.width  = null;\n    this.file.height = null;\n};\n\n/**\n * Set the container height\n */\nDropify.prototype.setContainerSize = function()\n{\n    if (this.settings.height) {\n        this.wrapper.height(this.settings.height);\n    }\n};\n\n/**\n * Test if it's touch screen\n *\n * @return {Boolean}\n */\nDropify.prototype.isTouchDevice = function()\n{\n    return (('ontouchstart' in window) ||\n            (navigator.MaxTouchPoints > 0) ||\n            (navigator.msMaxTouchPoints > 0));\n};\n\n/**\n * Get the file type.\n *\n * @return {String}\n */\nDropify.prototype.getFileType = function()\n{\n    return this.file.name.split('.').pop().toLowerCase();\n};\n\n/**\n * Test if the file is an image\n *\n * @return {Boolean}\n */\nDropify.prototype.isImage = function()\n{\n    if (this.settings.imgFileExtensions.indexOf(this.getFileType()) != \"-1\") {\n        return true;\n    }\n\n    return false;\n};\n\n/**\n* Test if the file extension is allowed\n*\n* @return {Boolean}\n*/\nDropify.prototype.isFileExtensionAllowed = function () {\n\n\tif (this.settings.allowedFileExtensions.indexOf('*') != \"-1\" || \n        this.settings.allowedFileExtensions.indexOf(this.getFileType()) != \"-1\") {\n\t\treturn true;\n\t}\n\tthis.pushError(\"fileExtension\");\n\n\treturn false;\n};\n\n/**\n * Translate messages if needed.\n */\nDropify.prototype.translateMessages = function()\n{\n    for (var name in this.settings.tpl) {\n        for (var key in this.settings.messages) {\n            this.settings.tpl[name] = this.settings.tpl[name].replace('{{ ' + key + ' }}', this.settings.messages[key]);\n        }\n    }\n};\n\n/**\n * Check the limit filesize.\n */\nDropify.prototype.checkFileSize = function()\n{\n    if (this.sizeToByte(this.settings.maxFileSize) !== 0 && this.file.size > this.sizeToByte(this.settings.maxFileSize)) {\n        this.pushError(\"fileSize\");\n    }\n};\n\n/**\n * Convert filesize to byte.\n *\n * @return {Int} value\n */\nDropify.prototype.sizeToByte = function(size)\n{\n    var value = 0;\n\n    if (size !== 0) {\n        var unit  = size.slice(-1).toUpperCase(),\n            kb    = 1024,\n            mb    = kb * 1024,\n            gb    = mb * 1024;\n\n        if (unit === 'K') {\n            value = parseFloat(size) * kb;\n        } else if (unit === 'M') {\n            value = parseFloat(size) * mb;\n        } else if (unit === 'G') {\n            value = parseFloat(size) * gb;\n        }\n    }\n\n    return value;\n};\n\n/**\n * Validate image dimensions and format\n */\nDropify.prototype.validateImage = function()\n{\n    if (this.settings.minWidth !== 0 && this.settings.minWidth >= this.file.width) {\n        this.pushError(\"minWidth\");\n    }\n\n    if (this.settings.maxWidth !== 0 && this.settings.maxWidth <= this.file.width) {\n        this.pushError(\"maxWidth\");\n    }\n\n    if (this.settings.minHeight !== 0 && this.settings.minHeight >= this.file.height) {\n        this.pushError(\"minHeight\");\n    }\n\n    if (this.settings.maxHeight !== 0 && this.settings.maxHeight <= this.file.height) {\n        this.pushError(\"maxHeight\");\n    }\n\n    if (this.settings.allowedFormats.indexOf(this.getImageFormat()) == \"-1\") {\n        this.pushError(\"imageFormat\");\n    }\n};\n\n/**\n * Get image format.\n *\n * @return {String}\n */\nDropify.prototype.getImageFormat = function()\n{\n    if (this.file.width == this.file.height) {\n        return \"square\";\n    }\n\n    if (this.file.width < this.file.height) {\n        return \"portrait\";\n    }\n\n    if (this.file.width > this.file.height) {\n        return \"landscape\";\n    }\n};\n\n/**\n* Push error\n*\n* @param {String} errorKey\n*/\nDropify.prototype.pushError = function(errorKey) {\n    var e = $.Event(\"dropify.error.\" + errorKey);\n    this.errorsEvent.errors.push(e);\n    this.input.trigger(e, [this]);\n};\n\n/**\n * Clear errors\n */\nDropify.prototype.clearErrors = function()\n{\n    if (typeof this.errorsContainer !== \"undefined\") {\n        this.errorsContainer.children('ul').html('');\n    }\n};\n\n/**\n * Show error in DOM\n *\n * @param  {String} errorKey\n */\nDropify.prototype.showError = function(errorKey)\n{\n    if (typeof this.errorsContainer !== \"undefined\") {\n        this.errorsContainer.children('ul').append('<li>' + this.getError(errorKey) + '</li>');\n    }\n};\n\n/**\n * Get error message\n *\n * @return  {String} message\n */\nDropify.prototype.getError = function(errorKey)\n{\n    var error = this.settings.error[errorKey],\n        value = '';\n\n    if (errorKey === 'fileSize') {\n        value = this.settings.maxFileSize;\n    } else if (errorKey === 'minWidth') {\n        value = this.settings.minWidth;\n    } else if (errorKey === 'maxWidth') {\n        value = this.settings.maxWidth;\n    } else if (errorKey === 'minHeight') {\n        value = this.settings.minHeight;\n    } else if (errorKey === 'maxHeight') {\n        value = this.settings.maxHeight;\n    } else if (errorKey === 'imageFormat') {\n        value = this.settings.allowedFormats.join(', ');\n    } else if (errorKey === 'fileExtension') {\n\t\tvalue = this.settings.allowedFileExtensions.join(', ');\n\t}\n\n    if (value !== '') {\n        return error.replace('{{ value }}', value);\n    }\n\n    return error;\n};\n\n/**\n * Show the loader\n */\nDropify.prototype.showLoader = function()\n{\n    if (typeof this.loader !== \"undefined\") {\n        this.loader.show();\n    }\n};\n\n/**\n * Hide the loader\n */\nDropify.prototype.hideLoader = function()\n{\n    if (typeof this.loader !== \"undefined\") {\n        this.loader.hide();\n    }\n};\n\n/**\n * Destroy dropify\n */\nDropify.prototype.destroy = function()\n{\n    this.input.siblings().remove();\n    this.input.unwrap();\n    this.isInit = false;\n};\n\n/**\n * Init dropify\n */\nDropify.prototype.init = function()\n{\n    this.createElements();\n};\n\n/**\n * Test if element is init\n */\nDropify.prototype.isDropified = function()\n{\n    return this.isInit;\n};\n\n$.fn[pluginName] = function(options) {\n    this.each(function() {\n        if (!$.data(this, pluginName)) {\n            $.data(this, pluginName, new Dropify(this, options));\n        }\n    });\n\n    return this;\n};\n\n\nreturn Dropify;\n}));\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZHJvcGlmeS9kaXN0L2pzL2Ryb3BpZnkuanM/YTlmYiJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLENBQUM7QUFDRCxNQUFNLElBQTBDO0FBQ2hELElBQUksaUNBQU8sQ0FBQywyQkFBUSxDQUFDLG9DQUFFLE9BQU87QUFBQTtBQUFBO0FBQUEsb0dBQUM7QUFDL0IsR0FBRyxNQUFNLEVBSU47QUFDSCxDQUFDO0FBQ0Q7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxPQUFPO0FBQ2xCLFdBQVcsTUFBTTtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLHFEQUFxRCxTQUFTO0FBQzlELHlEQUF5RCxVQUFVO0FBQ25FLHVEQUF1RCxVQUFVO0FBQ2pFLDJEQUEyRCxVQUFVO0FBQ3JFLHlEQUF5RCxTQUFTO0FBQ2xFLCtEQUErRCxTQUFTO0FBQ3hFLHlEQUF5RCxTQUFTO0FBQ2xFLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSwyRkFBMkYsV0FBVztBQUN0Ryw4TEFBOEwsV0FBVztBQUN6TTtBQUNBLDRFQUE0RSxVQUFVO0FBQ3RGLHlEQUF5RCxTQUFTO0FBQ2xFO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsWUFBWSxPQUFPO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGFBQWE7QUFDYixTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsWUFBWSxNQUFNO0FBQ2xCLFlBQVksS0FBSztBQUNqQixZQUFZLE9BQU87QUFDbkI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLHdEQUF3RCxRQUFRO0FBQ2hFO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxrQ0FBa0Msd0NBQXdDLEVBQUU7QUFDNUU7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLEtBQUs7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxJQUFJO0FBQ2YsV0FBVyxJQUFJO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsT0FBTztBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLE9BQU87QUFDbkI7QUFDQSxZQUFZLE9BQU87QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUVBQXlFLGVBQWU7QUFDeEY7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLElBQUk7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsVUFBVSxPQUFPO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsWUFBWSxPQUFPO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsT0FBTztBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxLQUFLO0FBQ0w7QUFDQSxLQUFLO0FBQ0w7QUFDQSxLQUFLO0FBQ0w7QUFDQSxLQUFLO0FBQ0w7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBLGdDQUFnQyxTQUFTO0FBQ3pDOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTs7O0FBR0E7QUFDQSxDQUFDIiwiZmlsZSI6ImE5ZmIuanMiLCJzb3VyY2VzQ29udGVudCI6WyIvKiFcbiAqID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAqIGRyb3BpZnkgdjAuMi4xIC0gT3ZlcnJpZGUgeW91ciBpbnB1dCBmaWxlcyB3aXRoIHN0eWxlLlxuICogaHR0cHM6Ly9naXRodWIuY29tL0plcmVteUZhZ2lzL2Ryb3BpZnlcbiAqXG4gKiAoYykgMjAxNyAtIEplcmVteSBGQUdJUyA8amVyZW15QGZhZ2lzLmZyPiAoaHR0cDovL2ZhZ2lzLmZyKVxuICogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICovXG5cbjsoZnVuY3Rpb24ocm9vdCwgZmFjdG9yeSkge1xuICBpZiAodHlwZW9mIGRlZmluZSA9PT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmUuYW1kKSB7XG4gICAgZGVmaW5lKFsnanF1ZXJ5J10sIGZhY3RvcnkpO1xuICB9IGVsc2UgaWYgKHR5cGVvZiBleHBvcnRzID09PSAnb2JqZWN0Jykge1xuICAgIG1vZHVsZS5leHBvcnRzID0gZmFjdG9yeShyZXF1aXJlKCdqcXVlcnknKSk7XG4gIH0gZWxzZSB7XG4gICAgcm9vdC5Ecm9waWZ5ID0gZmFjdG9yeShyb290LmpRdWVyeSk7XG4gIH1cbn0odGhpcywgZnVuY3Rpb24oJCkge1xudmFyIHBsdWdpbk5hbWUgPSBcImRyb3BpZnlcIjtcblxuLyoqXG4gKiBEcm9waWZ5IHBsdWdpblxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBlbGVtZW50XG4gKiBAcGFyYW0ge0FycmF5fSBvcHRpb25zXG4gKi9cbmZ1bmN0aW9uIERyb3BpZnkoZWxlbWVudCwgb3B0aW9ucykge1xuICAgIGlmICghKHdpbmRvdy5GaWxlICYmIHdpbmRvdy5GaWxlUmVhZGVyICYmIHdpbmRvdy5GaWxlTGlzdCAmJiB3aW5kb3cuQmxvYikpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHZhciBkZWZhdWx0cyA9IHtcbiAgICAgICAgZGVmYXVsdEZpbGU6ICcnLFxuICAgICAgICBtYXhGaWxlU2l6ZTogMCxcbiAgICAgICAgbWluV2lkdGg6IDAsXG4gICAgICAgIG1heFdpZHRoOiAwLFxuICAgICAgICBtaW5IZWlnaHQ6IDAsXG4gICAgICAgIG1heEhlaWdodDogMCxcbiAgICAgICAgc2hvd1JlbW92ZTogdHJ1ZSxcbiAgICAgICAgc2hvd0xvYWRlcjogdHJ1ZSxcbiAgICAgICAgc2hvd0Vycm9yczogdHJ1ZSxcbiAgICAgICAgZXJyb3JUaW1lb3V0OiAzMDAwLFxuICAgICAgICBlcnJvcnNQb3NpdGlvbjogJ292ZXJsYXknLFxuICAgICAgICBpbWdGaWxlRXh0ZW5zaW9uczogWydwbmcnLCAnanBnJywgJ2pwZWcnLCAnZ2lmJywgJ2JtcCddLFxuICAgICAgICBtYXhGaWxlU2l6ZVByZXZpZXc6IFwiNU1cIixcbiAgICAgICAgYWxsb3dlZEZvcm1hdHM6IFsncG9ydHJhaXQnLCAnc3F1YXJlJywgJ2xhbmRzY2FwZSddLFxuICAgICAgICBhbGxvd2VkRmlsZUV4dGVuc2lvbnM6IFsnKiddLFxuICAgICAgICBtZXNzYWdlczoge1xuICAgICAgICAgICAgJ2RlZmF1bHQnOiAnRHJhZyBhbmQgZHJvcCBhIGZpbGUgaGVyZSBvciBjbGljaycsXG4gICAgICAgICAgICAncmVwbGFjZSc6ICdEcmFnIGFuZCBkcm9wIG9yIGNsaWNrIHRvIHJlcGxhY2UnLFxuICAgICAgICAgICAgJ3JlbW92ZSc6ICAnUmVtb3ZlJyxcbiAgICAgICAgICAgICdlcnJvcic6ICAgJ09vb3BzLCBzb21ldGhpbmcgd3JvbmcgaGFwcGVuZGVkLidcbiAgICAgICAgfSxcbiAgICAgICAgZXJyb3I6IHtcbiAgICAgICAgICAgICdmaWxlU2l6ZSc6ICdUaGUgZmlsZSBzaXplIGlzIHRvbyBiaWcgKHt7IHZhbHVlIH19IG1heCkuJyxcbiAgICAgICAgICAgICdtaW5XaWR0aCc6ICdUaGUgaW1hZ2Ugd2lkdGggaXMgdG9vIHNtYWxsICh7eyB2YWx1ZSB9fX1weCBtaW4pLicsXG4gICAgICAgICAgICAnbWF4V2lkdGgnOiAnVGhlIGltYWdlIHdpZHRoIGlzIHRvbyBiaWcgKHt7IHZhbHVlIH19fXB4IG1heCkuJyxcbiAgICAgICAgICAgICdtaW5IZWlnaHQnOiAnVGhlIGltYWdlIGhlaWdodCBpcyB0b28gc21hbGwgKHt7IHZhbHVlIH19fXB4IG1pbikuJyxcbiAgICAgICAgICAgICdtYXhIZWlnaHQnOiAnVGhlIGltYWdlIGhlaWdodCBpcyB0b28gYmlnICh7eyB2YWx1ZSB9fXB4IG1heCkuJyxcbiAgICAgICAgICAgICdpbWFnZUZvcm1hdCc6ICdUaGUgaW1hZ2UgZm9ybWF0IGlzIG5vdCBhbGxvd2VkICh7eyB2YWx1ZSB9fSBvbmx5KS4nLFxuICAgICAgICAgICAgJ2ZpbGVFeHRlbnNpb24nOiAnVGhlIGZpbGUgaXMgbm90IGFsbG93ZWQgKHt7IHZhbHVlIH19IG9ubHkpLidcbiAgICAgICAgfSxcbiAgICAgICAgdHBsOiB7XG4gICAgICAgICAgICB3cmFwOiAgICAgICAgICAgICc8ZGl2IGNsYXNzPVwiZHJvcGlmeS13cmFwcGVyXCI+PC9kaXY+JyxcbiAgICAgICAgICAgIGxvYWRlcjogICAgICAgICAgJzxkaXYgY2xhc3M9XCJkcm9waWZ5LWxvYWRlclwiPjwvZGl2PicsXG4gICAgICAgICAgICBtZXNzYWdlOiAgICAgICAgICc8ZGl2IGNsYXNzPVwiZHJvcGlmeS1tZXNzYWdlXCI+PHNwYW4gY2xhc3M9XCJmaWxlLWljb25cIiAvPiA8cD57eyBkZWZhdWx0IH19PC9wPjwvZGl2PicsXG4gICAgICAgICAgICBwcmV2aWV3OiAgICAgICAgICc8ZGl2IGNsYXNzPVwiZHJvcGlmeS1wcmV2aWV3XCI+PHNwYW4gY2xhc3M9XCJkcm9waWZ5LXJlbmRlclwiPjwvc3Bhbj48ZGl2IGNsYXNzPVwiZHJvcGlmeS1pbmZvc1wiPjxkaXYgY2xhc3M9XCJkcm9waWZ5LWluZm9zLWlubmVyXCI+PHAgY2xhc3M9XCJkcm9waWZ5LWluZm9zLW1lc3NhZ2VcIj57eyByZXBsYWNlIH19PC9wPjwvZGl2PjwvZGl2PjwvZGl2PicsXG4gICAgICAgICAgICBmaWxlbmFtZTogICAgICAgICc8cCBjbGFzcz1cImRyb3BpZnktZmlsZW5hbWVcIj48c3BhbiBjbGFzcz1cImRyb3BpZnktZmlsZW5hbWUtaW5uZXJcIj48L3NwYW4+PC9wPicsXG4gICAgICAgICAgICBjbGVhckJ1dHRvbjogICAgICc8YnV0dG9uIHR5cGU9XCJidXR0b25cIiBjbGFzcz1cImRyb3BpZnktY2xlYXJcIj57eyByZW1vdmUgfX08L2J1dHRvbj4nLFxuICAgICAgICAgICAgZXJyb3JMaW5lOiAgICAgICAnPHAgY2xhc3M9XCJkcm9waWZ5LWVycm9yXCI+e3sgZXJyb3IgfX08L3A+JyxcbiAgICAgICAgICAgIGVycm9yc0NvbnRhaW5lcjogJzxkaXYgY2xhc3M9XCJkcm9waWZ5LWVycm9ycy1jb250YWluZXJcIj48dWw+PC91bD48L2Rpdj4nXG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgdGhpcy5lbGVtZW50ICAgICAgICAgICAgPSBlbGVtZW50O1xuICAgIHRoaXMuaW5wdXQgICAgICAgICAgICAgID0gJCh0aGlzLmVsZW1lbnQpO1xuICAgIHRoaXMud3JhcHBlciAgICAgICAgICAgID0gbnVsbDtcbiAgICB0aGlzLnByZXZpZXcgICAgICAgICAgICA9IG51bGw7XG4gICAgdGhpcy5maWxlbmFtZVdyYXBwZXIgICAgPSBudWxsO1xuICAgIHRoaXMuc2V0dGluZ3MgICAgICAgICAgID0gJC5leHRlbmQodHJ1ZSwgZGVmYXVsdHMsIG9wdGlvbnMsIHRoaXMuaW5wdXQuZGF0YSgpKTtcbiAgICB0aGlzLmVycm9yc0V2ZW50ICAgICAgICA9ICQuRXZlbnQoJ2Ryb3BpZnkuZXJyb3JzJyk7XG4gICAgdGhpcy5pc0Rpc2FibGVkICAgICAgICAgPSBmYWxzZTtcbiAgICB0aGlzLmlzSW5pdCAgICAgICAgICAgICA9IGZhbHNlO1xuICAgIHRoaXMuZmlsZSAgICAgICAgICAgICAgID0ge1xuICAgICAgICBvYmplY3Q6IG51bGwsXG4gICAgICAgIG5hbWU6IG51bGwsXG4gICAgICAgIHNpemU6IG51bGwsXG4gICAgICAgIHdpZHRoOiBudWxsLFxuICAgICAgICBoZWlnaHQ6IG51bGwsXG4gICAgICAgIHR5cGU6IG51bGxcbiAgICB9O1xuXG4gICAgaWYgKCFBcnJheS5pc0FycmF5KHRoaXMuc2V0dGluZ3MuYWxsb3dlZEZvcm1hdHMpKSB7XG4gICAgICAgIHRoaXMuc2V0dGluZ3MuYWxsb3dlZEZvcm1hdHMgPSB0aGlzLnNldHRpbmdzLmFsbG93ZWRGb3JtYXRzLnNwbGl0KCcgJyk7XG4gICAgfVxuXG4gICAgaWYgKCFBcnJheS5pc0FycmF5KHRoaXMuc2V0dGluZ3MuYWxsb3dlZEZpbGVFeHRlbnNpb25zKSkge1xuICAgICAgICB0aGlzLnNldHRpbmdzLmFsbG93ZWRGaWxlRXh0ZW5zaW9ucyA9IHRoaXMuc2V0dGluZ3MuYWxsb3dlZEZpbGVFeHRlbnNpb25zLnNwbGl0KCcgJyk7XG4gICAgfVxuXG4gICAgdGhpcy5vbkNoYW5nZSAgICAgPSB0aGlzLm9uQ2hhbmdlLmJpbmQodGhpcyk7XG4gICAgdGhpcy5jbGVhckVsZW1lbnQgPSB0aGlzLmNsZWFyRWxlbWVudC5iaW5kKHRoaXMpO1xuICAgIHRoaXMub25GaWxlUmVhZHkgID0gdGhpcy5vbkZpbGVSZWFkeS5iaW5kKHRoaXMpO1xuXG4gICAgdGhpcy50cmFuc2xhdGVNZXNzYWdlcygpO1xuICAgIHRoaXMuY3JlYXRlRWxlbWVudHMoKTtcbiAgICB0aGlzLnNldENvbnRhaW5lclNpemUoKTtcblxuICAgIHRoaXMuZXJyb3JzRXZlbnQuZXJyb3JzID0gW107XG5cbiAgICB0aGlzLmlucHV0Lm9uKCdjaGFuZ2UnLCB0aGlzLm9uQ2hhbmdlKTtcbn1cblxuLyoqXG4gKiBPbiBjaGFuZ2UgZXZlbnRcbiAqL1xuRHJvcGlmeS5wcm90b3R5cGUub25DaGFuZ2UgPSBmdW5jdGlvbigpXG57XG4gICAgdGhpcy5yZXNldFByZXZpZXcoKTtcbiAgICB0aGlzLnJlYWRGaWxlKHRoaXMuZWxlbWVudCk7XG59O1xuXG4vKipcbiAqIENyZWF0ZSBkb20gZWxlbWVudHNcbiAqL1xuRHJvcGlmeS5wcm90b3R5cGUuY3JlYXRlRWxlbWVudHMgPSBmdW5jdGlvbigpXG57XG4gICAgdGhpcy5pc0luaXQgPSB0cnVlO1xuICAgIHRoaXMuaW5wdXQud3JhcCgkKHRoaXMuc2V0dGluZ3MudHBsLndyYXApKTtcbiAgICB0aGlzLndyYXBwZXIgPSB0aGlzLmlucHV0LnBhcmVudCgpO1xuXG4gICAgdmFyIG1lc3NhZ2VXcmFwcGVyID0gJCh0aGlzLnNldHRpbmdzLnRwbC5tZXNzYWdlKS5pbnNlcnRCZWZvcmUodGhpcy5pbnB1dCk7XG4gICAgJCh0aGlzLnNldHRpbmdzLnRwbC5lcnJvckxpbmUpLmFwcGVuZFRvKG1lc3NhZ2VXcmFwcGVyKTtcblxuICAgIGlmICh0aGlzLmlzVG91Y2hEZXZpY2UoKSA9PT0gdHJ1ZSkge1xuICAgICAgICB0aGlzLndyYXBwZXIuYWRkQ2xhc3MoJ3RvdWNoLWZhbGxiYWNrJyk7XG4gICAgfVxuXG4gICAgaWYgKHRoaXMuaW5wdXQuYXR0cignZGlzYWJsZWQnKSkge1xuICAgICAgICB0aGlzLmlzRGlzYWJsZWQgPSB0cnVlO1xuICAgICAgICB0aGlzLndyYXBwZXIuYWRkQ2xhc3MoJ2Rpc2FibGVkJyk7XG4gICAgfVxuXG4gICAgaWYgKHRoaXMuc2V0dGluZ3Muc2hvd0xvYWRlciA9PT0gdHJ1ZSkge1xuICAgICAgICB0aGlzLmxvYWRlciA9ICQodGhpcy5zZXR0aW5ncy50cGwubG9hZGVyKTtcbiAgICAgICAgdGhpcy5sb2FkZXIuaW5zZXJ0QmVmb3JlKHRoaXMuaW5wdXQpO1xuICAgIH1cblxuICAgIHRoaXMucHJldmlldyA9ICQodGhpcy5zZXR0aW5ncy50cGwucHJldmlldyk7XG4gICAgdGhpcy5wcmV2aWV3Lmluc2VydEFmdGVyKHRoaXMuaW5wdXQpO1xuXG4gICAgaWYgKHRoaXMuaXNEaXNhYmxlZCA9PT0gZmFsc2UgJiYgdGhpcy5zZXR0aW5ncy5zaG93UmVtb3ZlID09PSB0cnVlKSB7XG4gICAgICAgIHRoaXMuY2xlYXJCdXR0b24gPSAkKHRoaXMuc2V0dGluZ3MudHBsLmNsZWFyQnV0dG9uKTtcbiAgICAgICAgdGhpcy5jbGVhckJ1dHRvbi5pbnNlcnRBZnRlcih0aGlzLmlucHV0KTtcbiAgICAgICAgdGhpcy5jbGVhckJ1dHRvbi5vbignY2xpY2snLCB0aGlzLmNsZWFyRWxlbWVudCk7XG4gICAgfVxuXG4gICAgdGhpcy5maWxlbmFtZVdyYXBwZXIgPSAkKHRoaXMuc2V0dGluZ3MudHBsLmZpbGVuYW1lKTtcbiAgICB0aGlzLmZpbGVuYW1lV3JhcHBlci5wcmVwZW5kVG8odGhpcy5wcmV2aWV3LmZpbmQoJy5kcm9waWZ5LWluZm9zLWlubmVyJykpO1xuXG4gICAgaWYgKHRoaXMuc2V0dGluZ3Muc2hvd0Vycm9ycyA9PT0gdHJ1ZSkge1xuICAgICAgICB0aGlzLmVycm9yc0NvbnRhaW5lciA9ICQodGhpcy5zZXR0aW5ncy50cGwuZXJyb3JzQ29udGFpbmVyKTtcblxuICAgICAgICBpZiAodGhpcy5zZXR0aW5ncy5lcnJvcnNQb3NpdGlvbiA9PT0gJ291dHNpZGUnKSB7XG4gICAgICAgICAgICB0aGlzLmVycm9yc0NvbnRhaW5lci5pbnNlcnRBZnRlcih0aGlzLndyYXBwZXIpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5lcnJvcnNDb250YWluZXIuaW5zZXJ0QmVmb3JlKHRoaXMuaW5wdXQpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgdmFyIGRlZmF1bHRGaWxlID0gdGhpcy5zZXR0aW5ncy5kZWZhdWx0RmlsZSB8fCAnJztcblxuICAgIGlmIChkZWZhdWx0RmlsZS50cmltKCkgIT09ICcnKSB7XG4gICAgICAgIHRoaXMuZmlsZS5uYW1lID0gdGhpcy5jbGVhbkZpbGVuYW1lKGRlZmF1bHRGaWxlKTtcbiAgICAgICAgdGhpcy5zZXRQcmV2aWV3KHRoaXMuaXNJbWFnZSgpLCBkZWZhdWx0RmlsZSk7XG4gICAgfVxufTtcblxuLyoqXG4gKiBSZWFkIHRoZSBmaWxlIHVzaW5nIEZpbGVSZWFkZXJcbiAqXG4gKiBAcGFyYW0gIHtPYmplY3R9IGlucHV0XG4gKi9cbkRyb3BpZnkucHJvdG90eXBlLnJlYWRGaWxlID0gZnVuY3Rpb24oaW5wdXQpXG57XG4gICAgaWYgKGlucHV0LmZpbGVzICYmIGlucHV0LmZpbGVzWzBdKSB7XG4gICAgICAgIHZhciByZWFkZXIgICAgICAgICA9IG5ldyBGaWxlUmVhZGVyKCk7XG4gICAgICAgIHZhciBpbWFnZSAgICAgICAgICA9IG5ldyBJbWFnZSgpO1xuICAgICAgICB2YXIgZmlsZSAgICAgICAgICAgPSBpbnB1dC5maWxlc1swXTtcbiAgICAgICAgdmFyIHNyY0Jhc2U2NCAgICAgID0gbnVsbDtcbiAgICAgICAgdmFyIF90aGlzICAgICAgICAgID0gdGhpcztcbiAgICAgICAgdmFyIGV2ZW50RmlsZVJlYWR5ID0gJC5FdmVudChcImRyb3BpZnkuZmlsZVJlYWR5XCIpO1xuXG4gICAgICAgIHRoaXMuY2xlYXJFcnJvcnMoKTtcbiAgICAgICAgdGhpcy5zaG93TG9hZGVyKCk7XG4gICAgICAgIHRoaXMuc2V0RmlsZUluZm9ybWF0aW9ucyhmaWxlKTtcbiAgICAgICAgdGhpcy5lcnJvcnNFdmVudC5lcnJvcnMgPSBbXTtcbiAgICAgICAgdGhpcy5jaGVja0ZpbGVTaXplKCk7XG5cdFx0dGhpcy5pc0ZpbGVFeHRlbnNpb25BbGxvd2VkKCk7XG5cbiAgICAgICAgaWYgKHRoaXMuaXNJbWFnZSgpICYmIHRoaXMuZmlsZS5zaXplIDwgdGhpcy5zaXplVG9CeXRlKHRoaXMuc2V0dGluZ3MubWF4RmlsZVNpemVQcmV2aWV3KSkge1xuICAgICAgICAgICAgdGhpcy5pbnB1dC5vbignZHJvcGlmeS5maWxlUmVhZHknLCB0aGlzLm9uRmlsZVJlYWR5KTtcbiAgICAgICAgICAgIHJlYWRlci5yZWFkQXNEYXRhVVJMKGZpbGUpO1xuICAgICAgICAgICAgcmVhZGVyLm9ubG9hZCA9IGZ1bmN0aW9uKF9maWxlKSB7XG4gICAgICAgICAgICAgICAgc3JjQmFzZTY0ID0gX2ZpbGUudGFyZ2V0LnJlc3VsdDtcbiAgICAgICAgICAgICAgICBpbWFnZS5zcmMgPSBfZmlsZS50YXJnZXQucmVzdWx0O1xuICAgICAgICAgICAgICAgIGltYWdlLm9ubG9hZCA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICBfdGhpcy5zZXRGaWxlRGltZW5zaW9ucyh0aGlzLndpZHRoLCB0aGlzLmhlaWdodCk7XG4gICAgICAgICAgICAgICAgICAgIF90aGlzLnZhbGlkYXRlSW1hZ2UoKTtcbiAgICAgICAgICAgICAgICAgICAgX3RoaXMuaW5wdXQudHJpZ2dlcihldmVudEZpbGVSZWFkeSwgW3RydWUsIHNyY0Jhc2U2NF0pO1xuICAgICAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgIH0uYmluZCh0aGlzKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMub25GaWxlUmVhZHkoZmFsc2UpO1xuICAgICAgICB9XG4gICAgfVxufTtcblxuLyoqXG4gKiBPbiBmaWxlIHJlYWR5IHRvIHNob3dcbiAqXG4gKiBAcGFyYW0gIHtFdmVudH0gZXZlbnRcbiAqIEBwYXJhbSAge0Jvb2x9IHByZXZpZXdhYmxlXG4gKiBAcGFyYW0gIHtTdHJpbmd9IHNyY1xuICovXG5Ecm9waWZ5LnByb3RvdHlwZS5vbkZpbGVSZWFkeSA9IGZ1bmN0aW9uKGV2ZW50LCBwcmV2aWV3YWJsZSwgc3JjKVxue1xuICAgIHRoaXMuaW5wdXQub2ZmKCdkcm9waWZ5LmZpbGVSZWFkeScsIHRoaXMub25GaWxlUmVhZHkpO1xuXG4gICAgaWYgKHRoaXMuZXJyb3JzRXZlbnQuZXJyb3JzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICB0aGlzLnNldFByZXZpZXcocHJldmlld2FibGUsIHNyYyk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5pbnB1dC50cmlnZ2VyKHRoaXMuZXJyb3JzRXZlbnQswqBbdGhpc10pO1xuICAgICAgICBmb3IgKHZhciBpID0gdGhpcy5lcnJvcnNFdmVudC5lcnJvcnMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgICAgICAgIHZhciBlcnJvck5hbWVzcGFjZSA9IHRoaXMuZXJyb3JzRXZlbnQuZXJyb3JzW2ldLm5hbWVzcGFjZTtcbiAgICAgICAgICAgIHZhciBlcnJvcktleSA9IGVycm9yTmFtZXNwYWNlLnNwbGl0KCcuJykucG9wKCk7XG4gICAgICAgICAgICB0aGlzLnNob3dFcnJvcihlcnJvcktleSk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodHlwZW9mIHRoaXMuZXJyb3JzQ29udGFpbmVyICE9PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICAgICAgICB0aGlzLmVycm9yc0NvbnRhaW5lci5hZGRDbGFzcygndmlzaWJsZScpO1xuXG4gICAgICAgICAgICB2YXIgZXJyb3JzQ29udGFpbmVyID0gdGhpcy5lcnJvcnNDb250YWluZXI7XG4gICAgICAgICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uKCl7IGVycm9yc0NvbnRhaW5lci5yZW1vdmVDbGFzcygndmlzaWJsZScpOyB9LCB0aGlzLnNldHRpbmdzLmVycm9yVGltZW91dCk7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLndyYXBwZXIuYWRkQ2xhc3MoJ2hhcy1lcnJvcicpO1xuICAgICAgICB0aGlzLnJlc2V0UHJldmlldygpO1xuICAgICAgICB0aGlzLmNsZWFyRWxlbWVudCgpO1xuICAgIH1cbn07XG5cbi8qKlxuICogU2V0IGZpbGUgaW5mb3JtYXRpb25zXG4gKlxuICogQHBhcmFtIHtGaWxlfSBmaWxlXG4gKi9cbkRyb3BpZnkucHJvdG90eXBlLnNldEZpbGVJbmZvcm1hdGlvbnMgPSBmdW5jdGlvbihmaWxlKVxue1xuICAgIHRoaXMuZmlsZS5vYmplY3QgPSBmaWxlO1xuICAgIHRoaXMuZmlsZS5uYW1lICAgPSBmaWxlLm5hbWU7XG4gICAgdGhpcy5maWxlLnNpemUgICA9IGZpbGUuc2l6ZTtcbiAgICB0aGlzLmZpbGUudHlwZSAgID0gZmlsZS50eXBlO1xuICAgIHRoaXMuZmlsZS53aWR0aCAgPSBudWxsO1xuICAgIHRoaXMuZmlsZS5oZWlnaHQgPSBudWxsO1xufTtcblxuLyoqXG4gKiBTZXQgZmlsZSBkaW1lbnNpb25zXG4gKlxuICogQHBhcmFtIHtJbnR9IHdpZHRoXG4gKiBAcGFyYW0ge0ludH0gaGVpZ2h0XG4gKi9cbkRyb3BpZnkucHJvdG90eXBlLnNldEZpbGVEaW1lbnNpb25zID0gZnVuY3Rpb24od2lkdGgsIGhlaWdodClcbntcbiAgICB0aGlzLmZpbGUud2lkdGggID0gd2lkdGg7XG4gICAgdGhpcy5maWxlLmhlaWdodCA9IGhlaWdodDtcbn07XG5cbi8qKlxuICogU2V0IHRoZSBwcmV2aWV3IGFuZCBhbmltYXRlIGl0XG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IHNyY1xuICovXG5Ecm9waWZ5LnByb3RvdHlwZS5zZXRQcmV2aWV3ID0gZnVuY3Rpb24ocHJldmlld2FibGUsIHNyYylcbntcbiAgICB0aGlzLndyYXBwZXIucmVtb3ZlQ2xhc3MoJ2hhcy1lcnJvcicpLmFkZENsYXNzKCdoYXMtcHJldmlldycpO1xuICAgIHRoaXMuZmlsZW5hbWVXcmFwcGVyLmNoaWxkcmVuKCcuZHJvcGlmeS1maWxlbmFtZS1pbm5lcicpLmh0bWwodGhpcy5maWxlLm5hbWUpO1xuICAgIHZhciByZW5kZXIgPSB0aGlzLnByZXZpZXcuY2hpbGRyZW4oJy5kcm9waWZ5LXJlbmRlcicpO1xuXG4gICAgdGhpcy5oaWRlTG9hZGVyKCk7XG5cbiAgICBpZiAocHJldmlld2FibGUgPT09IHRydWUpIHtcbiAgICAgICAgdmFyIGltZ1RhZyA9ICQoJzxpbWcgLz4nKS5hdHRyKCdzcmMnLCBzcmMpO1xuXG4gICAgICAgIGlmICh0aGlzLnNldHRpbmdzLmhlaWdodCkge1xuICAgICAgICAgICAgaW1nVGFnLmNzcyhcIm1heC1oZWlnaHRcIiwgdGhpcy5zZXR0aW5ncy5oZWlnaHQpO1xuICAgICAgICB9XG5cbiAgICAgICAgaW1nVGFnLmFwcGVuZFRvKHJlbmRlcik7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgJCgnPGkgLz4nKS5hdHRyKCdjbGFzcycsICdkcm9waWZ5LWZvbnQtZmlsZScpLmFwcGVuZFRvKHJlbmRlcik7XG4gICAgICAgICQoJzxzcGFuIGNsYXNzPVwiZHJvcGlmeS1leHRlbnNpb25cIiAvPicpLmh0bWwodGhpcy5nZXRGaWxlVHlwZSgpKS5hcHBlbmRUbyhyZW5kZXIpO1xuICAgIH1cbiAgICB0aGlzLnByZXZpZXcuZmFkZUluKCk7XG59O1xuXG4vKipcbiAqIFJlc2V0IHRoZSBwcmV2aWV3XG4gKi9cbkRyb3BpZnkucHJvdG90eXBlLnJlc2V0UHJldmlldyA9IGZ1bmN0aW9uKClcbntcbiAgICB0aGlzLndyYXBwZXIucmVtb3ZlQ2xhc3MoJ2hhcy1wcmV2aWV3Jyk7XG4gICAgdmFyIHJlbmRlciA9IHRoaXMucHJldmlldy5jaGlsZHJlbignLmRyb3BpZnktcmVuZGVyJyk7XG4gICAgcmVuZGVyLmZpbmQoJy5kcm9waWZ5LWV4dGVuc2lvbicpLnJlbW92ZSgpO1xuICAgIHJlbmRlci5maW5kKCdpJykucmVtb3ZlKCk7XG4gICAgcmVuZGVyLmZpbmQoJ2ltZycpLnJlbW92ZSgpO1xuICAgIHRoaXMucHJldmlldy5oaWRlKCk7XG4gICAgdGhpcy5oaWRlTG9hZGVyKCk7XG59O1xuXG4vKipcbiAqIENsZWFuIHRoZSBzcmMgYW5kIGdldCB0aGUgZmlsZW5hbWVcbiAqXG4gKiBAcGFyYW0gIHtTdHJpbmd9IHNyY1xuICpcbiAqIEByZXR1cm4ge1N0cmluZ30gZmlsZW5hbWVcbiAqL1xuRHJvcGlmeS5wcm90b3R5cGUuY2xlYW5GaWxlbmFtZSA9IGZ1bmN0aW9uKHNyYylcbntcbiAgICB2YXIgZmlsZW5hbWUgPSBzcmMuc3BsaXQoJ1xcXFwnKS5wb3AoKTtcbiAgICBpZiAoZmlsZW5hbWUgPT0gc3JjKSB7XG4gICAgICAgIGZpbGVuYW1lID0gc3JjLnNwbGl0KCcvJykucG9wKCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHNyYyAhPT0gXCJcIiA/IGZpbGVuYW1lIDogJyc7XG59O1xuXG4vKipcbiAqIENsZWFyIHRoZSBlbGVtZW50LCBldmVudHMgYXJlIGF2YWlsYWJsZVxuICovXG5Ecm9waWZ5LnByb3RvdHlwZS5jbGVhckVsZW1lbnQgPSBmdW5jdGlvbigpXG57XG4gICAgaWYgKHRoaXMuZXJyb3JzRXZlbnQuZXJyb3JzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICB2YXIgZXZlbnRCZWZvcmUgPSAkLkV2ZW50KFwiZHJvcGlmeS5iZWZvcmVDbGVhclwiKTtcbiAgICAgICAgdGhpcy5pbnB1dC50cmlnZ2VyKGV2ZW50QmVmb3JlLMKgW3RoaXNdKTtcblxuICAgICAgICBpZiAoZXZlbnRCZWZvcmUucmVzdWx0ICE9PSBmYWxzZSkge1xuICAgICAgICAgICAgdGhpcy5yZXNldEZpbGUoKTtcbiAgICAgICAgICAgIHRoaXMuaW5wdXQudmFsKCcnKTtcbiAgICAgICAgICAgIHRoaXMucmVzZXRQcmV2aWV3KCk7XG5cbiAgICAgICAgICAgIHRoaXMuaW5wdXQudHJpZ2dlcigkLkV2ZW50KFwiZHJvcGlmeS5hZnRlckNsZWFyXCIpLMKgW3RoaXNdKTtcbiAgICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMucmVzZXRGaWxlKCk7XG4gICAgICAgIHRoaXMuaW5wdXQudmFsKCcnKTtcbiAgICAgICAgdGhpcy5yZXNldFByZXZpZXcoKTtcbiAgICB9XG59O1xuXG4vKipcbiAqIFJlc2V0IGZpbGUgaW5mb3JtYXRpb25zXG4gKi9cbkRyb3BpZnkucHJvdG90eXBlLnJlc2V0RmlsZSA9IGZ1bmN0aW9uKClcbntcbiAgICB0aGlzLmZpbGUub2JqZWN0ID0gbnVsbDtcbiAgICB0aGlzLmZpbGUubmFtZSAgID0gbnVsbDtcbiAgICB0aGlzLmZpbGUuc2l6ZSAgID0gbnVsbDtcbiAgICB0aGlzLmZpbGUudHlwZSAgID0gbnVsbDtcbiAgICB0aGlzLmZpbGUud2lkdGggID0gbnVsbDtcbiAgICB0aGlzLmZpbGUuaGVpZ2h0ID0gbnVsbDtcbn07XG5cbi8qKlxuICogU2V0IHRoZSBjb250YWluZXIgaGVpZ2h0XG4gKi9cbkRyb3BpZnkucHJvdG90eXBlLnNldENvbnRhaW5lclNpemUgPSBmdW5jdGlvbigpXG57XG4gICAgaWYgKHRoaXMuc2V0dGluZ3MuaGVpZ2h0KSB7XG4gICAgICAgIHRoaXMud3JhcHBlci5oZWlnaHQodGhpcy5zZXR0aW5ncy5oZWlnaHQpO1xuICAgIH1cbn07XG5cbi8qKlxuICogVGVzdCBpZiBpdCdzIHRvdWNoIHNjcmVlblxuICpcbiAqIEByZXR1cm4ge0Jvb2xlYW59XG4gKi9cbkRyb3BpZnkucHJvdG90eXBlLmlzVG91Y2hEZXZpY2UgPSBmdW5jdGlvbigpXG57XG4gICAgcmV0dXJuICgoJ29udG91Y2hzdGFydCcgaW4gd2luZG93KSB8fFxuICAgICAgICAgICAgKG5hdmlnYXRvci5NYXhUb3VjaFBvaW50cyA+IDApIHx8XG4gICAgICAgICAgICAobmF2aWdhdG9yLm1zTWF4VG91Y2hQb2ludHMgPiAwKSk7XG59O1xuXG4vKipcbiAqIEdldCB0aGUgZmlsZSB0eXBlLlxuICpcbiAqIEByZXR1cm4ge1N0cmluZ31cbiAqL1xuRHJvcGlmeS5wcm90b3R5cGUuZ2V0RmlsZVR5cGUgPSBmdW5jdGlvbigpXG57XG4gICAgcmV0dXJuIHRoaXMuZmlsZS5uYW1lLnNwbGl0KCcuJykucG9wKCkudG9Mb3dlckNhc2UoKTtcbn07XG5cbi8qKlxuICogVGVzdCBpZiB0aGUgZmlsZSBpcyBhbiBpbWFnZVxuICpcbiAqIEByZXR1cm4ge0Jvb2xlYW59XG4gKi9cbkRyb3BpZnkucHJvdG90eXBlLmlzSW1hZ2UgPSBmdW5jdGlvbigpXG57XG4gICAgaWYgKHRoaXMuc2V0dGluZ3MuaW1nRmlsZUV4dGVuc2lvbnMuaW5kZXhPZih0aGlzLmdldEZpbGVUeXBlKCkpICE9IFwiLTFcIikge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cbiAgICByZXR1cm4gZmFsc2U7XG59O1xuXG4vKipcbiogVGVzdCBpZiB0aGUgZmlsZSBleHRlbnNpb24gaXMgYWxsb3dlZFxuKlxuKiBAcmV0dXJuIHtCb29sZWFufVxuKi9cbkRyb3BpZnkucHJvdG90eXBlLmlzRmlsZUV4dGVuc2lvbkFsbG93ZWQgPSBmdW5jdGlvbiAoKSB7XG5cblx0aWYgKHRoaXMuc2V0dGluZ3MuYWxsb3dlZEZpbGVFeHRlbnNpb25zLmluZGV4T2YoJyonKSAhPSBcIi0xXCIgfHzCoFxuICAgICAgICB0aGlzLnNldHRpbmdzLmFsbG93ZWRGaWxlRXh0ZW5zaW9ucy5pbmRleE9mKHRoaXMuZ2V0RmlsZVR5cGUoKSkgIT0gXCItMVwiKSB7XG5cdFx0cmV0dXJuIHRydWU7XG5cdH1cblx0dGhpcy5wdXNoRXJyb3IoXCJmaWxlRXh0ZW5zaW9uXCIpO1xuXG5cdHJldHVybiBmYWxzZTtcbn07XG5cbi8qKlxuICogVHJhbnNsYXRlIG1lc3NhZ2VzIGlmIG5lZWRlZC5cbiAqL1xuRHJvcGlmeS5wcm90b3R5cGUudHJhbnNsYXRlTWVzc2FnZXMgPSBmdW5jdGlvbigpXG57XG4gICAgZm9yICh2YXIgbmFtZSBpbiB0aGlzLnNldHRpbmdzLnRwbCkge1xuICAgICAgICBmb3IgKHZhciBrZXkgaW4gdGhpcy5zZXR0aW5ncy5tZXNzYWdlcykge1xuICAgICAgICAgICAgdGhpcy5zZXR0aW5ncy50cGxbbmFtZV0gPSB0aGlzLnNldHRpbmdzLnRwbFtuYW1lXS5yZXBsYWNlKCd7eyAnICsga2V5ICsgJyB9fScsIHRoaXMuc2V0dGluZ3MubWVzc2FnZXNba2V5XSk7XG4gICAgICAgIH1cbiAgICB9XG59O1xuXG4vKipcbiAqIENoZWNrIHRoZSBsaW1pdCBmaWxlc2l6ZS5cbiAqL1xuRHJvcGlmeS5wcm90b3R5cGUuY2hlY2tGaWxlU2l6ZSA9IGZ1bmN0aW9uKClcbntcbiAgICBpZiAodGhpcy5zaXplVG9CeXRlKHRoaXMuc2V0dGluZ3MubWF4RmlsZVNpemUpICE9PSAwICYmIHRoaXMuZmlsZS5zaXplID4gdGhpcy5zaXplVG9CeXRlKHRoaXMuc2V0dGluZ3MubWF4RmlsZVNpemUpKSB7XG4gICAgICAgIHRoaXMucHVzaEVycm9yKFwiZmlsZVNpemVcIik7XG4gICAgfVxufTtcblxuLyoqXG4gKiBDb252ZXJ0IGZpbGVzaXplIHRvIGJ5dGUuXG4gKlxuICogQHJldHVybiB7SW50fSB2YWx1ZVxuICovXG5Ecm9waWZ5LnByb3RvdHlwZS5zaXplVG9CeXRlID0gZnVuY3Rpb24oc2l6ZSlcbntcbiAgICB2YXIgdmFsdWUgPSAwO1xuXG4gICAgaWYgKHNpemUgIT09IDApIHtcbiAgICAgICAgdmFyIHVuaXQgID0gc2l6ZS5zbGljZSgtMSkudG9VcHBlckNhc2UoKSxcbiAgICAgICAgICAgIGtiICAgID0gMTAyNCxcbiAgICAgICAgICAgIG1iICAgID0ga2IgKiAxMDI0LFxuICAgICAgICAgICAgZ2IgICAgPSBtYiAqIDEwMjQ7XG5cbiAgICAgICAgaWYgKHVuaXQgPT09ICdLJykge1xuICAgICAgICAgICAgdmFsdWUgPSBwYXJzZUZsb2F0KHNpemUpICoga2I7XG4gICAgICAgIH0gZWxzZSBpZiAodW5pdCA9PT0gJ00nKSB7XG4gICAgICAgICAgICB2YWx1ZSA9IHBhcnNlRmxvYXQoc2l6ZSkgKiBtYjtcbiAgICAgICAgfSBlbHNlIGlmICh1bml0ID09PSAnRycpIHtcbiAgICAgICAgICAgIHZhbHVlID0gcGFyc2VGbG9hdChzaXplKSAqIGdiO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHZhbHVlO1xufTtcblxuLyoqXG4gKiBWYWxpZGF0ZSBpbWFnZSBkaW1lbnNpb25zIGFuZCBmb3JtYXRcbiAqL1xuRHJvcGlmeS5wcm90b3R5cGUudmFsaWRhdGVJbWFnZSA9IGZ1bmN0aW9uKClcbntcbiAgICBpZiAodGhpcy5zZXR0aW5ncy5taW5XaWR0aCAhPT0gMCAmJiB0aGlzLnNldHRpbmdzLm1pbldpZHRoID49IHRoaXMuZmlsZS53aWR0aCkge1xuICAgICAgICB0aGlzLnB1c2hFcnJvcihcIm1pbldpZHRoXCIpO1xuICAgIH1cblxuICAgIGlmICh0aGlzLnNldHRpbmdzLm1heFdpZHRoICE9PSAwICYmIHRoaXMuc2V0dGluZ3MubWF4V2lkdGggPD0gdGhpcy5maWxlLndpZHRoKSB7XG4gICAgICAgIHRoaXMucHVzaEVycm9yKFwibWF4V2lkdGhcIik7XG4gICAgfVxuXG4gICAgaWYgKHRoaXMuc2V0dGluZ3MubWluSGVpZ2h0ICE9PSAwICYmIHRoaXMuc2V0dGluZ3MubWluSGVpZ2h0ID49IHRoaXMuZmlsZS5oZWlnaHQpIHtcbiAgICAgICAgdGhpcy5wdXNoRXJyb3IoXCJtaW5IZWlnaHRcIik7XG4gICAgfVxuXG4gICAgaWYgKHRoaXMuc2V0dGluZ3MubWF4SGVpZ2h0ICE9PSAwICYmIHRoaXMuc2V0dGluZ3MubWF4SGVpZ2h0IDw9IHRoaXMuZmlsZS5oZWlnaHQpIHtcbiAgICAgICAgdGhpcy5wdXNoRXJyb3IoXCJtYXhIZWlnaHRcIik7XG4gICAgfVxuXG4gICAgaWYgKHRoaXMuc2V0dGluZ3MuYWxsb3dlZEZvcm1hdHMuaW5kZXhPZih0aGlzLmdldEltYWdlRm9ybWF0KCkpID09IFwiLTFcIikge1xuICAgICAgICB0aGlzLnB1c2hFcnJvcihcImltYWdlRm9ybWF0XCIpO1xuICAgIH1cbn07XG5cbi8qKlxuICogR2V0IGltYWdlIGZvcm1hdC5cbiAqXG4gKiBAcmV0dXJuIHtTdHJpbmd9XG4gKi9cbkRyb3BpZnkucHJvdG90eXBlLmdldEltYWdlRm9ybWF0ID0gZnVuY3Rpb24oKVxue1xuICAgIGlmICh0aGlzLmZpbGUud2lkdGggPT0gdGhpcy5maWxlLmhlaWdodCkge1xuICAgICAgICByZXR1cm4gXCJzcXVhcmVcIjtcbiAgICB9XG5cbiAgICBpZiAodGhpcy5maWxlLndpZHRoIDwgdGhpcy5maWxlLmhlaWdodCkge1xuICAgICAgICByZXR1cm4gXCJwb3J0cmFpdFwiO1xuICAgIH1cblxuICAgIGlmICh0aGlzLmZpbGUud2lkdGggPiB0aGlzLmZpbGUuaGVpZ2h0KSB7XG4gICAgICAgIHJldHVybiBcImxhbmRzY2FwZVwiO1xuICAgIH1cbn07XG5cbi8qKlxuKiBQdXNoIGVycm9yXG4qXG4qIEBwYXJhbSB7U3RyaW5nfSBlcnJvcktleVxuKi9cbkRyb3BpZnkucHJvdG90eXBlLnB1c2hFcnJvciA9IGZ1bmN0aW9uKGVycm9yS2V5KSB7XG4gICAgdmFyIGUgPSAkLkV2ZW50KFwiZHJvcGlmeS5lcnJvci5cIiArIGVycm9yS2V5KTtcbiAgICB0aGlzLmVycm9yc0V2ZW50LmVycm9ycy5wdXNoKGUpO1xuICAgIHRoaXMuaW5wdXQudHJpZ2dlcihlLCBbdGhpc10pO1xufTtcblxuLyoqXG4gKiBDbGVhciBlcnJvcnNcbiAqL1xuRHJvcGlmeS5wcm90b3R5cGUuY2xlYXJFcnJvcnMgPSBmdW5jdGlvbigpXG57XG4gICAgaWYgKHR5cGVvZiB0aGlzLmVycm9yc0NvbnRhaW5lciAhPT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgICB0aGlzLmVycm9yc0NvbnRhaW5lci5jaGlsZHJlbigndWwnKS5odG1sKCcnKTtcbiAgICB9XG59O1xuXG4vKipcbiAqIFNob3cgZXJyb3IgaW4gRE9NXG4gKlxuICogQHBhcmFtICB7U3RyaW5nfSBlcnJvcktleVxuICovXG5Ecm9waWZ5LnByb3RvdHlwZS5zaG93RXJyb3IgPSBmdW5jdGlvbihlcnJvcktleSlcbntcbiAgICBpZiAodHlwZW9mIHRoaXMuZXJyb3JzQ29udGFpbmVyICE9PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICAgIHRoaXMuZXJyb3JzQ29udGFpbmVyLmNoaWxkcmVuKCd1bCcpLmFwcGVuZCgnPGxpPicgKyB0aGlzLmdldEVycm9yKGVycm9yS2V5KSArICc8L2xpPicpO1xuICAgIH1cbn07XG5cbi8qKlxuICogR2V0IGVycm9yIG1lc3NhZ2VcbiAqXG4gKiBAcmV0dXJuICB7U3RyaW5nfSBtZXNzYWdlXG4gKi9cbkRyb3BpZnkucHJvdG90eXBlLmdldEVycm9yID0gZnVuY3Rpb24oZXJyb3JLZXkpXG57XG4gICAgdmFyIGVycm9yID0gdGhpcy5zZXR0aW5ncy5lcnJvcltlcnJvcktleV0sXG4gICAgICAgIHZhbHVlID0gJyc7XG5cbiAgICBpZiAoZXJyb3JLZXkgPT09ICdmaWxlU2l6ZScpIHtcbiAgICAgICAgdmFsdWUgPSB0aGlzLnNldHRpbmdzLm1heEZpbGVTaXplO1xuICAgIH0gZWxzZSBpZiAoZXJyb3JLZXkgPT09ICdtaW5XaWR0aCcpIHtcbiAgICAgICAgdmFsdWUgPSB0aGlzLnNldHRpbmdzLm1pbldpZHRoO1xuICAgIH0gZWxzZSBpZiAoZXJyb3JLZXkgPT09ICdtYXhXaWR0aCcpIHtcbiAgICAgICAgdmFsdWUgPSB0aGlzLnNldHRpbmdzLm1heFdpZHRoO1xuICAgIH0gZWxzZSBpZiAoZXJyb3JLZXkgPT09ICdtaW5IZWlnaHQnKSB7XG4gICAgICAgIHZhbHVlID0gdGhpcy5zZXR0aW5ncy5taW5IZWlnaHQ7XG4gICAgfSBlbHNlIGlmIChlcnJvcktleSA9PT0gJ21heEhlaWdodCcpIHtcbiAgICAgICAgdmFsdWUgPSB0aGlzLnNldHRpbmdzLm1heEhlaWdodDtcbiAgICB9IGVsc2UgaWYgKGVycm9yS2V5ID09PSAnaW1hZ2VGb3JtYXQnKSB7XG4gICAgICAgIHZhbHVlID0gdGhpcy5zZXR0aW5ncy5hbGxvd2VkRm9ybWF0cy5qb2luKCcsICcpO1xuICAgIH0gZWxzZSBpZiAoZXJyb3JLZXkgPT09ICdmaWxlRXh0ZW5zaW9uJykge1xuXHRcdHZhbHVlID0gdGhpcy5zZXR0aW5ncy5hbGxvd2VkRmlsZUV4dGVuc2lvbnMuam9pbignLCAnKTtcblx0fVxuXG4gICAgaWYgKHZhbHVlICE9PSAnJykge1xuICAgICAgICByZXR1cm4gZXJyb3IucmVwbGFjZSgne3sgdmFsdWUgfX0nLCB2YWx1ZSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGVycm9yO1xufTtcblxuLyoqXG4gKiBTaG93IHRoZSBsb2FkZXJcbiAqL1xuRHJvcGlmeS5wcm90b3R5cGUuc2hvd0xvYWRlciA9IGZ1bmN0aW9uKClcbntcbiAgICBpZiAodHlwZW9mIHRoaXMubG9hZGVyICE9PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICAgIHRoaXMubG9hZGVyLnNob3coKTtcbiAgICB9XG59O1xuXG4vKipcbiAqIEhpZGUgdGhlIGxvYWRlclxuICovXG5Ecm9waWZ5LnByb3RvdHlwZS5oaWRlTG9hZGVyID0gZnVuY3Rpb24oKVxue1xuICAgIGlmICh0eXBlb2YgdGhpcy5sb2FkZXIgIT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgICAgdGhpcy5sb2FkZXIuaGlkZSgpO1xuICAgIH1cbn07XG5cbi8qKlxuICogRGVzdHJveSBkcm9waWZ5XG4gKi9cbkRyb3BpZnkucHJvdG90eXBlLmRlc3Ryb3kgPSBmdW5jdGlvbigpXG57XG4gICAgdGhpcy5pbnB1dC5zaWJsaW5ncygpLnJlbW92ZSgpO1xuICAgIHRoaXMuaW5wdXQudW53cmFwKCk7XG4gICAgdGhpcy5pc0luaXQgPSBmYWxzZTtcbn07XG5cbi8qKlxuICogSW5pdCBkcm9waWZ5XG4gKi9cbkRyb3BpZnkucHJvdG90eXBlLmluaXQgPSBmdW5jdGlvbigpXG57XG4gICAgdGhpcy5jcmVhdGVFbGVtZW50cygpO1xufTtcblxuLyoqXG4gKiBUZXN0IGlmIGVsZW1lbnQgaXMgaW5pdFxuICovXG5Ecm9waWZ5LnByb3RvdHlwZS5pc0Ryb3BpZmllZCA9IGZ1bmN0aW9uKClcbntcbiAgICByZXR1cm4gdGhpcy5pc0luaXQ7XG59O1xuXG4kLmZuW3BsdWdpbk5hbWVdID0gZnVuY3Rpb24ob3B0aW9ucykge1xuICAgIHRoaXMuZWFjaChmdW5jdGlvbigpIHtcbiAgICAgICAgaWYgKCEkLmRhdGEodGhpcywgcGx1Z2luTmFtZSkpIHtcbiAgICAgICAgICAgICQuZGF0YSh0aGlzLCBwbHVnaW5OYW1lLCBuZXcgRHJvcGlmeSh0aGlzLCBvcHRpb25zKSk7XG4gICAgICAgIH1cbiAgICB9KTtcblxuICAgIHJldHVybiB0aGlzO1xufTtcblxuXG5yZXR1cm4gRHJvcGlmeTtcbn0pKTtcbiJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///a9fb\n")},cf06:function(module,exports,__webpack_require__){eval('/* flatpickr v4.6.2, @license MIT */\n(function (global, factory) {\n     true ? module.exports = factory() :\n    undefined;\n}(this, function () { \'use strict\';\n\n    /*! *****************************************************************************\r\n    Copyright (c) Microsoft Corporation. All rights reserved.\r\n    Licensed under the Apache License, Version 2.0 (the "License"); you may not use\r\n    this file except in compliance with the License. You may obtain a copy of the\r\n    License at http://www.apache.org/licenses/LICENSE-2.0\r\n\r\n    THIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\n    KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED\r\n    WARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,\r\n    MERCHANTABLITY OR NON-INFRINGEMENT.\r\n\r\n    See the Apache Version 2.0 License for specific language governing permissions\r\n    and limitations under the License.\r\n    ***************************************************************************** */\r\n\r\n    var __assign = function() {\r\n        __assign = Object.assign || function __assign(t) {\r\n            for (var s, i = 1, n = arguments.length; i < n; i++) {\r\n                s = arguments[i];\r\n                for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\r\n            }\r\n            return t;\r\n        };\r\n        return __assign.apply(this, arguments);\r\n    };\n\n    var HOOKS = [\n        "onChange",\n        "onClose",\n        "onDayCreate",\n        "onDestroy",\n        "onKeyDown",\n        "onMonthChange",\n        "onOpen",\n        "onParseConfig",\n        "onReady",\n        "onValueUpdate",\n        "onYearChange",\n        "onPreCalendarPosition",\n    ];\n    var defaults = {\n        _disable: [],\n        _enable: [],\n        allowInput: false,\n        altFormat: "F j, Y",\n        altInput: false,\n        altInputClass: "form-control input",\n        animate: typeof window === "object" &&\n            window.navigator.userAgent.indexOf("MSIE") === -1,\n        ariaDateFormat: "F j, Y",\n        clickOpens: true,\n        closeOnSelect: true,\n        conjunction: ", ",\n        dateFormat: "Y-m-d",\n        defaultHour: 12,\n        defaultMinute: 0,\n        defaultSeconds: 0,\n        disable: [],\n        disableMobile: false,\n        enable: [],\n        enableSeconds: false,\n        enableTime: false,\n        errorHandler: function (err) {\n            return typeof console !== "undefined" && console.warn(err);\n        },\n        getWeek: function (givenDate) {\n            var date = new Date(givenDate.getTime());\n            date.setHours(0, 0, 0, 0);\n            // Thursday in current week decides the year.\n            date.setDate(date.getDate() + 3 - ((date.getDay() + 6) % 7));\n            // January 4 is always in week 1.\n            var week1 = new Date(date.getFullYear(), 0, 4);\n            // Adjust to Thursday in week 1 and count number of weeks from date to week1.\n            return (1 +\n                Math.round(((date.getTime() - week1.getTime()) / 86400000 -\n                    3 +\n                    ((week1.getDay() + 6) % 7)) /\n                    7));\n        },\n        hourIncrement: 1,\n        ignoredFocusElements: [],\n        inline: false,\n        locale: "default",\n        minuteIncrement: 5,\n        mode: "single",\n        monthSelectorType: "dropdown",\n        nextArrow: "<svg version=\'1.1\' xmlns=\'http://www.w3.org/2000/svg\' xmlns:xlink=\'http://www.w3.org/1999/xlink\' viewBox=\'0 0 17 17\'><g></g><path d=\'M13.207 8.472l-7.854 7.854-0.707-0.707 7.146-7.146-7.146-7.148 0.707-0.707 7.854 7.854z\' /></svg>",\n        noCalendar: false,\n        now: new Date(),\n        onChange: [],\n        onClose: [],\n        onDayCreate: [],\n        onDestroy: [],\n        onKeyDown: [],\n        onMonthChange: [],\n        onOpen: [],\n        onParseConfig: [],\n        onReady: [],\n        onValueUpdate: [],\n        onYearChange: [],\n        onPreCalendarPosition: [],\n        plugins: [],\n        position: "auto",\n        positionElement: undefined,\n        prevArrow: "<svg version=\'1.1\' xmlns=\'http://www.w3.org/2000/svg\' xmlns:xlink=\'http://www.w3.org/1999/xlink\' viewBox=\'0 0 17 17\'><g></g><path d=\'M5.207 8.471l7.146 7.147-0.707 0.707-7.853-7.854 7.854-7.853 0.707 0.707-7.147 7.146z\' /></svg>",\n        shorthandCurrentMonth: false,\n        showMonths: 1,\n        static: false,\n        time_24hr: false,\n        weekNumbers: false,\n        wrap: false\n    };\n\n    var english = {\n        weekdays: {\n            shorthand: ["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"],\n            longhand: [\n                "Sunday",\n                "Monday",\n                "Tuesday",\n                "Wednesday",\n                "Thursday",\n                "Friday",\n                "Saturday",\n            ]\n        },\n        months: {\n            shorthand: [\n                "Jan",\n                "Feb",\n                "Mar",\n                "Apr",\n                "May",\n                "Jun",\n                "Jul",\n                "Aug",\n                "Sep",\n                "Oct",\n                "Nov",\n                "Dec",\n            ],\n            longhand: [\n                "January",\n                "February",\n                "March",\n                "April",\n                "May",\n                "June",\n                "July",\n                "August",\n                "September",\n                "October",\n                "November",\n                "December",\n            ]\n        },\n        daysInMonth: [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31],\n        firstDayOfWeek: 0,\n        ordinal: function (nth) {\n            var s = nth % 100;\n            if (s > 3 && s < 21)\n                return "th";\n            switch (s % 10) {\n                case 1:\n                    return "st";\n                case 2:\n                    return "nd";\n                case 3:\n                    return "rd";\n                default:\n                    return "th";\n            }\n        },\n        rangeSeparator: " to ",\n        weekAbbreviation: "Wk",\n        scrollTitle: "Scroll to increment",\n        toggleTitle: "Click to toggle",\n        amPM: ["AM", "PM"],\n        yearAriaLabel: "Year",\n        hourAriaLabel: "Hour",\n        minuteAriaLabel: "Minute",\n        time_24hr: false\n    };\n\n    var pad = function (number) { return ("0" + number).slice(-2); };\n    var int = function (bool) { return (bool === true ? 1 : 0); };\n    /* istanbul ignore next */\n    function debounce(func, wait, immediate) {\n        if (immediate === void 0) { immediate = false; }\n        var timeout;\n        return function () {\n            var context = this, args = arguments;\n            timeout !== null && clearTimeout(timeout);\n            timeout = window.setTimeout(function () {\n                timeout = null;\n                if (!immediate)\n                    func.apply(context, args);\n            }, wait);\n            if (immediate && !timeout)\n                func.apply(context, args);\n        };\n    }\n    var arrayify = function (obj) {\n        return obj instanceof Array ? obj : [obj];\n    };\n\n    function toggleClass(elem, className, bool) {\n        if (bool === true)\n            return elem.classList.add(className);\n        elem.classList.remove(className);\n    }\n    function createElement(tag, className, content) {\n        var e = window.document.createElement(tag);\n        className = className || "";\n        content = content || "";\n        e.className = className;\n        if (content !== undefined)\n            e.textContent = content;\n        return e;\n    }\n    function clearNode(node) {\n        while (node.firstChild)\n            node.removeChild(node.firstChild);\n    }\n    function findParent(node, condition) {\n        if (condition(node))\n            return node;\n        else if (node.parentNode)\n            return findParent(node.parentNode, condition);\n        return undefined; // nothing found\n    }\n    function createNumberInput(inputClassName, opts) {\n        var wrapper = createElement("div", "numInputWrapper"), numInput = createElement("input", "numInput " + inputClassName), arrowUp = createElement("span", "arrowUp"), arrowDown = createElement("span", "arrowDown");\n        if (navigator.userAgent.indexOf("MSIE 9.0") === -1) {\n            numInput.type = "number";\n        }\n        else {\n            numInput.type = "text";\n            numInput.pattern = "\\\\d*";\n        }\n        if (opts !== undefined)\n            for (var key in opts)\n                numInput.setAttribute(key, opts[key]);\n        wrapper.appendChild(numInput);\n        wrapper.appendChild(arrowUp);\n        wrapper.appendChild(arrowDown);\n        return wrapper;\n    }\n    function getEventTarget(event) {\n        if (typeof event.composedPath === "function") {\n            var path = event.composedPath();\n            return path[0];\n        }\n        return event.target;\n    }\n\n    var doNothing = function () { return undefined; };\n    var monthToStr = function (monthNumber, shorthand, locale) { return locale.months[shorthand ? "shorthand" : "longhand"][monthNumber]; };\n    var revFormat = {\n        D: doNothing,\n        F: function (dateObj, monthName, locale) {\n            dateObj.setMonth(locale.months.longhand.indexOf(monthName));\n        },\n        G: function (dateObj, hour) {\n            dateObj.setHours(parseFloat(hour));\n        },\n        H: function (dateObj, hour) {\n            dateObj.setHours(parseFloat(hour));\n        },\n        J: function (dateObj, day) {\n            dateObj.setDate(parseFloat(day));\n        },\n        K: function (dateObj, amPM, locale) {\n            dateObj.setHours((dateObj.getHours() % 12) +\n                12 * int(new RegExp(locale.amPM[1], "i").test(amPM)));\n        },\n        M: function (dateObj, shortMonth, locale) {\n            dateObj.setMonth(locale.months.shorthand.indexOf(shortMonth));\n        },\n        S: function (dateObj, seconds) {\n            dateObj.setSeconds(parseFloat(seconds));\n        },\n        U: function (_, unixSeconds) { return new Date(parseFloat(unixSeconds) * 1000); },\n        W: function (dateObj, weekNum, locale) {\n            var weekNumber = parseInt(weekNum);\n            var date = new Date(dateObj.getFullYear(), 0, 2 + (weekNumber - 1) * 7, 0, 0, 0, 0);\n            date.setDate(date.getDate() - date.getDay() + locale.firstDayOfWeek);\n            return date;\n        },\n        Y: function (dateObj, year) {\n            dateObj.setFullYear(parseFloat(year));\n        },\n        Z: function (_, ISODate) { return new Date(ISODate); },\n        d: function (dateObj, day) {\n            dateObj.setDate(parseFloat(day));\n        },\n        h: function (dateObj, hour) {\n            dateObj.setHours(parseFloat(hour));\n        },\n        i: function (dateObj, minutes) {\n            dateObj.setMinutes(parseFloat(minutes));\n        },\n        j: function (dateObj, day) {\n            dateObj.setDate(parseFloat(day));\n        },\n        l: doNothing,\n        m: function (dateObj, month) {\n            dateObj.setMonth(parseFloat(month) - 1);\n        },\n        n: function (dateObj, month) {\n            dateObj.setMonth(parseFloat(month) - 1);\n        },\n        s: function (dateObj, seconds) {\n            dateObj.setSeconds(parseFloat(seconds));\n        },\n        u: function (_, unixMillSeconds) {\n            return new Date(parseFloat(unixMillSeconds));\n        },\n        w: doNothing,\n        y: function (dateObj, year) {\n            dateObj.setFullYear(2000 + parseFloat(year));\n        }\n    };\n    var tokenRegex = {\n        D: "(\\\\w+)",\n        F: "(\\\\w+)",\n        G: "(\\\\d\\\\d|\\\\d)",\n        H: "(\\\\d\\\\d|\\\\d)",\n        J: "(\\\\d\\\\d|\\\\d)\\\\w+",\n        K: "",\n        M: "(\\\\w+)",\n        S: "(\\\\d\\\\d|\\\\d)",\n        U: "(.+)",\n        W: "(\\\\d\\\\d|\\\\d)",\n        Y: "(\\\\d{4})",\n        Z: "(.+)",\n        d: "(\\\\d\\\\d|\\\\d)",\n        h: "(\\\\d\\\\d|\\\\d)",\n        i: "(\\\\d\\\\d|\\\\d)",\n        j: "(\\\\d\\\\d|\\\\d)",\n        l: "(\\\\w+)",\n        m: "(\\\\d\\\\d|\\\\d)",\n        n: "(\\\\d\\\\d|\\\\d)",\n        s: "(\\\\d\\\\d|\\\\d)",\n        u: "(.+)",\n        w: "(\\\\d\\\\d|\\\\d)",\n        y: "(\\\\d{2})"\n    };\n    var formats = {\n        // get the date in UTC\n        Z: function (date) { return date.toISOString(); },\n        // weekday name, short, e.g. Thu\n        D: function (date, locale, options) {\n            return locale.weekdays.shorthand[formats.w(date, locale, options)];\n        },\n        // full month name e.g. January\n        F: function (date, locale, options) {\n            return monthToStr(formats.n(date, locale, options) - 1, false, locale);\n        },\n        // padded hour 1-12\n        G: function (date, locale, options) {\n            return pad(formats.h(date, locale, options));\n        },\n        // hours with leading zero e.g. 03\n        H: function (date) { return pad(date.getHours()); },\n        // day (1-30) with ordinal suffix e.g. 1st, 2nd\n        J: function (date, locale) {\n            return locale.ordinal !== undefined\n                ? date.getDate() + locale.ordinal(date.getDate())\n                : date.getDate();\n        },\n        // AM/PM\n        K: function (date, locale) { return locale.amPM[int(date.getHours() > 11)]; },\n        // shorthand month e.g. Jan, Sep, Oct, etc\n        M: function (date, locale) {\n            return monthToStr(date.getMonth(), true, locale);\n        },\n        // seconds 00-59\n        S: function (date) { return pad(date.getSeconds()); },\n        // unix timestamp\n        U: function (date) { return date.getTime() / 1000; },\n        W: function (date, _, options) {\n            return options.getWeek(date);\n        },\n        // full year e.g. 2016\n        Y: function (date) { return date.getFullYear(); },\n        // day in month, padded (01-30)\n        d: function (date) { return pad(date.getDate()); },\n        // hour from 1-12 (am/pm)\n        h: function (date) { return (date.getHours() % 12 ? date.getHours() % 12 : 12); },\n        // minutes, padded with leading zero e.g. 09\n        i: function (date) { return pad(date.getMinutes()); },\n        // day in month (1-30)\n        j: function (date) { return date.getDate(); },\n        // weekday name, full, e.g. Thursday\n        l: function (date, locale) {\n            return locale.weekdays.longhand[date.getDay()];\n        },\n        // padded month number (01-12)\n        m: function (date) { return pad(date.getMonth() + 1); },\n        // the month number (1-12)\n        n: function (date) { return date.getMonth() + 1; },\n        // seconds 0-59\n        s: function (date) { return date.getSeconds(); },\n        // Unix Milliseconds\n        u: function (date) { return date.getTime(); },\n        // number of the day of the week\n        w: function (date) { return date.getDay(); },\n        // last two digits of year e.g. 16 for 2016\n        y: function (date) { return String(date.getFullYear()).substring(2); }\n    };\n\n    var createDateFormatter = function (_a) {\n        var _b = _a.config, config = _b === void 0 ? defaults : _b, _c = _a.l10n, l10n = _c === void 0 ? english : _c;\n        return function (dateObj, frmt, overrideLocale) {\n            var locale = overrideLocale || l10n;\n            if (config.formatDate !== undefined) {\n                return config.formatDate(dateObj, frmt, locale);\n            }\n            return frmt\n                .split("")\n                .map(function (c, i, arr) {\n                return formats[c] && arr[i - 1] !== "\\\\"\n                    ? formats[c](dateObj, locale, config)\n                    : c !== "\\\\"\n                        ? c\n                        : "";\n            })\n                .join("");\n        };\n    };\n    var createDateParser = function (_a) {\n        var _b = _a.config, config = _b === void 0 ? defaults : _b, _c = _a.l10n, l10n = _c === void 0 ? english : _c;\n        return function (date, givenFormat, timeless, customLocale) {\n            if (date !== 0 && !date)\n                return undefined;\n            var locale = customLocale || l10n;\n            var parsedDate;\n            var dateOrig = date;\n            if (date instanceof Date)\n                parsedDate = new Date(date.getTime());\n            else if (typeof date !== "string" &&\n                date.toFixed !== undefined // timestamp\n            )\n                // create a copy\n                parsedDate = new Date(date);\n            else if (typeof date === "string") {\n                // date string\n                var format = givenFormat || (config || defaults).dateFormat;\n                var datestr = String(date).trim();\n                if (datestr === "today") {\n                    parsedDate = new Date();\n                    timeless = true;\n                }\n                else if (/Z$/.test(datestr) ||\n                    /GMT$/.test(datestr) // datestrings w/ timezone\n                )\n                    parsedDate = new Date(date);\n                else if (config && config.parseDate)\n                    parsedDate = config.parseDate(date, format);\n                else {\n                    parsedDate =\n                        !config || !config.noCalendar\n                            ? new Date(new Date().getFullYear(), 0, 1, 0, 0, 0, 0)\n                            : new Date(new Date().setHours(0, 0, 0, 0));\n                    var matched = void 0, ops = [];\n                    for (var i = 0, matchIndex = 0, regexStr = ""; i < format.length; i++) {\n                        var token_1 = format[i];\n                        var isBackSlash = token_1 === "\\\\";\n                        var escaped = format[i - 1] === "\\\\" || isBackSlash;\n                        if (tokenRegex[token_1] && !escaped) {\n                            regexStr += tokenRegex[token_1];\n                            var match = new RegExp(regexStr).exec(date);\n                            if (match && (matched = true)) {\n                                ops[token_1 !== "Y" ? "push" : "unshift"]({\n                                    fn: revFormat[token_1],\n                                    val: match[++matchIndex]\n                                });\n                            }\n                        }\n                        else if (!isBackSlash)\n                            regexStr += "."; // don\'t really care\n                        ops.forEach(function (_a) {\n                            var fn = _a.fn, val = _a.val;\n                            return (parsedDate = fn(parsedDate, val, locale) || parsedDate);\n                        });\n                    }\n                    parsedDate = matched ? parsedDate : undefined;\n                }\n            }\n            /* istanbul ignore next */\n            if (!(parsedDate instanceof Date && !isNaN(parsedDate.getTime()))) {\n                config.errorHandler(new Error("Invalid date provided: " + dateOrig));\n                return undefined;\n            }\n            if (timeless === true)\n                parsedDate.setHours(0, 0, 0, 0);\n            return parsedDate;\n        };\n    };\n    /**\n     * Compute the difference in dates, measured in ms\n     */\n    function compareDates(date1, date2, timeless) {\n        if (timeless === void 0) { timeless = true; }\n        if (timeless !== false) {\n            return (new Date(date1.getTime()).setHours(0, 0, 0, 0) -\n                new Date(date2.getTime()).setHours(0, 0, 0, 0));\n        }\n        return date1.getTime() - date2.getTime();\n    }\n    var isBetween = function (ts, ts1, ts2) {\n        return ts > Math.min(ts1, ts2) && ts < Math.max(ts1, ts2);\n    };\n    var duration = {\n        DAY: 86400000\n    };\n\n    if (typeof Object.assign !== "function") {\n        Object.assign = function (target) {\n            var args = [];\n            for (var _i = 1; _i < arguments.length; _i++) {\n                args[_i - 1] = arguments[_i];\n            }\n            if (!target) {\n                throw TypeError("Cannot convert undefined or null to object");\n            }\n            var _loop_1 = function (source) {\n                if (source) {\n                    Object.keys(source).forEach(function (key) { return (target[key] = source[key]); });\n                }\n            };\n            for (var _a = 0, args_1 = args; _a < args_1.length; _a++) {\n                var source = args_1[_a];\n                _loop_1(source);\n            }\n            return target;\n        };\n    }\n\n    var DEBOUNCED_CHANGE_MS = 300;\n    function FlatpickrInstance(element, instanceConfig) {\n        var self = {\n            config: __assign({}, defaults, flatpickr.defaultConfig),\n            l10n: english\n        };\n        self.parseDate = createDateParser({ config: self.config, l10n: self.l10n });\n        self._handlers = [];\n        self.pluginElements = [];\n        self.loadedPlugins = [];\n        self._bind = bind;\n        self._setHoursFromDate = setHoursFromDate;\n        self._positionCalendar = positionCalendar;\n        self.changeMonth = changeMonth;\n        self.changeYear = changeYear;\n        self.clear = clear;\n        self.close = close;\n        self._createElement = createElement;\n        self.destroy = destroy;\n        self.isEnabled = isEnabled;\n        self.jumpToDate = jumpToDate;\n        self.open = open;\n        self.redraw = redraw;\n        self.set = set;\n        self.setDate = setDate;\n        self.toggle = toggle;\n        function setupHelperFunctions() {\n            self.utils = {\n                getDaysInMonth: function (month, yr) {\n                    if (month === void 0) { month = self.currentMonth; }\n                    if (yr === void 0) { yr = self.currentYear; }\n                    if (month === 1 && ((yr % 4 === 0 && yr % 100 !== 0) || yr % 400 === 0))\n                        return 29;\n                    return self.l10n.daysInMonth[month];\n                }\n            };\n        }\n        function init() {\n            self.element = self.input = element;\n            self.isOpen = false;\n            parseConfig();\n            setupLocale();\n            setupInputs();\n            setupDates();\n            setupHelperFunctions();\n            if (!self.isMobile)\n                build();\n            bindEvents();\n            if (self.selectedDates.length || self.config.noCalendar) {\n                if (self.config.enableTime) {\n                    setHoursFromDate(self.config.noCalendar\n                        ? self.latestSelectedDateObj || self.config.minDate\n                        : undefined);\n                }\n                updateValue(false);\n            }\n            setCalendarWidth();\n            self.showTimeInput =\n                self.selectedDates.length > 0 || self.config.noCalendar;\n            var isSafari = /^((?!chrome|android).)*safari/i.test(navigator.userAgent);\n            /* TODO: investigate this further\n        \n              Currently, there is weird positioning behavior in safari causing pages\n              to scroll up. https://github.com/chmln/flatpickr/issues/563\n        \n              However, most browsers are not Safari and positioning is expensive when used\n              in scale. https://github.com/chmln/flatpickr/issues/1096\n            */\n            if (!self.isMobile && isSafari) {\n                positionCalendar();\n            }\n            triggerEvent("onReady");\n        }\n        function bindToInstance(fn) {\n            return fn.bind(self);\n        }\n        function setCalendarWidth() {\n            var config = self.config;\n            if (config.weekNumbers === false && config.showMonths === 1)\n                return;\n            else if (config.noCalendar !== true) {\n                window.requestAnimationFrame(function () {\n                    if (self.calendarContainer !== undefined) {\n                        self.calendarContainer.style.visibility = "hidden";\n                        self.calendarContainer.style.display = "block";\n                    }\n                    if (self.daysContainer !== undefined) {\n                        var daysWidth = (self.days.offsetWidth + 1) * config.showMonths;\n                        self.daysContainer.style.width = daysWidth + "px";\n                        self.calendarContainer.style.width =\n                            daysWidth +\n                                (self.weekWrapper !== undefined\n                                    ? self.weekWrapper.offsetWidth\n                                    : 0) +\n                                "px";\n                        self.calendarContainer.style.removeProperty("visibility");\n                        self.calendarContainer.style.removeProperty("display");\n                    }\n                });\n            }\n        }\n        /**\n         * The handler for all events targeting the time inputs\n         */\n        function updateTime(e) {\n            if (self.selectedDates.length === 0) {\n                setDefaultTime();\n            }\n            if (e !== undefined && e.type !== "blur") {\n                timeWrapper(e);\n            }\n            var prevValue = self._input.value;\n            setHoursFromInputs();\n            updateValue();\n            if (self._input.value !== prevValue) {\n                self._debouncedChange();\n            }\n        }\n        function ampm2military(hour, amPM) {\n            return (hour % 12) + 12 * int(amPM === self.l10n.amPM[1]);\n        }\n        function military2ampm(hour) {\n            switch (hour % 24) {\n                case 0:\n                case 12:\n                    return 12;\n                default:\n                    return hour % 12;\n            }\n        }\n        /**\n         * Syncs the selected date object time with user\'s time input\n         */\n        function setHoursFromInputs() {\n            if (self.hourElement === undefined || self.minuteElement === undefined)\n                return;\n            var hours = (parseInt(self.hourElement.value.slice(-2), 10) || 0) % 24, minutes = (parseInt(self.minuteElement.value, 10) || 0) % 60, seconds = self.secondElement !== undefined\n                ? (parseInt(self.secondElement.value, 10) || 0) % 60\n                : 0;\n            if (self.amPM !== undefined) {\n                hours = ampm2military(hours, self.amPM.textContent);\n            }\n            var limitMinHours = self.config.minTime !== undefined ||\n                (self.config.minDate &&\n                    self.minDateHasTime &&\n                    self.latestSelectedDateObj &&\n                    compareDates(self.latestSelectedDateObj, self.config.minDate, true) ===\n                        0);\n            var limitMaxHours = self.config.maxTime !== undefined ||\n                (self.config.maxDate &&\n                    self.maxDateHasTime &&\n                    self.latestSelectedDateObj &&\n                    compareDates(self.latestSelectedDateObj, self.config.maxDate, true) ===\n                        0);\n            if (limitMaxHours) {\n                var maxTime = self.config.maxTime !== undefined\n                    ? self.config.maxTime\n                    : self.config.maxDate;\n                hours = Math.min(hours, maxTime.getHours());\n                if (hours === maxTime.getHours())\n                    minutes = Math.min(minutes, maxTime.getMinutes());\n                if (minutes === maxTime.getMinutes())\n                    seconds = Math.min(seconds, maxTime.getSeconds());\n            }\n            if (limitMinHours) {\n                var minTime = self.config.minTime !== undefined\n                    ? self.config.minTime\n                    : self.config.minDate;\n                hours = Math.max(hours, minTime.getHours());\n                if (hours === minTime.getHours())\n                    minutes = Math.max(minutes, minTime.getMinutes());\n                if (minutes === minTime.getMinutes())\n                    seconds = Math.max(seconds, minTime.getSeconds());\n            }\n            setHours(hours, minutes, seconds);\n        }\n        /**\n         * Syncs time input values with a date\n         */\n        function setHoursFromDate(dateObj) {\n            var date = dateObj || self.latestSelectedDateObj;\n            if (date)\n                setHours(date.getHours(), date.getMinutes(), date.getSeconds());\n        }\n        function setDefaultHours() {\n            var hours = self.config.defaultHour;\n            var minutes = self.config.defaultMinute;\n            var seconds = self.config.defaultSeconds;\n            if (self.config.minDate !== undefined) {\n                var minHr = self.config.minDate.getHours();\n                var minMinutes = self.config.minDate.getMinutes();\n                hours = Math.max(hours, minHr);\n                if (hours === minHr)\n                    minutes = Math.max(minMinutes, minutes);\n                if (hours === minHr && minutes === minMinutes)\n                    seconds = self.config.minDate.getSeconds();\n            }\n            if (self.config.maxDate !== undefined) {\n                var maxHr = self.config.maxDate.getHours();\n                var maxMinutes = self.config.maxDate.getMinutes();\n                hours = Math.min(hours, maxHr);\n                if (hours === maxHr)\n                    minutes = Math.min(maxMinutes, minutes);\n                if (hours === maxHr && minutes === maxMinutes)\n                    seconds = self.config.maxDate.getSeconds();\n            }\n            setHours(hours, minutes, seconds);\n        }\n        /**\n         * Sets the hours, minutes, and optionally seconds\n         * of the latest selected date object and the\n         * corresponding time inputs\n         * @param {Number} hours the hour. whether its military\n         *                 or am-pm gets inferred from config\n         * @param {Number} minutes the minutes\n         * @param {Number} seconds the seconds (optional)\n         */\n        function setHours(hours, minutes, seconds) {\n            if (self.latestSelectedDateObj !== undefined) {\n                self.latestSelectedDateObj.setHours(hours % 24, minutes, seconds || 0, 0);\n            }\n            if (!self.hourElement || !self.minuteElement || self.isMobile)\n                return;\n            self.hourElement.value = pad(!self.config.time_24hr\n                ? ((12 + hours) % 12) + 12 * int(hours % 12 === 0)\n                : hours);\n            self.minuteElement.value = pad(minutes);\n            if (self.amPM !== undefined)\n                self.amPM.textContent = self.l10n.amPM[int(hours >= 12)];\n            if (self.secondElement !== undefined)\n                self.secondElement.value = pad(seconds);\n        }\n        /**\n         * Handles the year input and incrementing events\n         * @param {Event} event the keyup or increment event\n         */\n        function onYearInput(event) {\n            var year = parseInt(event.target.value) + (event.delta || 0);\n            if (year / 1000 > 1 ||\n                (event.key === "Enter" && !/[^\\d]/.test(year.toString()))) {\n                changeYear(year);\n            }\n        }\n        /**\n         * Essentially addEventListener + tracking\n         * @param {Element} element the element to addEventListener to\n         * @param {String} event the event name\n         * @param {Function} handler the event handler\n         */\n        function bind(element, event, handler, options) {\n            if (event instanceof Array)\n                return event.forEach(function (ev) { return bind(element, ev, handler, options); });\n            if (element instanceof Array)\n                return element.forEach(function (el) { return bind(el, event, handler, options); });\n            element.addEventListener(event, handler, options);\n            self._handlers.push({\n                element: element,\n                event: event,\n                handler: handler,\n                options: options\n            });\n        }\n        /**\n         * A mousedown handler which mimics click.\n         * Minimizes latency, since we don\'t need to wait for mouseup in most cases.\n         * Also, avoids handling right clicks.\n         *\n         * @param {Function} handler the event handler\n         */\n        function onClick(handler) {\n            return function (evt) {\n                evt.which === 1 && handler(evt);\n            };\n        }\n        function triggerChange() {\n            triggerEvent("onChange");\n        }\n        /**\n         * Adds all the necessary event listeners\n         */\n        function bindEvents() {\n            if (self.config.wrap) {\n                ["open", "close", "toggle", "clear"].forEach(function (evt) {\n                    Array.prototype.forEach.call(self.element.querySelectorAll("[data-" + evt + "]"), function (el) {\n                        return bind(el, "click", self[evt]);\n                    });\n                });\n            }\n            if (self.isMobile) {\n                setupMobile();\n                return;\n            }\n            var debouncedResize = debounce(onResize, 50);\n            self._debouncedChange = debounce(triggerChange, DEBOUNCED_CHANGE_MS);\n            if (self.daysContainer && !/iPhone|iPad|iPod/i.test(navigator.userAgent))\n                bind(self.daysContainer, "mouseover", function (e) {\n                    if (self.config.mode === "range")\n                        onMouseOver(e.target);\n                });\n            bind(window.document.body, "keydown", onKeyDown);\n            if (!self.config.inline && !self.config.static)\n                bind(window, "resize", debouncedResize);\n            if (window.ontouchstart !== undefined)\n                bind(window.document, "touchstart", documentClick);\n            else\n                bind(window.document, "mousedown", onClick(documentClick));\n            bind(window.document, "focus", documentClick, { capture: true });\n            if (self.config.clickOpens === true) {\n                bind(self._input, "focus", self.open);\n                bind(self._input, "mousedown", onClick(self.open));\n            }\n            if (self.daysContainer !== undefined) {\n                bind(self.monthNav, "mousedown", onClick(onMonthNavClick));\n                bind(self.monthNav, ["keyup", "increment"], onYearInput);\n                bind(self.daysContainer, "mousedown", onClick(selectDate));\n            }\n            if (self.timeContainer !== undefined &&\n                self.minuteElement !== undefined &&\n                self.hourElement !== undefined) {\n                var selText = function (e) {\n                    return e.target.select();\n                };\n                bind(self.timeContainer, ["increment"], updateTime);\n                bind(self.timeContainer, "blur", updateTime, { capture: true });\n                bind(self.timeContainer, "mousedown", onClick(timeIncrement));\n                bind([self.hourElement, self.minuteElement], ["focus", "click"], selText);\n                if (self.secondElement !== undefined)\n                    bind(self.secondElement, "focus", function () { return self.secondElement && self.secondElement.select(); });\n                if (self.amPM !== undefined) {\n                    bind(self.amPM, "mousedown", onClick(function (e) {\n                        updateTime(e);\n                        triggerChange();\n                    }));\n                }\n            }\n        }\n        /**\n         * Set the calendar view to a particular date.\n         * @param {Date} jumpDate the date to set the view to\n         * @param {boolean} triggerChange if change events should be triggered\n         */\n        function jumpToDate(jumpDate, triggerChange) {\n            var jumpTo = jumpDate !== undefined\n                ? self.parseDate(jumpDate)\n                : self.latestSelectedDateObj ||\n                    (self.config.minDate && self.config.minDate > self.now\n                        ? self.config.minDate\n                        : self.config.maxDate && self.config.maxDate < self.now\n                            ? self.config.maxDate\n                            : self.now);\n            var oldYear = self.currentYear;\n            var oldMonth = self.currentMonth;\n            try {\n                if (jumpTo !== undefined) {\n                    self.currentYear = jumpTo.getFullYear();\n                    self.currentMonth = jumpTo.getMonth();\n                }\n            }\n            catch (e) {\n                /* istanbul ignore next */\n                e.message = "Invalid date supplied: " + jumpTo;\n                self.config.errorHandler(e);\n            }\n            if (triggerChange && self.currentYear !== oldYear) {\n                triggerEvent("onYearChange");\n                buildMonthSwitch();\n            }\n            if (triggerChange &&\n                (self.currentYear !== oldYear || self.currentMonth !== oldMonth)) {\n                triggerEvent("onMonthChange");\n            }\n            self.redraw();\n        }\n        /**\n         * The up/down arrow handler for time inputs\n         * @param {Event} e the click event\n         */\n        function timeIncrement(e) {\n            if (~e.target.className.indexOf("arrow"))\n                incrementNumInput(e, e.target.classList.contains("arrowUp") ? 1 : -1);\n        }\n        /**\n         * Increments/decrements the value of input associ-\n         * ated with the up/down arrow by dispatching an\n         * "increment" event on the input.\n         *\n         * @param {Event} e the click event\n         * @param {Number} delta the diff (usually 1 or -1)\n         * @param {Element} inputElem the input element\n         */\n        function incrementNumInput(e, delta, inputElem) {\n            var target = e && e.target;\n            var input = inputElem ||\n                (target && target.parentNode && target.parentNode.firstChild);\n            var event = createEvent("increment");\n            event.delta = delta;\n            input && input.dispatchEvent(event);\n        }\n        function build() {\n            var fragment = window.document.createDocumentFragment();\n            self.calendarContainer = createElement("div", "flatpickr-calendar");\n            self.calendarContainer.tabIndex = -1;\n            if (!self.config.noCalendar) {\n                fragment.appendChild(buildMonthNav());\n                self.innerContainer = createElement("div", "flatpickr-innerContainer");\n                if (self.config.weekNumbers) {\n                    var _a = buildWeeks(), weekWrapper = _a.weekWrapper, weekNumbers = _a.weekNumbers;\n                    self.innerContainer.appendChild(weekWrapper);\n                    self.weekNumbers = weekNumbers;\n                    self.weekWrapper = weekWrapper;\n                }\n                self.rContainer = createElement("div", "flatpickr-rContainer");\n                self.rContainer.appendChild(buildWeekdays());\n                if (!self.daysContainer) {\n                    self.daysContainer = createElement("div", "flatpickr-days");\n                    self.daysContainer.tabIndex = -1;\n                }\n                buildDays();\n                self.rContainer.appendChild(self.daysContainer);\n                self.innerContainer.appendChild(self.rContainer);\n                fragment.appendChild(self.innerContainer);\n            }\n            if (self.config.enableTime) {\n                fragment.appendChild(buildTime());\n            }\n            toggleClass(self.calendarContainer, "rangeMode", self.config.mode === "range");\n            toggleClass(self.calendarContainer, "animate", self.config.animate === true);\n            toggleClass(self.calendarContainer, "multiMonth", self.config.showMonths > 1);\n            self.calendarContainer.appendChild(fragment);\n            var customAppend = self.config.appendTo !== undefined &&\n                self.config.appendTo.nodeType !== undefined;\n            if (self.config.inline || self.config.static) {\n                self.calendarContainer.classList.add(self.config.inline ? "inline" : "static");\n                if (self.config.inline) {\n                    if (!customAppend && self.element.parentNode)\n                        self.element.parentNode.insertBefore(self.calendarContainer, self._input.nextSibling);\n                    else if (self.config.appendTo !== undefined)\n                        self.config.appendTo.appendChild(self.calendarContainer);\n                }\n                if (self.config.static) {\n                    var wrapper = createElement("div", "flatpickr-wrapper");\n                    if (self.element.parentNode)\n                        self.element.parentNode.insertBefore(wrapper, self.element);\n                    wrapper.appendChild(self.element);\n                    if (self.altInput)\n                        wrapper.appendChild(self.altInput);\n                    wrapper.appendChild(self.calendarContainer);\n                }\n            }\n            if (!self.config.static && !self.config.inline)\n                (self.config.appendTo !== undefined\n                    ? self.config.appendTo\n                    : window.document.body).appendChild(self.calendarContainer);\n        }\n        function createDay(className, date, dayNumber, i) {\n            var dateIsEnabled = isEnabled(date, true), dayElement = createElement("span", "flatpickr-day " + className, date.getDate().toString());\n            dayElement.dateObj = date;\n            dayElement.$i = i;\n            dayElement.setAttribute("aria-label", self.formatDate(date, self.config.ariaDateFormat));\n            if (className.indexOf("hidden") === -1 &&\n                compareDates(date, self.now) === 0) {\n                self.todayDateElem = dayElement;\n                dayElement.classList.add("today");\n                dayElement.setAttribute("aria-current", "date");\n            }\n            if (dateIsEnabled) {\n                dayElement.tabIndex = -1;\n                if (isDateSelected(date)) {\n                    dayElement.classList.add("selected");\n                    self.selectedDateElem = dayElement;\n                    if (self.config.mode === "range") {\n                        toggleClass(dayElement, "startRange", self.selectedDates[0] &&\n                            compareDates(date, self.selectedDates[0], true) === 0);\n                        toggleClass(dayElement, "endRange", self.selectedDates[1] &&\n                            compareDates(date, self.selectedDates[1], true) === 0);\n                        if (className === "nextMonthDay")\n                            dayElement.classList.add("inRange");\n                    }\n                }\n            }\n            else {\n                dayElement.classList.add("flatpickr-disabled");\n            }\n            if (self.config.mode === "range") {\n                if (isDateInRange(date) && !isDateSelected(date))\n                    dayElement.classList.add("inRange");\n            }\n            if (self.weekNumbers &&\n                self.config.showMonths === 1 &&\n                className !== "prevMonthDay" &&\n                dayNumber % 7 === 1) {\n                self.weekNumbers.insertAdjacentHTML("beforeend", "<span class=\'flatpickr-day\'>" + self.config.getWeek(date) + "</span>");\n            }\n            triggerEvent("onDayCreate", dayElement);\n            return dayElement;\n        }\n        function focusOnDayElem(targetNode) {\n            targetNode.focus();\n            if (self.config.mode === "range")\n                onMouseOver(targetNode);\n        }\n        function getFirstAvailableDay(delta) {\n            var startMonth = delta > 0 ? 0 : self.config.showMonths - 1;\n            var endMonth = delta > 0 ? self.config.showMonths : -1;\n            for (var m = startMonth; m != endMonth; m += delta) {\n                var month = self.daysContainer.children[m];\n                var startIndex = delta > 0 ? 0 : month.children.length - 1;\n                var endIndex = delta > 0 ? month.children.length : -1;\n                for (var i = startIndex; i != endIndex; i += delta) {\n                    var c = month.children[i];\n                    if (c.className.indexOf("hidden") === -1 && isEnabled(c.dateObj))\n                        return c;\n                }\n            }\n            return undefined;\n        }\n        function getNextAvailableDay(current, delta) {\n            var givenMonth = current.className.indexOf("Month") === -1\n                ? current.dateObj.getMonth()\n                : self.currentMonth;\n            var endMonth = delta > 0 ? self.config.showMonths : -1;\n            var loopDelta = delta > 0 ? 1 : -1;\n            for (var m = givenMonth - self.currentMonth; m != endMonth; m += loopDelta) {\n                var month = self.daysContainer.children[m];\n                var startIndex = givenMonth - self.currentMonth === m\n                    ? current.$i + delta\n                    : delta < 0\n                        ? month.children.length - 1\n                        : 0;\n                var numMonthDays = month.children.length;\n                for (var i = startIndex; i >= 0 && i < numMonthDays && i != (delta > 0 ? numMonthDays : -1); i += loopDelta) {\n                    var c = month.children[i];\n                    if (c.className.indexOf("hidden") === -1 &&\n                        isEnabled(c.dateObj) &&\n                        Math.abs(current.$i - i) >= Math.abs(delta))\n                        return focusOnDayElem(c);\n                }\n            }\n            self.changeMonth(loopDelta);\n            focusOnDay(getFirstAvailableDay(loopDelta), 0);\n            return undefined;\n        }\n        function focusOnDay(current, offset) {\n            var dayFocused = isInView(document.activeElement || document.body);\n            var startElem = current !== undefined\n                ? current\n                : dayFocused\n                    ? document.activeElement\n                    : self.selectedDateElem !== undefined && isInView(self.selectedDateElem)\n                        ? self.selectedDateElem\n                        : self.todayDateElem !== undefined && isInView(self.todayDateElem)\n                            ? self.todayDateElem\n                            : getFirstAvailableDay(offset > 0 ? 1 : -1);\n            if (startElem === undefined)\n                return self._input.focus();\n            if (!dayFocused)\n                return focusOnDayElem(startElem);\n            getNextAvailableDay(startElem, offset);\n        }\n        function buildMonthDays(year, month) {\n            var firstOfMonth = (new Date(year, month, 1).getDay() - self.l10n.firstDayOfWeek + 7) % 7;\n            var prevMonthDays = self.utils.getDaysInMonth((month - 1 + 12) % 12);\n            var daysInMonth = self.utils.getDaysInMonth(month), days = window.document.createDocumentFragment(), isMultiMonth = self.config.showMonths > 1, prevMonthDayClass = isMultiMonth ? "prevMonthDay hidden" : "prevMonthDay", nextMonthDayClass = isMultiMonth ? "nextMonthDay hidden" : "nextMonthDay";\n            var dayNumber = prevMonthDays + 1 - firstOfMonth, dayIndex = 0;\n            // prepend days from the ending of previous month\n            for (; dayNumber <= prevMonthDays; dayNumber++, dayIndex++) {\n                days.appendChild(createDay(prevMonthDayClass, new Date(year, month - 1, dayNumber), dayNumber, dayIndex));\n            }\n            // Start at 1 since there is no 0th day\n            for (dayNumber = 1; dayNumber <= daysInMonth; dayNumber++, dayIndex++) {\n                days.appendChild(createDay("", new Date(year, month, dayNumber), dayNumber, dayIndex));\n            }\n            // append days from the next month\n            for (var dayNum = daysInMonth + 1; dayNum <= 42 - firstOfMonth &&\n                (self.config.showMonths === 1 || dayIndex % 7 !== 0); dayNum++, dayIndex++) {\n                days.appendChild(createDay(nextMonthDayClass, new Date(year, month + 1, dayNum % daysInMonth), dayNum, dayIndex));\n            }\n            //updateNavigationCurrentMonth();\n            var dayContainer = createElement("div", "dayContainer");\n            dayContainer.appendChild(days);\n            return dayContainer;\n        }\n        function buildDays() {\n            if (self.daysContainer === undefined) {\n                return;\n            }\n            clearNode(self.daysContainer);\n            // TODO: week numbers for each month\n            if (self.weekNumbers)\n                clearNode(self.weekNumbers);\n            var frag = document.createDocumentFragment();\n            for (var i = 0; i < self.config.showMonths; i++) {\n                var d = new Date(self.currentYear, self.currentMonth, 1);\n                d.setMonth(self.currentMonth + i);\n                frag.appendChild(buildMonthDays(d.getFullYear(), d.getMonth()));\n            }\n            self.daysContainer.appendChild(frag);\n            self.days = self.daysContainer.firstChild;\n            if (self.config.mode === "range" && self.selectedDates.length === 1) {\n                onMouseOver();\n            }\n        }\n        function buildMonthSwitch() {\n            if (self.config.showMonths > 1 ||\n                self.config.monthSelectorType !== "dropdown")\n                return;\n            var shouldBuildMonth = function (month) {\n                if (self.config.minDate !== undefined &&\n                    self.currentYear === self.config.minDate.getFullYear() &&\n                    month < self.config.minDate.getMonth()) {\n                    return false;\n                }\n                return !(self.config.maxDate !== undefined &&\n                    self.currentYear === self.config.maxDate.getFullYear() &&\n                    month > self.config.maxDate.getMonth());\n            };\n            self.monthsDropdownContainer.tabIndex = -1;\n            self.monthsDropdownContainer.innerHTML = "";\n            for (var i = 0; i < 12; i++) {\n                if (!shouldBuildMonth(i))\n                    continue;\n                var month = createElement("option", "flatpickr-monthDropdown-month");\n                month.value = new Date(self.currentYear, i).getMonth().toString();\n                month.textContent = monthToStr(i, self.config.shorthandCurrentMonth, self.l10n);\n                month.tabIndex = -1;\n                if (self.currentMonth === i) {\n                    month.selected = true;\n                }\n                self.monthsDropdownContainer.appendChild(month);\n            }\n        }\n        function buildMonth() {\n            var container = createElement("div", "flatpickr-month");\n            var monthNavFragment = window.document.createDocumentFragment();\n            var monthElement;\n            if (self.config.showMonths > 1 ||\n                self.config.monthSelectorType === "static") {\n                monthElement = createElement("span", "cur-month");\n            }\n            else {\n                self.monthsDropdownContainer = createElement("select", "flatpickr-monthDropdown-months");\n                bind(self.monthsDropdownContainer, "change", function (e) {\n                    var target = e.target;\n                    var selectedMonth = parseInt(target.value, 10);\n                    self.changeMonth(selectedMonth - self.currentMonth);\n                    triggerEvent("onMonthChange");\n                });\n                buildMonthSwitch();\n                monthElement = self.monthsDropdownContainer;\n            }\n            var yearInput = createNumberInput("cur-year", { tabindex: "-1" });\n            var yearElement = yearInput.getElementsByTagName("input")[0];\n            yearElement.setAttribute("aria-label", self.l10n.yearAriaLabel);\n            if (self.config.minDate) {\n                yearElement.setAttribute("min", self.config.minDate.getFullYear().toString());\n            }\n            if (self.config.maxDate) {\n                yearElement.setAttribute("max", self.config.maxDate.getFullYear().toString());\n                yearElement.disabled =\n                    !!self.config.minDate &&\n                        self.config.minDate.getFullYear() === self.config.maxDate.getFullYear();\n            }\n            var currentMonth = createElement("div", "flatpickr-current-month");\n            currentMonth.appendChild(monthElement);\n            currentMonth.appendChild(yearInput);\n            monthNavFragment.appendChild(currentMonth);\n            container.appendChild(monthNavFragment);\n            return {\n                container: container,\n                yearElement: yearElement,\n                monthElement: monthElement\n            };\n        }\n        function buildMonths() {\n            clearNode(self.monthNav);\n            self.monthNav.appendChild(self.prevMonthNav);\n            if (self.config.showMonths) {\n                self.yearElements = [];\n                self.monthElements = [];\n            }\n            for (var m = self.config.showMonths; m--;) {\n                var month = buildMonth();\n                self.yearElements.push(month.yearElement);\n                self.monthElements.push(month.monthElement);\n                self.monthNav.appendChild(month.container);\n            }\n            self.monthNav.appendChild(self.nextMonthNav);\n        }\n        function buildMonthNav() {\n            self.monthNav = createElement("div", "flatpickr-months");\n            self.yearElements = [];\n            self.monthElements = [];\n            self.prevMonthNav = createElement("span", "flatpickr-prev-month");\n            self.prevMonthNav.innerHTML = self.config.prevArrow;\n            self.nextMonthNav = createElement("span", "flatpickr-next-month");\n            self.nextMonthNav.innerHTML = self.config.nextArrow;\n            buildMonths();\n            Object.defineProperty(self, "_hidePrevMonthArrow", {\n                get: function () { return self.__hidePrevMonthArrow; },\n                set: function (bool) {\n                    if (self.__hidePrevMonthArrow !== bool) {\n                        toggleClass(self.prevMonthNav, "flatpickr-disabled", bool);\n                        self.__hidePrevMonthArrow = bool;\n                    }\n                }\n            });\n            Object.defineProperty(self, "_hideNextMonthArrow", {\n                get: function () { return self.__hideNextMonthArrow; },\n                set: function (bool) {\n                    if (self.__hideNextMonthArrow !== bool) {\n                        toggleClass(self.nextMonthNav, "flatpickr-disabled", bool);\n                        self.__hideNextMonthArrow = bool;\n                    }\n                }\n            });\n            self.currentYearElement = self.yearElements[0];\n            updateNavigationCurrentMonth();\n            return self.monthNav;\n        }\n        function buildTime() {\n            self.calendarContainer.classList.add("hasTime");\n            if (self.config.noCalendar)\n                self.calendarContainer.classList.add("noCalendar");\n            self.timeContainer = createElement("div", "flatpickr-time");\n            self.timeContainer.tabIndex = -1;\n            var separator = createElement("span", "flatpickr-time-separator", ":");\n            var hourInput = createNumberInput("flatpickr-hour", {\n                "aria-label": self.l10n.hourAriaLabel\n            });\n            self.hourElement = hourInput.getElementsByTagName("input")[0];\n            var minuteInput = createNumberInput("flatpickr-minute", {\n                "aria-label": self.l10n.minuteAriaLabel\n            });\n            self.minuteElement = minuteInput.getElementsByTagName("input")[0];\n            self.hourElement.tabIndex = self.minuteElement.tabIndex = -1;\n            self.hourElement.value = pad(self.latestSelectedDateObj\n                ? self.latestSelectedDateObj.getHours()\n                : self.config.time_24hr\n                    ? self.config.defaultHour\n                    : military2ampm(self.config.defaultHour));\n            self.minuteElement.value = pad(self.latestSelectedDateObj\n                ? self.latestSelectedDateObj.getMinutes()\n                : self.config.defaultMinute);\n            self.hourElement.setAttribute("step", self.config.hourIncrement.toString());\n            self.minuteElement.setAttribute("step", self.config.minuteIncrement.toString());\n            self.hourElement.setAttribute("min", self.config.time_24hr ? "0" : "1");\n            self.hourElement.setAttribute("max", self.config.time_24hr ? "23" : "12");\n            self.minuteElement.setAttribute("min", "0");\n            self.minuteElement.setAttribute("max", "59");\n            self.timeContainer.appendChild(hourInput);\n            self.timeContainer.appendChild(separator);\n            self.timeContainer.appendChild(minuteInput);\n            if (self.config.time_24hr)\n                self.timeContainer.classList.add("time24hr");\n            if (self.config.enableSeconds) {\n                self.timeContainer.classList.add("hasSeconds");\n                var secondInput = createNumberInput("flatpickr-second");\n                self.secondElement = secondInput.getElementsByTagName("input")[0];\n                self.secondElement.value = pad(self.latestSelectedDateObj\n                    ? self.latestSelectedDateObj.getSeconds()\n                    : self.config.defaultSeconds);\n                self.secondElement.setAttribute("step", self.minuteElement.getAttribute("step"));\n                self.secondElement.setAttribute("min", "0");\n                self.secondElement.setAttribute("max", "59");\n                self.timeContainer.appendChild(createElement("span", "flatpickr-time-separator", ":"));\n                self.timeContainer.appendChild(secondInput);\n            }\n            if (!self.config.time_24hr) {\n                // add self.amPM if appropriate\n                self.amPM = createElement("span", "flatpickr-am-pm", self.l10n.amPM[int((self.latestSelectedDateObj\n                    ? self.hourElement.value\n                    : self.config.defaultHour) > 11)]);\n                self.amPM.title = self.l10n.toggleTitle;\n                self.amPM.tabIndex = -1;\n                self.timeContainer.appendChild(self.amPM);\n            }\n            return self.timeContainer;\n        }\n        function buildWeekdays() {\n            if (!self.weekdayContainer)\n                self.weekdayContainer = createElement("div", "flatpickr-weekdays");\n            else\n                clearNode(self.weekdayContainer);\n            for (var i = self.config.showMonths; i--;) {\n                var container = createElement("div", "flatpickr-weekdaycontainer");\n                self.weekdayContainer.appendChild(container);\n            }\n            updateWeekdays();\n            return self.weekdayContainer;\n        }\n        function updateWeekdays() {\n            var firstDayOfWeek = self.l10n.firstDayOfWeek;\n            var weekdays = self.l10n.weekdays.shorthand.slice();\n            if (firstDayOfWeek > 0 && firstDayOfWeek < weekdays.length) {\n                weekdays = weekdays.splice(firstDayOfWeek, weekdays.length).concat(weekdays.splice(0, firstDayOfWeek));\n            }\n            for (var i = self.config.showMonths; i--;) {\n                self.weekdayContainer.children[i].innerHTML = "\\n      <span class=\'flatpickr-weekday\'>\\n        " + weekdays.join("</span><span class=\'flatpickr-weekday\'>") + "\\n      </span>\\n      ";\n            }\n        }\n        /* istanbul ignore next */\n        function buildWeeks() {\n            self.calendarContainer.classList.add("hasWeeks");\n            var weekWrapper = createElement("div", "flatpickr-weekwrapper");\n            weekWrapper.appendChild(createElement("span", "flatpickr-weekday", self.l10n.weekAbbreviation));\n            var weekNumbers = createElement("div", "flatpickr-weeks");\n            weekWrapper.appendChild(weekNumbers);\n            return {\n                weekWrapper: weekWrapper,\n                weekNumbers: weekNumbers\n            };\n        }\n        function changeMonth(value, isOffset) {\n            if (isOffset === void 0) { isOffset = true; }\n            var delta = isOffset ? value : value - self.currentMonth;\n            if ((delta < 0 && self._hidePrevMonthArrow === true) ||\n                (delta > 0 && self._hideNextMonthArrow === true))\n                return;\n            self.currentMonth += delta;\n            if (self.currentMonth < 0 || self.currentMonth > 11) {\n                self.currentYear += self.currentMonth > 11 ? 1 : -1;\n                self.currentMonth = (self.currentMonth + 12) % 12;\n                triggerEvent("onYearChange");\n                buildMonthSwitch();\n            }\n            buildDays();\n            triggerEvent("onMonthChange");\n            updateNavigationCurrentMonth();\n        }\n        function clear(triggerChangeEvent, toInitial) {\n            if (triggerChangeEvent === void 0) { triggerChangeEvent = true; }\n            if (toInitial === void 0) { toInitial = true; }\n            self.input.value = "";\n            if (self.altInput !== undefined)\n                self.altInput.value = "";\n            if (self.mobileInput !== undefined)\n                self.mobileInput.value = "";\n            self.selectedDates = [];\n            self.latestSelectedDateObj = undefined;\n            if (toInitial === true) {\n                self.currentYear = self._initialDate.getFullYear();\n                self.currentMonth = self._initialDate.getMonth();\n            }\n            self.showTimeInput = false;\n            if (self.config.enableTime === true) {\n                setDefaultHours();\n            }\n            self.redraw();\n            if (triggerChangeEvent)\n                // triggerChangeEvent is true (default) or an Event\n                triggerEvent("onChange");\n        }\n        function close() {\n            self.isOpen = false;\n            if (!self.isMobile) {\n                if (self.calendarContainer !== undefined) {\n                    self.calendarContainer.classList.remove("open");\n                }\n                if (self._input !== undefined) {\n                    self._input.classList.remove("active");\n                }\n            }\n            triggerEvent("onClose");\n        }\n        function destroy() {\n            if (self.config !== undefined)\n                triggerEvent("onDestroy");\n            for (var i = self._handlers.length; i--;) {\n                var h = self._handlers[i];\n                h.element.removeEventListener(h.event, h.handler, h.options);\n            }\n            self._handlers = [];\n            if (self.mobileInput) {\n                if (self.mobileInput.parentNode)\n                    self.mobileInput.parentNode.removeChild(self.mobileInput);\n                self.mobileInput = undefined;\n            }\n            else if (self.calendarContainer && self.calendarContainer.parentNode) {\n                if (self.config.static && self.calendarContainer.parentNode) {\n                    var wrapper = self.calendarContainer.parentNode;\n                    wrapper.lastChild && wrapper.removeChild(wrapper.lastChild);\n                    if (wrapper.parentNode) {\n                        while (wrapper.firstChild)\n                            wrapper.parentNode.insertBefore(wrapper.firstChild, wrapper);\n                        wrapper.parentNode.removeChild(wrapper);\n                    }\n                }\n                else\n                    self.calendarContainer.parentNode.removeChild(self.calendarContainer);\n            }\n            if (self.altInput) {\n                self.input.type = "text";\n                if (self.altInput.parentNode)\n                    self.altInput.parentNode.removeChild(self.altInput);\n                delete self.altInput;\n            }\n            if (self.input) {\n                self.input.type = self.input._type;\n                self.input.classList.remove("flatpickr-input");\n                self.input.removeAttribute("readonly");\n                self.input.value = "";\n            }\n            [\n                "_showTimeInput",\n                "latestSelectedDateObj",\n                "_hideNextMonthArrow",\n                "_hidePrevMonthArrow",\n                "__hideNextMonthArrow",\n                "__hidePrevMonthArrow",\n                "isMobile",\n                "isOpen",\n                "selectedDateElem",\n                "minDateHasTime",\n                "maxDateHasTime",\n                "days",\n                "daysContainer",\n                "_input",\n                "_positionElement",\n                "innerContainer",\n                "rContainer",\n                "monthNav",\n                "todayDateElem",\n                "calendarContainer",\n                "weekdayContainer",\n                "prevMonthNav",\n                "nextMonthNav",\n                "monthsDropdownContainer",\n                "currentMonthElement",\n                "currentYearElement",\n                "navigationCurrentMonth",\n                "selectedDateElem",\n                "config",\n            ].forEach(function (k) {\n                try {\n                    delete self[k];\n                }\n                catch (_) { }\n            });\n        }\n        function isCalendarElem(elem) {\n            if (self.config.appendTo && self.config.appendTo.contains(elem))\n                return true;\n            return self.calendarContainer.contains(elem);\n        }\n        function documentClick(e) {\n            if (self.isOpen && !self.config.inline) {\n                var eventTarget_1 = getEventTarget(e);\n                var isCalendarElement = isCalendarElem(eventTarget_1);\n                var isInput = eventTarget_1 === self.input ||\n                    eventTarget_1 === self.altInput ||\n                    self.element.contains(eventTarget_1) ||\n                    // web components\n                    // e.path is not present in all browsers. circumventing typechecks\n                    (e.path &&\n                        e.path.indexOf &&\n                        (~e.path.indexOf(self.input) ||\n                            ~e.path.indexOf(self.altInput)));\n                var lostFocus = e.type === "blur"\n                    ? isInput &&\n                        e.relatedTarget &&\n                        !isCalendarElem(e.relatedTarget)\n                    : !isInput &&\n                        !isCalendarElement &&\n                        !isCalendarElem(e.relatedTarget);\n                var isIgnored = !self.config.ignoredFocusElements.some(function (elem) {\n                    return elem.contains(eventTarget_1);\n                });\n                if (lostFocus && isIgnored) {\n                    self.close();\n                    if (self.config.mode === "range" && self.selectedDates.length === 1) {\n                        self.clear(false);\n                        self.redraw();\n                    }\n                }\n            }\n        }\n        function changeYear(newYear) {\n            if (!newYear ||\n                (self.config.minDate && newYear < self.config.minDate.getFullYear()) ||\n                (self.config.maxDate && newYear > self.config.maxDate.getFullYear()))\n                return;\n            var newYearNum = newYear, isNewYear = self.currentYear !== newYearNum;\n            self.currentYear = newYearNum || self.currentYear;\n            if (self.config.maxDate &&\n                self.currentYear === self.config.maxDate.getFullYear()) {\n                self.currentMonth = Math.min(self.config.maxDate.getMonth(), self.currentMonth);\n            }\n            else if (self.config.minDate &&\n                self.currentYear === self.config.minDate.getFullYear()) {\n                self.currentMonth = Math.max(self.config.minDate.getMonth(), self.currentMonth);\n            }\n            if (isNewYear) {\n                self.redraw();\n                triggerEvent("onYearChange");\n                buildMonthSwitch();\n            }\n        }\n        function isEnabled(date, timeless) {\n            if (timeless === void 0) { timeless = true; }\n            var dateToCheck = self.parseDate(date, undefined, timeless); // timeless\n            if ((self.config.minDate &&\n                dateToCheck &&\n                compareDates(dateToCheck, self.config.minDate, timeless !== undefined ? timeless : !self.minDateHasTime) < 0) ||\n                (self.config.maxDate &&\n                    dateToCheck &&\n                    compareDates(dateToCheck, self.config.maxDate, timeless !== undefined ? timeless : !self.maxDateHasTime) > 0))\n                return false;\n            if (self.config.enable.length === 0 && self.config.disable.length === 0)\n                return true;\n            if (dateToCheck === undefined)\n                return false;\n            var bool = self.config.enable.length > 0, array = bool ? self.config.enable : self.config.disable;\n            for (var i = 0, d = void 0; i < array.length; i++) {\n                d = array[i];\n                if (typeof d === "function" &&\n                    d(dateToCheck) // disabled by function\n                )\n                    return bool;\n                else if (d instanceof Date &&\n                    dateToCheck !== undefined &&\n                    d.getTime() === dateToCheck.getTime())\n                    // disabled by date\n                    return bool;\n                else if (typeof d === "string" && dateToCheck !== undefined) {\n                    // disabled by date string\n                    var parsed = self.parseDate(d, undefined, true);\n                    return parsed && parsed.getTime() === dateToCheck.getTime()\n                        ? bool\n                        : !bool;\n                }\n                else if (\n                // disabled by range\n                typeof d === "object" &&\n                    dateToCheck !== undefined &&\n                    d.from &&\n                    d.to &&\n                    dateToCheck.getTime() >= d.from.getTime() &&\n                    dateToCheck.getTime() <= d.to.getTime())\n                    return bool;\n            }\n            return !bool;\n        }\n        function isInView(elem) {\n            if (self.daysContainer !== undefined)\n                return (elem.className.indexOf("hidden") === -1 &&\n                    self.daysContainer.contains(elem));\n            return false;\n        }\n        function onKeyDown(e) {\n            // e.key                      e.keyCode\n            // "Backspace"                        8\n            // "Tab"                              9\n            // "Enter"                           13\n            // "Escape"     (IE "Esc")           27\n            // "ArrowLeft"  (IE "Left")          37\n            // "ArrowUp"    (IE "Up")            38\n            // "ArrowRight" (IE "Right")         39\n            // "ArrowDown"  (IE "Down")          40\n            // "Delete"     (IE "Del")           46\n            var isInput = e.target === self._input;\n            var allowInput = self.config.allowInput;\n            var allowKeydown = self.isOpen && (!allowInput || !isInput);\n            var allowInlineKeydown = self.config.inline && isInput && !allowInput;\n            if (e.keyCode === 13 && isInput) {\n                if (allowInput) {\n                    self.setDate(self._input.value, true, e.target === self.altInput\n                        ? self.config.altFormat\n                        : self.config.dateFormat);\n                    return e.target.blur();\n                }\n                else {\n                    self.open();\n                }\n            }\n            else if (isCalendarElem(e.target) ||\n                allowKeydown ||\n                allowInlineKeydown) {\n                var isTimeObj = !!self.timeContainer &&\n                    self.timeContainer.contains(e.target);\n                switch (e.keyCode) {\n                    case 13:\n                        if (isTimeObj) {\n                            e.preventDefault();\n                            updateTime();\n                            focusAndClose();\n                        }\n                        else\n                            selectDate(e);\n                        break;\n                    case 27: // escape\n                        e.preventDefault();\n                        focusAndClose();\n                        break;\n                    case 8:\n                    case 46:\n                        if (isInput && !self.config.allowInput) {\n                            e.preventDefault();\n                            self.clear();\n                        }\n                        break;\n                    case 37:\n                    case 39:\n                        if (!isTimeObj && !isInput) {\n                            e.preventDefault();\n                            if (self.daysContainer !== undefined &&\n                                (allowInput === false ||\n                                    (document.activeElement && isInView(document.activeElement)))) {\n                                var delta_1 = e.keyCode === 39 ? 1 : -1;\n                                if (!e.ctrlKey)\n                                    focusOnDay(undefined, delta_1);\n                                else {\n                                    e.stopPropagation();\n                                    changeMonth(delta_1);\n                                    focusOnDay(getFirstAvailableDay(1), 0);\n                                }\n                            }\n                        }\n                        else if (self.hourElement)\n                            self.hourElement.focus();\n                        break;\n                    case 38:\n                    case 40:\n                        e.preventDefault();\n                        var delta = e.keyCode === 40 ? 1 : -1;\n                        if ((self.daysContainer && e.target.$i !== undefined) ||\n                            e.target === self.input) {\n                            if (e.ctrlKey) {\n                                e.stopPropagation();\n                                changeYear(self.currentYear - delta);\n                                focusOnDay(getFirstAvailableDay(1), 0);\n                            }\n                            else if (!isTimeObj)\n                                focusOnDay(undefined, delta * 7);\n                        }\n                        else if (e.target === self.currentYearElement) {\n                            changeYear(self.currentYear - delta);\n                        }\n                        else if (self.config.enableTime) {\n                            if (!isTimeObj && self.hourElement)\n                                self.hourElement.focus();\n                            updateTime(e);\n                            self._debouncedChange();\n                        }\n                        break;\n                    case 9:\n                        if (isTimeObj) {\n                            var elems = [\n                                self.hourElement,\n                                self.minuteElement,\n                                self.secondElement,\n                                self.amPM,\n                            ]\n                                .concat(self.pluginElements)\n                                .filter(function (x) { return x; });\n                            var i = elems.indexOf(e.target);\n                            if (i !== -1) {\n                                var target = elems[i + (e.shiftKey ? -1 : 1)];\n                                e.preventDefault();\n                                (target || self._input).focus();\n                            }\n                        }\n                        else if (!self.config.noCalendar &&\n                            self.daysContainer &&\n                            self.daysContainer.contains(e.target) &&\n                            e.shiftKey) {\n                            e.preventDefault();\n                            self._input.focus();\n                        }\n                        break;\n                    default:\n                        break;\n                }\n            }\n            if (self.amPM !== undefined && e.target === self.amPM) {\n                switch (e.key) {\n                    case self.l10n.amPM[0].charAt(0):\n                    case self.l10n.amPM[0].charAt(0).toLowerCase():\n                        self.amPM.textContent = self.l10n.amPM[0];\n                        setHoursFromInputs();\n                        updateValue();\n                        break;\n                    case self.l10n.amPM[1].charAt(0):\n                    case self.l10n.amPM[1].charAt(0).toLowerCase():\n                        self.amPM.textContent = self.l10n.amPM[1];\n                        setHoursFromInputs();\n                        updateValue();\n                        break;\n                }\n            }\n            if (isInput || isCalendarElem(e.target)) {\n                triggerEvent("onKeyDown", e);\n            }\n        }\n        function onMouseOver(elem) {\n            if (self.selectedDates.length !== 1 ||\n                (elem &&\n                    (!elem.classList.contains("flatpickr-day") ||\n                        elem.classList.contains("flatpickr-disabled"))))\n                return;\n            var hoverDate = elem\n                ? elem.dateObj.getTime()\n                : self.days.firstElementChild.dateObj.getTime(), initialDate = self.parseDate(self.selectedDates[0], undefined, true).getTime(), rangeStartDate = Math.min(hoverDate, self.selectedDates[0].getTime()), rangeEndDate = Math.max(hoverDate, self.selectedDates[0].getTime());\n            var containsDisabled = false;\n            var minRange = 0, maxRange = 0;\n            for (var t = rangeStartDate; t < rangeEndDate; t += duration.DAY) {\n                if (!isEnabled(new Date(t), true)) {\n                    containsDisabled =\n                        containsDisabled || (t > rangeStartDate && t < rangeEndDate);\n                    if (t < initialDate && (!minRange || t > minRange))\n                        minRange = t;\n                    else if (t > initialDate && (!maxRange || t < maxRange))\n                        maxRange = t;\n                }\n            }\n            for (var m = 0; m < self.config.showMonths; m++) {\n                var month = self.daysContainer.children[m];\n                var _loop_1 = function (i, l) {\n                    var dayElem = month.children[i], date = dayElem.dateObj;\n                    var timestamp = date.getTime();\n                    var outOfRange = (minRange > 0 && timestamp < minRange) ||\n                        (maxRange > 0 && timestamp > maxRange);\n                    if (outOfRange) {\n                        dayElem.classList.add("notAllowed");\n                        ["inRange", "startRange", "endRange"].forEach(function (c) {\n                            dayElem.classList.remove(c);\n                        });\n                        return "continue";\n                    }\n                    else if (containsDisabled && !outOfRange)\n                        return "continue";\n                    ["startRange", "inRange", "endRange", "notAllowed"].forEach(function (c) {\n                        dayElem.classList.remove(c);\n                    });\n                    if (elem !== undefined) {\n                        elem.classList.add(hoverDate <= self.selectedDates[0].getTime()\n                            ? "startRange"\n                            : "endRange");\n                        if (initialDate < hoverDate && timestamp === initialDate)\n                            dayElem.classList.add("startRange");\n                        else if (initialDate > hoverDate && timestamp === initialDate)\n                            dayElem.classList.add("endRange");\n                        if (timestamp >= minRange &&\n                            (maxRange === 0 || timestamp <= maxRange) &&\n                            isBetween(timestamp, initialDate, hoverDate))\n                            dayElem.classList.add("inRange");\n                    }\n                };\n                for (var i = 0, l = month.children.length; i < l; i++) {\n                    _loop_1(i, l);\n                }\n            }\n        }\n        function onResize() {\n            if (self.isOpen && !self.config.static && !self.config.inline)\n                positionCalendar();\n        }\n        function setDefaultTime() {\n            self.setDate(self.config.minDate !== undefined\n                ? new Date(self.config.minDate.getTime())\n                : new Date(), true);\n            setDefaultHours();\n            updateValue();\n        }\n        function open(e, positionElement) {\n            if (positionElement === void 0) { positionElement = self._positionElement; }\n            if (self.isMobile === true) {\n                if (e) {\n                    e.preventDefault();\n                    e.target && e.target.blur();\n                }\n                if (self.mobileInput !== undefined) {\n                    self.mobileInput.focus();\n                    self.mobileInput.click();\n                }\n                triggerEvent("onOpen");\n                return;\n            }\n            if (self._input.disabled || self.config.inline)\n                return;\n            var wasOpen = self.isOpen;\n            self.isOpen = true;\n            if (!wasOpen) {\n                self.calendarContainer.classList.add("open");\n                self._input.classList.add("active");\n                triggerEvent("onOpen");\n                positionCalendar(positionElement);\n            }\n            if (self.config.enableTime === true && self.config.noCalendar === true) {\n                if (self.selectedDates.length === 0) {\n                    setDefaultTime();\n                }\n                if (self.config.allowInput === false &&\n                    (e === undefined ||\n                        !self.timeContainer.contains(e.relatedTarget))) {\n                    setTimeout(function () { return self.hourElement.select(); }, 50);\n                }\n            }\n        }\n        function minMaxDateSetter(type) {\n            return function (date) {\n                var dateObj = (self.config["_" + type + "Date"] = self.parseDate(date, self.config.dateFormat));\n                var inverseDateObj = self.config["_" + (type === "min" ? "max" : "min") + "Date"];\n                if (dateObj !== undefined) {\n                    self[type === "min" ? "minDateHasTime" : "maxDateHasTime"] =\n                        dateObj.getHours() > 0 ||\n                            dateObj.getMinutes() > 0 ||\n                            dateObj.getSeconds() > 0;\n                }\n                if (self.selectedDates) {\n                    self.selectedDates = self.selectedDates.filter(function (d) { return isEnabled(d); });\n                    if (!self.selectedDates.length && type === "min")\n                        setHoursFromDate(dateObj);\n                    updateValue();\n                }\n                if (self.daysContainer) {\n                    redraw();\n                    if (dateObj !== undefined)\n                        self.currentYearElement[type] = dateObj.getFullYear().toString();\n                    else\n                        self.currentYearElement.removeAttribute(type);\n                    self.currentYearElement.disabled =\n                        !!inverseDateObj &&\n                            dateObj !== undefined &&\n                            inverseDateObj.getFullYear() === dateObj.getFullYear();\n                }\n            };\n        }\n        function parseConfig() {\n            var boolOpts = [\n                "wrap",\n                "weekNumbers",\n                "allowInput",\n                "clickOpens",\n                "time_24hr",\n                "enableTime",\n                "noCalendar",\n                "altInput",\n                "shorthandCurrentMonth",\n                "inline",\n                "static",\n                "enableSeconds",\n                "disableMobile",\n            ];\n            var userConfig = __assign({}, instanceConfig, JSON.parse(JSON.stringify(element.dataset || {})));\n            var formats = {};\n            self.config.parseDate = userConfig.parseDate;\n            self.config.formatDate = userConfig.formatDate;\n            Object.defineProperty(self.config, "enable", {\n                get: function () { return self.config._enable; },\n                set: function (dates) {\n                    self.config._enable = parseDateRules(dates);\n                }\n            });\n            Object.defineProperty(self.config, "disable", {\n                get: function () { return self.config._disable; },\n                set: function (dates) {\n                    self.config._disable = parseDateRules(dates);\n                }\n            });\n            var timeMode = userConfig.mode === "time";\n            if (!userConfig.dateFormat && (userConfig.enableTime || timeMode)) {\n                var defaultDateFormat = flatpickr.defaultConfig.dateFormat || defaults.dateFormat;\n                formats.dateFormat =\n                    userConfig.noCalendar || timeMode\n                        ? "H:i" + (userConfig.enableSeconds ? ":S" : "")\n                        : defaultDateFormat + " H:i" + (userConfig.enableSeconds ? ":S" : "");\n            }\n            if (userConfig.altInput &&\n                (userConfig.enableTime || timeMode) &&\n                !userConfig.altFormat) {\n                var defaultAltFormat = flatpickr.defaultConfig.altFormat || defaults.altFormat;\n                formats.altFormat =\n                    userConfig.noCalendar || timeMode\n                        ? "h:i" + (userConfig.enableSeconds ? ":S K" : " K")\n                        : defaultAltFormat + (" h:i" + (userConfig.enableSeconds ? ":S" : "") + " K");\n            }\n            if (!userConfig.altInputClass) {\n                self.config.altInputClass =\n                    self.input.className + " " + self.config.altInputClass;\n            }\n            Object.defineProperty(self.config, "minDate", {\n                get: function () { return self.config._minDate; },\n                set: minMaxDateSetter("min")\n            });\n            Object.defineProperty(self.config, "maxDate", {\n                get: function () { return self.config._maxDate; },\n                set: minMaxDateSetter("max")\n            });\n            var minMaxTimeSetter = function (type) { return function (val) {\n                self.config[type === "min" ? "_minTime" : "_maxTime"] = self.parseDate(val, "H:i");\n            }; };\n            Object.defineProperty(self.config, "minTime", {\n                get: function () { return self.config._minTime; },\n                set: minMaxTimeSetter("min")\n            });\n            Object.defineProperty(self.config, "maxTime", {\n                get: function () { return self.config._maxTime; },\n                set: minMaxTimeSetter("max")\n            });\n            if (userConfig.mode === "time") {\n                self.config.noCalendar = true;\n                self.config.enableTime = true;\n            }\n            Object.assign(self.config, formats, userConfig);\n            for (var i = 0; i < boolOpts.length; i++)\n                self.config[boolOpts[i]] =\n                    self.config[boolOpts[i]] === true ||\n                        self.config[boolOpts[i]] === "true";\n            HOOKS.filter(function (hook) { return self.config[hook] !== undefined; }).forEach(function (hook) {\n                self.config[hook] = arrayify(self.config[hook] || []).map(bindToInstance);\n            });\n            self.isMobile =\n                !self.config.disableMobile &&\n                    !self.config.inline &&\n                    self.config.mode === "single" &&\n                    !self.config.disable.length &&\n                    !self.config.enable.length &&\n                    !self.config.weekNumbers &&\n                    /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);\n            for (var i = 0; i < self.config.plugins.length; i++) {\n                var pluginConf = self.config.plugins[i](self) || {};\n                for (var key in pluginConf) {\n                    if (HOOKS.indexOf(key) > -1) {\n                        self.config[key] = arrayify(pluginConf[key])\n                            .map(bindToInstance)\n                            .concat(self.config[key]);\n                    }\n                    else if (typeof userConfig[key] === "undefined")\n                        self.config[key] = pluginConf[key];\n                }\n            }\n            triggerEvent("onParseConfig");\n        }\n        function setupLocale() {\n            if (typeof self.config.locale !== "object" &&\n                typeof flatpickr.l10ns[self.config.locale] === "undefined")\n                self.config.errorHandler(new Error("flatpickr: invalid locale " + self.config.locale));\n            self.l10n = __assign({}, flatpickr.l10ns["default"], (typeof self.config.locale === "object"\n                ? self.config.locale\n                : self.config.locale !== "default"\n                    ? flatpickr.l10ns[self.config.locale]\n                    : undefined));\n            tokenRegex.K = "(" + self.l10n.amPM[0] + "|" + self.l10n.amPM[1] + "|" + self.l10n.amPM[0].toLowerCase() + "|" + self.l10n.amPM[1].toLowerCase() + ")";\n            var userConfig = __assign({}, instanceConfig, JSON.parse(JSON.stringify(element.dataset || {})));\n            if (userConfig.time_24hr === undefined &&\n                flatpickr.defaultConfig.time_24hr === undefined) {\n                self.config.time_24hr = self.l10n.time_24hr;\n            }\n            self.formatDate = createDateFormatter(self);\n            self.parseDate = createDateParser({ config: self.config, l10n: self.l10n });\n        }\n        function positionCalendar(customPositionElement) {\n            if (self.calendarContainer === undefined)\n                return;\n            triggerEvent("onPreCalendarPosition");\n            var positionElement = customPositionElement || self._positionElement;\n            var calendarHeight = Array.prototype.reduce.call(self.calendarContainer.children, (function (acc, child) { return acc + child.offsetHeight; }), 0), calendarWidth = self.calendarContainer.offsetWidth, configPos = self.config.position.split(" "), configPosVertical = configPos[0], configPosHorizontal = configPos.length > 1 ? configPos[1] : null, inputBounds = positionElement.getBoundingClientRect(), distanceFromBottom = window.innerHeight - inputBounds.bottom, showOnTop = configPosVertical === "above" ||\n                (configPosVertical !== "below" &&\n                    distanceFromBottom < calendarHeight &&\n                    inputBounds.top > calendarHeight);\n            var top = window.pageYOffset +\n                inputBounds.top +\n                (!showOnTop ? positionElement.offsetHeight + 2 : -calendarHeight - 2);\n            toggleClass(self.calendarContainer, "arrowTop", !showOnTop);\n            toggleClass(self.calendarContainer, "arrowBottom", showOnTop);\n            if (self.config.inline)\n                return;\n            var left = window.pageXOffset +\n                inputBounds.left -\n                (configPosHorizontal != null && configPosHorizontal === "center"\n                    ? (calendarWidth - inputBounds.width) / 2\n                    : 0);\n            var right = window.document.body.offsetWidth - inputBounds.right;\n            var rightMost = left + calendarWidth > window.document.body.offsetWidth;\n            var centerMost = right + calendarWidth > window.document.body.offsetWidth;\n            toggleClass(self.calendarContainer, "rightMost", rightMost);\n            if (self.config.static)\n                return;\n            self.calendarContainer.style.top = top + "px";\n            if (!rightMost) {\n                self.calendarContainer.style.left = left + "px";\n                self.calendarContainer.style.right = "auto";\n            }\n            else if (!centerMost) {\n                self.calendarContainer.style.left = "auto";\n                self.calendarContainer.style.right = right + "px";\n            }\n            else {\n                var doc = document.styleSheets[0];\n                // some testing environments don\'t have css support\n                if (doc === undefined)\n                    return;\n                var bodyWidth = window.document.body.offsetWidth;\n                var centerLeft = Math.max(0, bodyWidth / 2 - calendarWidth / 2);\n                var centerBefore = ".flatpickr-calendar.centerMost:before";\n                var centerAfter = ".flatpickr-calendar.centerMost:after";\n                var centerIndex = doc.cssRules.length;\n                var centerStyle = "{left:" + inputBounds.left + "px;right:auto;}";\n                toggleClass(self.calendarContainer, "rightMost", false);\n                toggleClass(self.calendarContainer, "centerMost", true);\n                doc.insertRule(centerBefore + "," + centerAfter + centerStyle, centerIndex);\n                self.calendarContainer.style.left = centerLeft + "px";\n                self.calendarContainer.style.right = "auto";\n            }\n        }\n        function redraw() {\n            if (self.config.noCalendar || self.isMobile)\n                return;\n            updateNavigationCurrentMonth();\n            buildDays();\n        }\n        function focusAndClose() {\n            self._input.focus();\n            if (window.navigator.userAgent.indexOf("MSIE") !== -1 ||\n                navigator.msMaxTouchPoints !== undefined) {\n                // hack - bugs in the way IE handles focus keeps the calendar open\n                setTimeout(self.close, 0);\n            }\n            else {\n                self.close();\n            }\n        }\n        function selectDate(e) {\n            e.preventDefault();\n            e.stopPropagation();\n            var isSelectable = function (day) {\n                return day.classList &&\n                    day.classList.contains("flatpickr-day") &&\n                    !day.classList.contains("flatpickr-disabled") &&\n                    !day.classList.contains("notAllowed");\n            };\n            var t = findParent(e.target, isSelectable);\n            if (t === undefined)\n                return;\n            var target = t;\n            var selectedDate = (self.latestSelectedDateObj = new Date(target.dateObj.getTime()));\n            var shouldChangeMonth = (selectedDate.getMonth() < self.currentMonth ||\n                selectedDate.getMonth() >\n                    self.currentMonth + self.config.showMonths - 1) &&\n                self.config.mode !== "range";\n            self.selectedDateElem = target;\n            if (self.config.mode === "single")\n                self.selectedDates = [selectedDate];\n            else if (self.config.mode === "multiple") {\n                var selectedIndex = isDateSelected(selectedDate);\n                if (selectedIndex)\n                    self.selectedDates.splice(parseInt(selectedIndex), 1);\n                else\n                    self.selectedDates.push(selectedDate);\n            }\n            else if (self.config.mode === "range") {\n                if (self.selectedDates.length === 2) {\n                    self.clear(false, false);\n                }\n                self.latestSelectedDateObj = selectedDate;\n                self.selectedDates.push(selectedDate);\n                // unless selecting same date twice, sort ascendingly\n                if (compareDates(selectedDate, self.selectedDates[0], true) !== 0)\n                    self.selectedDates.sort(function (a, b) { return a.getTime() - b.getTime(); });\n            }\n            setHoursFromInputs();\n            if (shouldChangeMonth) {\n                var isNewYear = self.currentYear !== selectedDate.getFullYear();\n                self.currentYear = selectedDate.getFullYear();\n                self.currentMonth = selectedDate.getMonth();\n                if (isNewYear) {\n                    triggerEvent("onYearChange");\n                    buildMonthSwitch();\n                }\n                triggerEvent("onMonthChange");\n            }\n            updateNavigationCurrentMonth();\n            buildDays();\n            updateValue();\n            if (self.config.enableTime)\n                setTimeout(function () { return (self.showTimeInput = true); }, 50);\n            // maintain focus\n            if (!shouldChangeMonth &&\n                self.config.mode !== "range" &&\n                self.config.showMonths === 1)\n                focusOnDayElem(target);\n            else if (self.selectedDateElem !== undefined &&\n                self.hourElement === undefined) {\n                self.selectedDateElem && self.selectedDateElem.focus();\n            }\n            if (self.hourElement !== undefined)\n                self.hourElement !== undefined && self.hourElement.focus();\n            if (self.config.closeOnSelect) {\n                var single = self.config.mode === "single" && !self.config.enableTime;\n                var range = self.config.mode === "range" &&\n                    self.selectedDates.length === 2 &&\n                    !self.config.enableTime;\n                if (single || range) {\n                    focusAndClose();\n                }\n            }\n            triggerChange();\n        }\n        var CALLBACKS = {\n            locale: [setupLocale, updateWeekdays],\n            showMonths: [buildMonths, setCalendarWidth, buildWeekdays],\n            minDate: [jumpToDate],\n            maxDate: [jumpToDate]\n        };\n        function set(option, value) {\n            if (option !== null && typeof option === "object") {\n                Object.assign(self.config, option);\n                for (var key in option) {\n                    if (CALLBACKS[key] !== undefined)\n                        CALLBACKS[key].forEach(function (x) { return x(); });\n                }\n            }\n            else {\n                self.config[option] = value;\n                if (CALLBACKS[option] !== undefined)\n                    CALLBACKS[option].forEach(function (x) { return x(); });\n                else if (HOOKS.indexOf(option) > -1)\n                    self.config[option] = arrayify(value);\n            }\n            self.redraw();\n            updateValue(false);\n        }\n        function setSelectedDate(inputDate, format) {\n            var dates = [];\n            if (inputDate instanceof Array)\n                dates = inputDate.map(function (d) { return self.parseDate(d, format); });\n            else if (inputDate instanceof Date || typeof inputDate === "number")\n                dates = [self.parseDate(inputDate, format)];\n            else if (typeof inputDate === "string") {\n                switch (self.config.mode) {\n                    case "single":\n                    case "time":\n                        dates = [self.parseDate(inputDate, format)];\n                        break;\n                    case "multiple":\n                        dates = inputDate\n                            .split(self.config.conjunction)\n                            .map(function (date) { return self.parseDate(date, format); });\n                        break;\n                    case "range":\n                        dates = inputDate\n                            .split(self.l10n.rangeSeparator)\n                            .map(function (date) { return self.parseDate(date, format); });\n                        break;\n                    default:\n                        break;\n                }\n            }\n            else\n                self.config.errorHandler(new Error("Invalid date supplied: " + JSON.stringify(inputDate)));\n            self.selectedDates = dates.filter(function (d) { return d instanceof Date && isEnabled(d, false); });\n            if (self.config.mode === "range")\n                self.selectedDates.sort(function (a, b) { return a.getTime() - b.getTime(); });\n        }\n        function setDate(date, triggerChange, format) {\n            if (triggerChange === void 0) { triggerChange = false; }\n            if (format === void 0) { format = self.config.dateFormat; }\n            if ((date !== 0 && !date) || (date instanceof Array && date.length === 0))\n                return self.clear(triggerChange);\n            setSelectedDate(date, format);\n            self.showTimeInput = self.selectedDates.length > 0;\n            self.latestSelectedDateObj =\n                self.selectedDates[self.selectedDates.length - 1];\n            self.redraw();\n            jumpToDate();\n            setHoursFromDate();\n            if (self.selectedDates.length === 0) {\n                self.clear(false);\n            }\n            updateValue(triggerChange);\n            if (triggerChange)\n                triggerEvent("onChange");\n        }\n        function parseDateRules(arr) {\n            return arr\n                .slice()\n                .map(function (rule) {\n                if (typeof rule === "string" ||\n                    typeof rule === "number" ||\n                    rule instanceof Date) {\n                    return self.parseDate(rule, undefined, true);\n                }\n                else if (rule &&\n                    typeof rule === "object" &&\n                    rule.from &&\n                    rule.to)\n                    return {\n                        from: self.parseDate(rule.from, undefined),\n                        to: self.parseDate(rule.to, undefined)\n                    };\n                return rule;\n            })\n                .filter(function (x) { return x; }); // remove falsy values\n        }\n        function setupDates() {\n            self.selectedDates = [];\n            self.now = self.parseDate(self.config.now) || new Date();\n            // Workaround IE11 setting placeholder as the input\'s value\n            var preloadedDate = self.config.defaultDate ||\n                ((self.input.nodeName === "INPUT" ||\n                    self.input.nodeName === "TEXTAREA") &&\n                    self.input.placeholder &&\n                    self.input.value === self.input.placeholder\n                    ? null\n                    : self.input.value);\n            if (preloadedDate)\n                setSelectedDate(preloadedDate, self.config.dateFormat);\n            self._initialDate =\n                self.selectedDates.length > 0\n                    ? self.selectedDates[0]\n                    : self.config.minDate &&\n                        self.config.minDate.getTime() > self.now.getTime()\n                        ? self.config.minDate\n                        : self.config.maxDate &&\n                            self.config.maxDate.getTime() < self.now.getTime()\n                            ? self.config.maxDate\n                            : self.now;\n            self.currentYear = self._initialDate.getFullYear();\n            self.currentMonth = self._initialDate.getMonth();\n            if (self.selectedDates.length > 0)\n                self.latestSelectedDateObj = self.selectedDates[0];\n            if (self.config.minTime !== undefined)\n                self.config.minTime = self.parseDate(self.config.minTime, "H:i");\n            if (self.config.maxTime !== undefined)\n                self.config.maxTime = self.parseDate(self.config.maxTime, "H:i");\n            self.minDateHasTime =\n                !!self.config.minDate &&\n                    (self.config.minDate.getHours() > 0 ||\n                        self.config.minDate.getMinutes() > 0 ||\n                        self.config.minDate.getSeconds() > 0);\n            self.maxDateHasTime =\n                !!self.config.maxDate &&\n                    (self.config.maxDate.getHours() > 0 ||\n                        self.config.maxDate.getMinutes() > 0 ||\n                        self.config.maxDate.getSeconds() > 0);\n            Object.defineProperty(self, "showTimeInput", {\n                get: function () { return self._showTimeInput; },\n                set: function (bool) {\n                    self._showTimeInput = bool;\n                    if (self.calendarContainer)\n                        toggleClass(self.calendarContainer, "showTimeInput", bool);\n                    self.isOpen && positionCalendar();\n                }\n            });\n        }\n        function setupInputs() {\n            self.input = self.config.wrap\n                ? element.querySelector("[data-input]")\n                : element;\n            /* istanbul ignore next */\n            if (!self.input) {\n                self.config.errorHandler(new Error("Invalid input element specified"));\n                return;\n            }\n            // hack: store previous type to restore it after destroy()\n            self.input._type = self.input.type;\n            self.input.type = "text";\n            self.input.classList.add("flatpickr-input");\n            self._input = self.input;\n            if (self.config.altInput) {\n                // replicate self.element\n                self.altInput = createElement(self.input.nodeName, self.config.altInputClass);\n                self._input = self.altInput;\n                self.altInput.placeholder = self.input.placeholder;\n                self.altInput.disabled = self.input.disabled;\n                self.altInput.required = self.input.required;\n                self.altInput.tabIndex = self.input.tabIndex;\n                self.altInput.type = "text";\n                self.input.setAttribute("type", "hidden");\n                if (!self.config.static && self.input.parentNode)\n                    self.input.parentNode.insertBefore(self.altInput, self.input.nextSibling);\n            }\n            if (!self.config.allowInput)\n                self._input.setAttribute("readonly", "readonly");\n            self._positionElement = self.config.positionElement || self._input;\n        }\n        function setupMobile() {\n            var inputType = self.config.enableTime\n                ? self.config.noCalendar\n                    ? "time"\n                    : "datetime-local"\n                : "date";\n            self.mobileInput = createElement("input", self.input.className + " flatpickr-mobile");\n            self.mobileInput.step = self.input.getAttribute("step") || "any";\n            self.mobileInput.tabIndex = 1;\n            self.mobileInput.type = inputType;\n            self.mobileInput.disabled = self.input.disabled;\n            self.mobileInput.required = self.input.required;\n            self.mobileInput.placeholder = self.input.placeholder;\n            self.mobileFormatStr =\n                inputType === "datetime-local"\n                    ? "Y-m-d\\\\TH:i:S"\n                    : inputType === "date"\n                        ? "Y-m-d"\n                        : "H:i:S";\n            if (self.selectedDates.length > 0) {\n                self.mobileInput.defaultValue = self.mobileInput.value = self.formatDate(self.selectedDates[0], self.mobileFormatStr);\n            }\n            if (self.config.minDate)\n                self.mobileInput.min = self.formatDate(self.config.minDate, "Y-m-d");\n            if (self.config.maxDate)\n                self.mobileInput.max = self.formatDate(self.config.maxDate, "Y-m-d");\n            self.input.type = "hidden";\n            if (self.altInput !== undefined)\n                self.altInput.type = "hidden";\n            try {\n                if (self.input.parentNode)\n                    self.input.parentNode.insertBefore(self.mobileInput, self.input.nextSibling);\n            }\n            catch (_a) { }\n            bind(self.mobileInput, "change", function (e) {\n                self.setDate(e.target.value, false, self.mobileFormatStr);\n                triggerEvent("onChange");\n                triggerEvent("onClose");\n            });\n        }\n        function toggle(e) {\n            if (self.isOpen === true)\n                return self.close();\n            self.open(e);\n        }\n        function triggerEvent(event, data) {\n            // If the instance has been destroyed already, all hooks have been removed\n            if (self.config === undefined)\n                return;\n            var hooks = self.config[event];\n            if (hooks !== undefined && hooks.length > 0) {\n                for (var i = 0; hooks[i] && i < hooks.length; i++)\n                    hooks[i](self.selectedDates, self.input.value, self, data);\n            }\n            if (event === "onChange") {\n                self.input.dispatchEvent(createEvent("change"));\n                // many front-end frameworks bind to the input event\n                self.input.dispatchEvent(createEvent("input"));\n            }\n        }\n        function createEvent(name) {\n            var e = document.createEvent("Event");\n            e.initEvent(name, true, true);\n            return e;\n        }\n        function isDateSelected(date) {\n            for (var i = 0; i < self.selectedDates.length; i++) {\n                if (compareDates(self.selectedDates[i], date) === 0)\n                    return "" + i;\n            }\n            return false;\n        }\n        function isDateInRange(date) {\n            if (self.config.mode !== "range" || self.selectedDates.length < 2)\n                return false;\n            return (compareDates(date, self.selectedDates[0]) >= 0 &&\n                compareDates(date, self.selectedDates[1]) <= 0);\n        }\n        function updateNavigationCurrentMonth() {\n            if (self.config.noCalendar || self.isMobile || !self.monthNav)\n                return;\n            self.yearElements.forEach(function (yearElement, i) {\n                var d = new Date(self.currentYear, self.currentMonth, 1);\n                d.setMonth(self.currentMonth + i);\n                if (self.config.showMonths > 1 ||\n                    self.config.monthSelectorType === "static") {\n                    self.monthElements[i].textContent =\n                        monthToStr(d.getMonth(), self.config.shorthandCurrentMonth, self.l10n) + " ";\n                }\n                else {\n                    self.monthsDropdownContainer.value = d.getMonth().toString();\n                }\n                yearElement.value = d.getFullYear().toString();\n            });\n            self._hidePrevMonthArrow =\n                self.config.minDate !== undefined &&\n                    (self.currentYear === self.config.minDate.getFullYear()\n                        ? self.currentMonth <= self.config.minDate.getMonth()\n                        : self.currentYear < self.config.minDate.getFullYear());\n            self._hideNextMonthArrow =\n                self.config.maxDate !== undefined &&\n                    (self.currentYear === self.config.maxDate.getFullYear()\n                        ? self.currentMonth + 1 > self.config.maxDate.getMonth()\n                        : self.currentYear > self.config.maxDate.getFullYear());\n        }\n        function getDateStr(format) {\n            return self.selectedDates\n                .map(function (dObj) { return self.formatDate(dObj, format); })\n                .filter(function (d, i, arr) {\n                return self.config.mode !== "range" ||\n                    self.config.enableTime ||\n                    arr.indexOf(d) === i;\n            })\n                .join(self.config.mode !== "range"\n                ? self.config.conjunction\n                : self.l10n.rangeSeparator);\n        }\n        /**\n         * Updates the values of inputs associated with the calendar\n         */\n        function updateValue(triggerChange) {\n            if (triggerChange === void 0) { triggerChange = true; }\n            if (self.mobileInput !== undefined && self.mobileFormatStr) {\n                self.mobileInput.value =\n                    self.latestSelectedDateObj !== undefined\n                        ? self.formatDate(self.latestSelectedDateObj, self.mobileFormatStr)\n                        : "";\n            }\n            self.input.value = getDateStr(self.config.dateFormat);\n            if (self.altInput !== undefined) {\n                self.altInput.value = getDateStr(self.config.altFormat);\n            }\n            if (triggerChange !== false)\n                triggerEvent("onValueUpdate");\n        }\n        function onMonthNavClick(e) {\n            var isPrevMonth = self.prevMonthNav.contains(e.target);\n            var isNextMonth = self.nextMonthNav.contains(e.target);\n            if (isPrevMonth || isNextMonth) {\n                changeMonth(isPrevMonth ? -1 : 1);\n            }\n            else if (self.yearElements.indexOf(e.target) >= 0) {\n                e.target.select();\n            }\n            else if (e.target.classList.contains("arrowUp")) {\n                self.changeYear(self.currentYear + 1);\n            }\n            else if (e.target.classList.contains("arrowDown")) {\n                self.changeYear(self.currentYear - 1);\n            }\n        }\n        function timeWrapper(e) {\n            e.preventDefault();\n            var isKeyDown = e.type === "keydown", input = e.target;\n            if (self.amPM !== undefined && e.target === self.amPM) {\n                self.amPM.textContent =\n                    self.l10n.amPM[int(self.amPM.textContent === self.l10n.amPM[0])];\n            }\n            var min = parseFloat(input.getAttribute("min")), max = parseFloat(input.getAttribute("max")), step = parseFloat(input.getAttribute("step")), curValue = parseInt(input.value, 10), delta = e.delta ||\n                (isKeyDown ? (e.which === 38 ? 1 : -1) : 0);\n            var newValue = curValue + step * delta;\n            if (typeof input.value !== "undefined" && input.value.length === 2) {\n                var isHourElem = input === self.hourElement, isMinuteElem = input === self.minuteElement;\n                if (newValue < min) {\n                    newValue =\n                        max +\n                            newValue +\n                            int(!isHourElem) +\n                            (int(isHourElem) && int(!self.amPM));\n                    if (isMinuteElem)\n                        incrementNumInput(undefined, -1, self.hourElement);\n                }\n                else if (newValue > max) {\n                    newValue =\n                        input === self.hourElement ? newValue - max - int(!self.amPM) : min;\n                    if (isMinuteElem)\n                        incrementNumInput(undefined, 1, self.hourElement);\n                }\n                if (self.amPM &&\n                    isHourElem &&\n                    (step === 1\n                        ? newValue + curValue === 23\n                        : Math.abs(newValue - curValue) > step)) {\n                    self.amPM.textContent =\n                        self.l10n.amPM[int(self.amPM.textContent === self.l10n.amPM[0])];\n                }\n                input.value = pad(newValue);\n            }\n        }\n        init();\n        return self;\n    }\n    /* istanbul ignore next */\n    function _flatpickr(nodeList, config) {\n        // static list\n        var nodes = Array.prototype.slice\n            .call(nodeList)\n            .filter(function (x) { return x instanceof HTMLElement; });\n        var instances = [];\n        for (var i = 0; i < nodes.length; i++) {\n            var node = nodes[i];\n            try {\n                if (node.getAttribute("data-fp-omit") !== null)\n                    continue;\n                if (node._flatpickr !== undefined) {\n                    node._flatpickr.destroy();\n                    node._flatpickr = undefined;\n                }\n                node._flatpickr = FlatpickrInstance(node, config || {});\n                instances.push(node._flatpickr);\n            }\n            catch (e) {\n                console.error(e);\n            }\n        }\n        return instances.length === 1 ? instances[0] : instances;\n    }\n    /* istanbul ignore next */\n    if (typeof HTMLElement !== "undefined" &&\n        typeof HTMLCollection !== "undefined" &&\n        typeof NodeList !== "undefined") {\n        // browser env\n        HTMLCollection.prototype.flatpickr = NodeList.prototype.flatpickr = function (config) {\n            return _flatpickr(this, config);\n        };\n        HTMLElement.prototype.flatpickr = function (config) {\n            return _flatpickr([this], config);\n        };\n    }\n    /* istanbul ignore next */\n    var flatpickr = function (selector, config) {\n        if (typeof selector === "string") {\n            return _flatpickr(window.document.querySelectorAll(selector), config);\n        }\n        else if (selector instanceof Node) {\n            return _flatpickr([selector], config);\n        }\n        else {\n            return _flatpickr(selector, config);\n        }\n    };\n    /* istanbul ignore next */\n    flatpickr.defaultConfig = {};\n    flatpickr.l10ns = {\n        en: __assign({}, english),\n        "default": __assign({}, english)\n    };\n    flatpickr.localize = function (l10n) {\n        flatpickr.l10ns["default"] = __assign({}, flatpickr.l10ns["default"], l10n);\n    };\n    flatpickr.setDefaults = function (config) {\n        flatpickr.defaultConfig = __assign({}, flatpickr.defaultConfig, config);\n    };\n    flatpickr.parseDate = createDateParser({});\n    flatpickr.formatDate = createDateFormatter({});\n    flatpickr.compareDates = compareDates;\n    /* istanbul ignore next */\n    if (typeof jQuery !== "undefined" && typeof jQuery.fn !== "undefined") {\n        jQuery.fn.flatpickr = function (config) {\n            return _flatpickr(this, config);\n        };\n    }\n    // eslint-disable-next-line @typescript-eslint/camelcase\n    Date.prototype.fp_incr = function (days) {\n        return new Date(this.getFullYear(), this.getMonth(), this.getDate() + (typeof days === "string" ? parseInt(days, 10) : days));\n    };\n    if (typeof window !== "undefined") {\n        window.flatpickr = flatpickr;\n    }\n\n    return flatpickr;\n\n}));\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZmxhdHBpY2tyL2Rpc3QvZmxhdHBpY2tyLmpzP2NmMDYiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBLElBQUksS0FBNEQ7QUFDaEUsSUFBSSxTQUN1RDtBQUMzRCxDQUFDLG9CQUFvQjs7QUFFckI7QUFDQTtBQUNBLG1FQUFtRTtBQUNuRTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0Esb0RBQW9ELE9BQU87QUFDM0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsaUNBQWlDLGlDQUFpQztBQUNsRSwrQkFBK0IsZ0NBQWdDO0FBQy9EO0FBQ0E7QUFDQSxtQ0FBbUMsbUJBQW1CO0FBQ3REO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QjtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxpQ0FBaUMsa0JBQWtCO0FBQ25ELGdFQUFnRSx5RUFBeUU7QUFDekk7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFNBQVM7QUFDVCxzQ0FBc0MsaURBQWlELEVBQUU7QUFDekY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsU0FBUztBQUNULGtDQUFrQywwQkFBMEIsRUFBRTtBQUM5RDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQixFQUFFO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsRUFBRTtBQUNuQjtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsMkJBQTJCLEVBQUU7QUFDekQ7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSw0QkFBNEIsNkJBQTZCLEVBQUU7QUFDM0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLG9DQUFvQywrQ0FBK0MsRUFBRTtBQUNyRjtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSw0QkFBNEIsK0JBQStCLEVBQUU7QUFDN0Q7QUFDQSw0QkFBNEIsOEJBQThCLEVBQUU7QUFDNUQ7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLDRCQUE0QiwyQkFBMkIsRUFBRTtBQUN6RDtBQUNBLDRCQUE0Qiw0QkFBNEIsRUFBRTtBQUMxRDtBQUNBLDRCQUE0QiwyREFBMkQsRUFBRTtBQUN6RjtBQUNBLDRCQUE0QiwrQkFBK0IsRUFBRTtBQUM3RDtBQUNBLDRCQUE0Qix1QkFBdUIsRUFBRTtBQUNyRDtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSw0QkFBNEIsaUNBQWlDLEVBQUU7QUFDL0Q7QUFDQSw0QkFBNEIsNEJBQTRCLEVBQUU7QUFDMUQ7QUFDQSw0QkFBNEIsMEJBQTBCLEVBQUU7QUFDeEQ7QUFDQSw0QkFBNEIsdUJBQXVCLEVBQUU7QUFDckQ7QUFDQSw0QkFBNEIsc0JBQXNCLEVBQUU7QUFDcEQ7QUFDQSw0QkFBNEIsZ0RBQWdEO0FBQzVFOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0VBQWtFLG1CQUFtQjtBQUNyRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQztBQUNqQztBQUNBO0FBQ0E7QUFDQSw0Q0FBNEM7QUFDNUM7QUFDQTtBQUNBO0FBQ0EseUJBQXlCO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtDQUFrQyxpQkFBaUI7QUFDbkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0Qix1QkFBdUI7QUFDbkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnRUFBZ0Usb0NBQW9DLEVBQUU7QUFDdEc7QUFDQTtBQUNBLDJDQUEyQyxvQkFBb0I7QUFDL0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLCtCQUErQjtBQUMvQjtBQUNBO0FBQ0EsMkNBQTJDLHVDQUF1QztBQUNsRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJDQUEyQywyQkFBMkI7QUFDdEUsd0NBQXdDLHVCQUF1QjtBQUMvRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixPQUFPO0FBQzFCO0FBQ0EsbUJBQW1CLE9BQU87QUFDMUIsbUJBQW1CLE9BQU87QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLE1BQU07QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsUUFBUTtBQUMzQixtQkFBbUIsT0FBTztBQUMxQixtQkFBbUIsU0FBUztBQUM1QjtBQUNBO0FBQ0E7QUFDQSxvREFBb0QsNENBQTRDLEVBQUU7QUFDbEc7QUFDQSxzREFBc0QsMENBQTBDLEVBQUU7QUFDbEc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixTQUFTO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckIsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyREFBMkQsZ0JBQWdCO0FBQzNFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOERBQThELGdCQUFnQjtBQUM5RTtBQUNBO0FBQ0E7QUFDQSxtRUFBbUUsMERBQTBELEVBQUU7QUFDL0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixLQUFLO0FBQ3hCLG1CQUFtQixRQUFRO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsTUFBTTtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixNQUFNO0FBQ3pCLG1CQUFtQixPQUFPO0FBQzFCLG1CQUFtQixRQUFRO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0NBQW9DLGVBQWU7QUFDbkQ7QUFDQTtBQUNBO0FBQ0Esd0NBQXdDLGVBQWU7QUFDdkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3REFBd0QsZUFBZTtBQUN2RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdDQUF3QyxvRUFBb0U7QUFDNUc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IsNEJBQTRCO0FBQzlDO0FBQ0E7QUFDQTtBQUNBLCtCQUErQiwwQkFBMEI7QUFDekQ7QUFDQTtBQUNBO0FBQ0EsOENBQThDO0FBQzlDLHFFQUFxRTtBQUNyRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQiw0QkFBNEI7QUFDdkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQixRQUFRO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQSwyREFBMkQsaUJBQWlCO0FBQzVFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnREFBZ0QsS0FBSztBQUNyRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0NBQWtDLGtDQUFrQyxFQUFFO0FBQ3RFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBLGtDQUFrQyxrQ0FBa0MsRUFBRTtBQUN0RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnREFBZ0QsS0FBSztBQUNyRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnREFBZ0QsS0FBSztBQUNyRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNDQUFzQyxpQkFBaUI7QUFDdkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnREFBZ0QsMkJBQTJCO0FBQzNFLHVDQUF1QyxrQkFBa0I7QUFDekQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtDQUErQyxLQUFLO0FBQ3BEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkI7QUFDM0IsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0NBQXNDLGlCQUFpQjtBQUN2RCx3RUFBd0U7QUFDeEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUNBQXVDLGtCQUFrQjtBQUN6RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0RBQXNELFVBQVUsRUFBRTtBQUNsRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0NBQXdDLGtCQUFrQjtBQUMxRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkIsNEJBQTRCO0FBQ3ZEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMERBQTBELE9BQU87QUFDakU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2Q0FBNkMseUNBQXlDO0FBQ3RGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0Q0FBNEMsa0NBQWtDLEVBQUU7QUFDaEY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlGQUFpRixxQkFBcUIsRUFBRTtBQUN4RztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3Q0FBd0MsaUVBQWlFO0FBQ3pHO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0NBQWtDLDRCQUE0QixFQUFFO0FBQ2hFO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBLGtDQUFrQyw2QkFBNkIsRUFBRTtBQUNqRTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQ0FBa0MsNkJBQTZCLEVBQUU7QUFDakU7QUFDQSxhQUFhO0FBQ2I7QUFDQSxrQ0FBa0MsNkJBQTZCLEVBQUU7QUFDakU7QUFDQSxhQUFhO0FBQ2Isb0RBQW9EO0FBQ3BEO0FBQ0EsY0FBYztBQUNkO0FBQ0Esa0NBQWtDLDZCQUE2QixFQUFFO0FBQ2pFO0FBQ0EsYUFBYTtBQUNiO0FBQ0Esa0NBQWtDLDZCQUE2QixFQUFFO0FBQ2pFO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkIscUJBQXFCO0FBQ2hEO0FBQ0E7QUFDQTtBQUNBLDBDQUEwQyx3Q0FBd0MsRUFBRTtBQUNwRjtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCLGdDQUFnQztBQUMzRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUNBQW1DO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3Q0FBd0MsaUVBQWlFO0FBQ3pHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQ0FBK0MsdUNBQXVDO0FBQ3RGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNIQUFzSCxpQ0FBaUMsRUFBRTtBQUN6SjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9DQUFvQyxnQ0FBZ0MsWUFBWTtBQUNoRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2REFBNkQsa0NBQWtDLEVBQUU7QUFDakc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3Q0FBd0Msb0NBQW9DLEVBQUU7QUFDOUU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkRBQTZELFlBQVksRUFBRTtBQUMzRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNERBQTRELFlBQVksRUFBRTtBQUMxRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvREFBb0Qsa0NBQWtDLEVBQUU7QUFDeEY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtEQUFrRCxxQ0FBcUMsRUFBRTtBQUN6RjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtEQUFrRCxxQ0FBcUMsRUFBRTtBQUN6RjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDREQUE0RCxpREFBaUQsRUFBRTtBQUMvRztBQUNBLHlEQUF5RCxrQ0FBa0MsRUFBRTtBQUM3RjtBQUNBO0FBQ0EsMkNBQTJDLHVCQUF1QjtBQUNsRSxvQ0FBb0MsaUNBQWlDO0FBQ3JFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLHNDQUFzQyxVQUFVLEVBQUUsRUFBRTtBQUNwRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtDQUFrQyw0QkFBNEIsRUFBRTtBQUNoRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QjtBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQkFBK0IsOEJBQThCO0FBQzdEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkIsK0JBQStCO0FBQzFEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQ0FBc0Msc0NBQXNDLEVBQUU7QUFDOUU7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJDQUEyQyxzQkFBc0I7QUFDakU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0NBQWtDLGlDQUFpQyxFQUFFO0FBQ3JFO0FBQ0EsdUJBQXVCLGtCQUFrQjtBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0VBQXNFO0FBQ3RFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUI7QUFDdkIsOEJBQThCO0FBQzlCO0FBQ0E7QUFDQSxnREFBZ0Q7QUFDaEQ7QUFDQTtBQUNBLDZDQUE2QztBQUM3QztBQUNBLDZDQUE2QztBQUM3QyxpREFBaUQ7QUFDakQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSxDQUFDIiwiZmlsZSI6ImNmMDYuanMiLCJzb3VyY2VzQ29udGVudCI6WyIvKiBmbGF0cGlja3IgdjQuNi4yLCBAbGljZW5zZSBNSVQgKi9cbihmdW5jdGlvbiAoZ2xvYmFsLCBmYWN0b3J5KSB7XG4gICAgdHlwZW9mIGV4cG9ydHMgPT09ICdvYmplY3QnICYmIHR5cGVvZiBtb2R1bGUgIT09ICd1bmRlZmluZWQnID8gbW9kdWxlLmV4cG9ydHMgPSBmYWN0b3J5KCkgOlxuICAgIHR5cGVvZiBkZWZpbmUgPT09ICdmdW5jdGlvbicgJiYgZGVmaW5lLmFtZCA/IGRlZmluZShmYWN0b3J5KSA6XG4gICAgKGdsb2JhbCA9IGdsb2JhbCB8fCBzZWxmLCBnbG9iYWwuZmxhdHBpY2tyID0gZmFjdG9yeSgpKTtcbn0odGhpcywgZnVuY3Rpb24gKCkgeyAndXNlIHN0cmljdCc7XG5cbiAgICAvKiEgKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKipcclxuICAgIENvcHlyaWdodCAoYykgTWljcm9zb2Z0IENvcnBvcmF0aW9uLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxyXG4gICAgTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTsgeW91IG1heSBub3QgdXNlXHJcbiAgICB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS4gWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZVxyXG4gICAgTGljZW5zZSBhdCBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcclxuXHJcbiAgICBUSElTIENPREUgSVMgUFJPVklERUQgT04gQU4gKkFTIElTKiBCQVNJUywgV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZXHJcbiAgICBLSU5ELCBFSVRIRVIgRVhQUkVTUyBPUiBJTVBMSUVELCBJTkNMVURJTkcgV0lUSE9VVCBMSU1JVEFUSU9OIEFOWSBJTVBMSUVEXHJcbiAgICBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgVElUTEUsIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFLFxyXG4gICAgTUVSQ0hBTlRBQkxJVFkgT1IgTk9OLUlORlJJTkdFTUVOVC5cclxuXHJcbiAgICBTZWUgdGhlIEFwYWNoZSBWZXJzaW9uIDIuMCBMaWNlbnNlIGZvciBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnNcclxuICAgIGFuZCBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cclxuICAgICoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqICovXHJcblxyXG4gICAgdmFyIF9fYXNzaWduID0gZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgX19hc3NpZ24gPSBPYmplY3QuYXNzaWduIHx8IGZ1bmN0aW9uIF9fYXNzaWduKHQpIHtcclxuICAgICAgICAgICAgZm9yICh2YXIgcywgaSA9IDEsIG4gPSBhcmd1bWVudHMubGVuZ3RoOyBpIDwgbjsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICBzID0gYXJndW1lbnRzW2ldO1xyXG4gICAgICAgICAgICAgICAgZm9yICh2YXIgcCBpbiBzKSBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHMsIHApKSB0W3BdID0gc1twXTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gdDtcclxuICAgICAgICB9O1xyXG4gICAgICAgIHJldHVybiBfX2Fzc2lnbi5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xyXG4gICAgfTtcblxuICAgIHZhciBIT09LUyA9IFtcbiAgICAgICAgXCJvbkNoYW5nZVwiLFxuICAgICAgICBcIm9uQ2xvc2VcIixcbiAgICAgICAgXCJvbkRheUNyZWF0ZVwiLFxuICAgICAgICBcIm9uRGVzdHJveVwiLFxuICAgICAgICBcIm9uS2V5RG93blwiLFxuICAgICAgICBcIm9uTW9udGhDaGFuZ2VcIixcbiAgICAgICAgXCJvbk9wZW5cIixcbiAgICAgICAgXCJvblBhcnNlQ29uZmlnXCIsXG4gICAgICAgIFwib25SZWFkeVwiLFxuICAgICAgICBcIm9uVmFsdWVVcGRhdGVcIixcbiAgICAgICAgXCJvblllYXJDaGFuZ2VcIixcbiAgICAgICAgXCJvblByZUNhbGVuZGFyUG9zaXRpb25cIixcbiAgICBdO1xuICAgIHZhciBkZWZhdWx0cyA9IHtcbiAgICAgICAgX2Rpc2FibGU6IFtdLFxuICAgICAgICBfZW5hYmxlOiBbXSxcbiAgICAgICAgYWxsb3dJbnB1dDogZmFsc2UsXG4gICAgICAgIGFsdEZvcm1hdDogXCJGIGosIFlcIixcbiAgICAgICAgYWx0SW5wdXQ6IGZhbHNlLFxuICAgICAgICBhbHRJbnB1dENsYXNzOiBcImZvcm0tY29udHJvbCBpbnB1dFwiLFxuICAgICAgICBhbmltYXRlOiB0eXBlb2Ygd2luZG93ID09PSBcIm9iamVjdFwiICYmXG4gICAgICAgICAgICB3aW5kb3cubmF2aWdhdG9yLnVzZXJBZ2VudC5pbmRleE9mKFwiTVNJRVwiKSA9PT0gLTEsXG4gICAgICAgIGFyaWFEYXRlRm9ybWF0OiBcIkYgaiwgWVwiLFxuICAgICAgICBjbGlja09wZW5zOiB0cnVlLFxuICAgICAgICBjbG9zZU9uU2VsZWN0OiB0cnVlLFxuICAgICAgICBjb25qdW5jdGlvbjogXCIsIFwiLFxuICAgICAgICBkYXRlRm9ybWF0OiBcIlktbS1kXCIsXG4gICAgICAgIGRlZmF1bHRIb3VyOiAxMixcbiAgICAgICAgZGVmYXVsdE1pbnV0ZTogMCxcbiAgICAgICAgZGVmYXVsdFNlY29uZHM6IDAsXG4gICAgICAgIGRpc2FibGU6IFtdLFxuICAgICAgICBkaXNhYmxlTW9iaWxlOiBmYWxzZSxcbiAgICAgICAgZW5hYmxlOiBbXSxcbiAgICAgICAgZW5hYmxlU2Vjb25kczogZmFsc2UsXG4gICAgICAgIGVuYWJsZVRpbWU6IGZhbHNlLFxuICAgICAgICBlcnJvckhhbmRsZXI6IGZ1bmN0aW9uIChlcnIpIHtcbiAgICAgICAgICAgIHJldHVybiB0eXBlb2YgY29uc29sZSAhPT0gXCJ1bmRlZmluZWRcIiAmJiBjb25zb2xlLndhcm4oZXJyKTtcbiAgICAgICAgfSxcbiAgICAgICAgZ2V0V2VlazogZnVuY3Rpb24gKGdpdmVuRGF0ZSkge1xuICAgICAgICAgICAgdmFyIGRhdGUgPSBuZXcgRGF0ZShnaXZlbkRhdGUuZ2V0VGltZSgpKTtcbiAgICAgICAgICAgIGRhdGUuc2V0SG91cnMoMCwgMCwgMCwgMCk7XG4gICAgICAgICAgICAvLyBUaHVyc2RheSBpbiBjdXJyZW50IHdlZWsgZGVjaWRlcyB0aGUgeWVhci5cbiAgICAgICAgICAgIGRhdGUuc2V0RGF0ZShkYXRlLmdldERhdGUoKSArIDMgLSAoKGRhdGUuZ2V0RGF5KCkgKyA2KSAlIDcpKTtcbiAgICAgICAgICAgIC8vIEphbnVhcnkgNCBpcyBhbHdheXMgaW4gd2VlayAxLlxuICAgICAgICAgICAgdmFyIHdlZWsxID0gbmV3IERhdGUoZGF0ZS5nZXRGdWxsWWVhcigpLCAwLCA0KTtcbiAgICAgICAgICAgIC8vIEFkanVzdCB0byBUaHVyc2RheSBpbiB3ZWVrIDEgYW5kIGNvdW50IG51bWJlciBvZiB3ZWVrcyBmcm9tIGRhdGUgdG8gd2VlazEuXG4gICAgICAgICAgICByZXR1cm4gKDEgK1xuICAgICAgICAgICAgICAgIE1hdGgucm91bmQoKChkYXRlLmdldFRpbWUoKSAtIHdlZWsxLmdldFRpbWUoKSkgLyA4NjQwMDAwMCAtXG4gICAgICAgICAgICAgICAgICAgIDMgK1xuICAgICAgICAgICAgICAgICAgICAoKHdlZWsxLmdldERheSgpICsgNikgJSA3KSkgL1xuICAgICAgICAgICAgICAgICAgICA3KSk7XG4gICAgICAgIH0sXG4gICAgICAgIGhvdXJJbmNyZW1lbnQ6IDEsXG4gICAgICAgIGlnbm9yZWRGb2N1c0VsZW1lbnRzOiBbXSxcbiAgICAgICAgaW5saW5lOiBmYWxzZSxcbiAgICAgICAgbG9jYWxlOiBcImRlZmF1bHRcIixcbiAgICAgICAgbWludXRlSW5jcmVtZW50OiA1LFxuICAgICAgICBtb2RlOiBcInNpbmdsZVwiLFxuICAgICAgICBtb250aFNlbGVjdG9yVHlwZTogXCJkcm9wZG93blwiLFxuICAgICAgICBuZXh0QXJyb3c6IFwiPHN2ZyB2ZXJzaW9uPScxLjEnIHhtbG5zPSdodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZycgeG1sbnM6eGxpbms9J2h0dHA6Ly93d3cudzMub3JnLzE5OTkveGxpbmsnIHZpZXdCb3g9JzAgMCAxNyAxNyc+PGc+PC9nPjxwYXRoIGQ9J00xMy4yMDcgOC40NzJsLTcuODU0IDcuODU0LTAuNzA3LTAuNzA3IDcuMTQ2LTcuMTQ2LTcuMTQ2LTcuMTQ4IDAuNzA3LTAuNzA3IDcuODU0IDcuODU0eicgLz48L3N2Zz5cIixcbiAgICAgICAgbm9DYWxlbmRhcjogZmFsc2UsXG4gICAgICAgIG5vdzogbmV3IERhdGUoKSxcbiAgICAgICAgb25DaGFuZ2U6IFtdLFxuICAgICAgICBvbkNsb3NlOiBbXSxcbiAgICAgICAgb25EYXlDcmVhdGU6IFtdLFxuICAgICAgICBvbkRlc3Ryb3k6IFtdLFxuICAgICAgICBvbktleURvd246IFtdLFxuICAgICAgICBvbk1vbnRoQ2hhbmdlOiBbXSxcbiAgICAgICAgb25PcGVuOiBbXSxcbiAgICAgICAgb25QYXJzZUNvbmZpZzogW10sXG4gICAgICAgIG9uUmVhZHk6IFtdLFxuICAgICAgICBvblZhbHVlVXBkYXRlOiBbXSxcbiAgICAgICAgb25ZZWFyQ2hhbmdlOiBbXSxcbiAgICAgICAgb25QcmVDYWxlbmRhclBvc2l0aW9uOiBbXSxcbiAgICAgICAgcGx1Z2luczogW10sXG4gICAgICAgIHBvc2l0aW9uOiBcImF1dG9cIixcbiAgICAgICAgcG9zaXRpb25FbGVtZW50OiB1bmRlZmluZWQsXG4gICAgICAgIHByZXZBcnJvdzogXCI8c3ZnIHZlcnNpb249JzEuMScgeG1sbnM9J2h0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnJyB4bWxuczp4bGluaz0naHR0cDovL3d3dy53My5vcmcvMTk5OS94bGluaycgdmlld0JveD0nMCAwIDE3IDE3Jz48Zz48L2c+PHBhdGggZD0nTTUuMjA3IDguNDcxbDcuMTQ2IDcuMTQ3LTAuNzA3IDAuNzA3LTcuODUzLTcuODU0IDcuODU0LTcuODUzIDAuNzA3IDAuNzA3LTcuMTQ3IDcuMTQ2eicgLz48L3N2Zz5cIixcbiAgICAgICAgc2hvcnRoYW5kQ3VycmVudE1vbnRoOiBmYWxzZSxcbiAgICAgICAgc2hvd01vbnRoczogMSxcbiAgICAgICAgc3RhdGljOiBmYWxzZSxcbiAgICAgICAgdGltZV8yNGhyOiBmYWxzZSxcbiAgICAgICAgd2Vla051bWJlcnM6IGZhbHNlLFxuICAgICAgICB3cmFwOiBmYWxzZVxuICAgIH07XG5cbiAgICB2YXIgZW5nbGlzaCA9IHtcbiAgICAgICAgd2Vla2RheXM6IHtcbiAgICAgICAgICAgIHNob3J0aGFuZDogW1wiU3VuXCIsIFwiTW9uXCIsIFwiVHVlXCIsIFwiV2VkXCIsIFwiVGh1XCIsIFwiRnJpXCIsIFwiU2F0XCJdLFxuICAgICAgICAgICAgbG9uZ2hhbmQ6IFtcbiAgICAgICAgICAgICAgICBcIlN1bmRheVwiLFxuICAgICAgICAgICAgICAgIFwiTW9uZGF5XCIsXG4gICAgICAgICAgICAgICAgXCJUdWVzZGF5XCIsXG4gICAgICAgICAgICAgICAgXCJXZWRuZXNkYXlcIixcbiAgICAgICAgICAgICAgICBcIlRodXJzZGF5XCIsXG4gICAgICAgICAgICAgICAgXCJGcmlkYXlcIixcbiAgICAgICAgICAgICAgICBcIlNhdHVyZGF5XCIsXG4gICAgICAgICAgICBdXG4gICAgICAgIH0sXG4gICAgICAgIG1vbnRoczoge1xuICAgICAgICAgICAgc2hvcnRoYW5kOiBbXG4gICAgICAgICAgICAgICAgXCJKYW5cIixcbiAgICAgICAgICAgICAgICBcIkZlYlwiLFxuICAgICAgICAgICAgICAgIFwiTWFyXCIsXG4gICAgICAgICAgICAgICAgXCJBcHJcIixcbiAgICAgICAgICAgICAgICBcIk1heVwiLFxuICAgICAgICAgICAgICAgIFwiSnVuXCIsXG4gICAgICAgICAgICAgICAgXCJKdWxcIixcbiAgICAgICAgICAgICAgICBcIkF1Z1wiLFxuICAgICAgICAgICAgICAgIFwiU2VwXCIsXG4gICAgICAgICAgICAgICAgXCJPY3RcIixcbiAgICAgICAgICAgICAgICBcIk5vdlwiLFxuICAgICAgICAgICAgICAgIFwiRGVjXCIsXG4gICAgICAgICAgICBdLFxuICAgICAgICAgICAgbG9uZ2hhbmQ6IFtcbiAgICAgICAgICAgICAgICBcIkphbnVhcnlcIixcbiAgICAgICAgICAgICAgICBcIkZlYnJ1YXJ5XCIsXG4gICAgICAgICAgICAgICAgXCJNYXJjaFwiLFxuICAgICAgICAgICAgICAgIFwiQXByaWxcIixcbiAgICAgICAgICAgICAgICBcIk1heVwiLFxuICAgICAgICAgICAgICAgIFwiSnVuZVwiLFxuICAgICAgICAgICAgICAgIFwiSnVseVwiLFxuICAgICAgICAgICAgICAgIFwiQXVndXN0XCIsXG4gICAgICAgICAgICAgICAgXCJTZXB0ZW1iZXJcIixcbiAgICAgICAgICAgICAgICBcIk9jdG9iZXJcIixcbiAgICAgICAgICAgICAgICBcIk5vdmVtYmVyXCIsXG4gICAgICAgICAgICAgICAgXCJEZWNlbWJlclwiLFxuICAgICAgICAgICAgXVxuICAgICAgICB9LFxuICAgICAgICBkYXlzSW5Nb250aDogWzMxLCAyOCwgMzEsIDMwLCAzMSwgMzAsIDMxLCAzMSwgMzAsIDMxLCAzMCwgMzFdLFxuICAgICAgICBmaXJzdERheU9mV2VlazogMCxcbiAgICAgICAgb3JkaW5hbDogZnVuY3Rpb24gKG50aCkge1xuICAgICAgICAgICAgdmFyIHMgPSBudGggJSAxMDA7XG4gICAgICAgICAgICBpZiAocyA+IDMgJiYgcyA8IDIxKVxuICAgICAgICAgICAgICAgIHJldHVybiBcInRoXCI7XG4gICAgICAgICAgICBzd2l0Y2ggKHMgJSAxMCkge1xuICAgICAgICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFwic3RcIjtcbiAgICAgICAgICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBcIm5kXCI7XG4gICAgICAgICAgICAgICAgY2FzZSAzOlxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gXCJyZFwiO1xuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBcInRoXCI7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIHJhbmdlU2VwYXJhdG9yOiBcIiB0byBcIixcbiAgICAgICAgd2Vla0FiYnJldmlhdGlvbjogXCJXa1wiLFxuICAgICAgICBzY3JvbGxUaXRsZTogXCJTY3JvbGwgdG8gaW5jcmVtZW50XCIsXG4gICAgICAgIHRvZ2dsZVRpdGxlOiBcIkNsaWNrIHRvIHRvZ2dsZVwiLFxuICAgICAgICBhbVBNOiBbXCJBTVwiLCBcIlBNXCJdLFxuICAgICAgICB5ZWFyQXJpYUxhYmVsOiBcIlllYXJcIixcbiAgICAgICAgaG91ckFyaWFMYWJlbDogXCJIb3VyXCIsXG4gICAgICAgIG1pbnV0ZUFyaWFMYWJlbDogXCJNaW51dGVcIixcbiAgICAgICAgdGltZV8yNGhyOiBmYWxzZVxuICAgIH07XG5cbiAgICB2YXIgcGFkID0gZnVuY3Rpb24gKG51bWJlcikgeyByZXR1cm4gKFwiMFwiICsgbnVtYmVyKS5zbGljZSgtMik7IH07XG4gICAgdmFyIGludCA9IGZ1bmN0aW9uIChib29sKSB7IHJldHVybiAoYm9vbCA9PT0gdHJ1ZSA/IDEgOiAwKTsgfTtcbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuICAgIGZ1bmN0aW9uIGRlYm91bmNlKGZ1bmMsIHdhaXQsIGltbWVkaWF0ZSkge1xuICAgICAgICBpZiAoaW1tZWRpYXRlID09PSB2b2lkIDApIHsgaW1tZWRpYXRlID0gZmFsc2U7IH1cbiAgICAgICAgdmFyIHRpbWVvdXQ7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgY29udGV4dCA9IHRoaXMsIGFyZ3MgPSBhcmd1bWVudHM7XG4gICAgICAgICAgICB0aW1lb3V0ICE9PSBudWxsICYmIGNsZWFyVGltZW91dCh0aW1lb3V0KTtcbiAgICAgICAgICAgIHRpbWVvdXQgPSB3aW5kb3cuc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgdGltZW91dCA9IG51bGw7XG4gICAgICAgICAgICAgICAgaWYgKCFpbW1lZGlhdGUpXG4gICAgICAgICAgICAgICAgICAgIGZ1bmMuYXBwbHkoY29udGV4dCwgYXJncyk7XG4gICAgICAgICAgICB9LCB3YWl0KTtcbiAgICAgICAgICAgIGlmIChpbW1lZGlhdGUgJiYgIXRpbWVvdXQpXG4gICAgICAgICAgICAgICAgZnVuYy5hcHBseShjb250ZXh0LCBhcmdzKTtcbiAgICAgICAgfTtcbiAgICB9XG4gICAgdmFyIGFycmF5aWZ5ID0gZnVuY3Rpb24gKG9iaikge1xuICAgICAgICByZXR1cm4gb2JqIGluc3RhbmNlb2YgQXJyYXkgPyBvYmogOiBbb2JqXTtcbiAgICB9O1xuXG4gICAgZnVuY3Rpb24gdG9nZ2xlQ2xhc3MoZWxlbSwgY2xhc3NOYW1lLCBib29sKSB7XG4gICAgICAgIGlmIChib29sID09PSB0cnVlKVxuICAgICAgICAgICAgcmV0dXJuIGVsZW0uY2xhc3NMaXN0LmFkZChjbGFzc05hbWUpO1xuICAgICAgICBlbGVtLmNsYXNzTGlzdC5yZW1vdmUoY2xhc3NOYW1lKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gY3JlYXRlRWxlbWVudCh0YWcsIGNsYXNzTmFtZSwgY29udGVudCkge1xuICAgICAgICB2YXIgZSA9IHdpbmRvdy5kb2N1bWVudC5jcmVhdGVFbGVtZW50KHRhZyk7XG4gICAgICAgIGNsYXNzTmFtZSA9IGNsYXNzTmFtZSB8fCBcIlwiO1xuICAgICAgICBjb250ZW50ID0gY29udGVudCB8fCBcIlwiO1xuICAgICAgICBlLmNsYXNzTmFtZSA9IGNsYXNzTmFtZTtcbiAgICAgICAgaWYgKGNvbnRlbnQgIT09IHVuZGVmaW5lZClcbiAgICAgICAgICAgIGUudGV4dENvbnRlbnQgPSBjb250ZW50O1xuICAgICAgICByZXR1cm4gZTtcbiAgICB9XG4gICAgZnVuY3Rpb24gY2xlYXJOb2RlKG5vZGUpIHtcbiAgICAgICAgd2hpbGUgKG5vZGUuZmlyc3RDaGlsZClcbiAgICAgICAgICAgIG5vZGUucmVtb3ZlQ2hpbGQobm9kZS5maXJzdENoaWxkKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gZmluZFBhcmVudChub2RlLCBjb25kaXRpb24pIHtcbiAgICAgICAgaWYgKGNvbmRpdGlvbihub2RlKSlcbiAgICAgICAgICAgIHJldHVybiBub2RlO1xuICAgICAgICBlbHNlIGlmIChub2RlLnBhcmVudE5vZGUpXG4gICAgICAgICAgICByZXR1cm4gZmluZFBhcmVudChub2RlLnBhcmVudE5vZGUsIGNvbmRpdGlvbik7XG4gICAgICAgIHJldHVybiB1bmRlZmluZWQ7IC8vIG5vdGhpbmcgZm91bmRcbiAgICB9XG4gICAgZnVuY3Rpb24gY3JlYXRlTnVtYmVySW5wdXQoaW5wdXRDbGFzc05hbWUsIG9wdHMpIHtcbiAgICAgICAgdmFyIHdyYXBwZXIgPSBjcmVhdGVFbGVtZW50KFwiZGl2XCIsIFwibnVtSW5wdXRXcmFwcGVyXCIpLCBudW1JbnB1dCA9IGNyZWF0ZUVsZW1lbnQoXCJpbnB1dFwiLCBcIm51bUlucHV0IFwiICsgaW5wdXRDbGFzc05hbWUpLCBhcnJvd1VwID0gY3JlYXRlRWxlbWVudChcInNwYW5cIiwgXCJhcnJvd1VwXCIpLCBhcnJvd0Rvd24gPSBjcmVhdGVFbGVtZW50KFwic3BhblwiLCBcImFycm93RG93blwiKTtcbiAgICAgICAgaWYgKG5hdmlnYXRvci51c2VyQWdlbnQuaW5kZXhPZihcIk1TSUUgOS4wXCIpID09PSAtMSkge1xuICAgICAgICAgICAgbnVtSW5wdXQudHlwZSA9IFwibnVtYmVyXCI7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBudW1JbnB1dC50eXBlID0gXCJ0ZXh0XCI7XG4gICAgICAgICAgICBudW1JbnB1dC5wYXR0ZXJuID0gXCJcXFxcZCpcIjtcbiAgICAgICAgfVxuICAgICAgICBpZiAob3B0cyAhPT0gdW5kZWZpbmVkKVxuICAgICAgICAgICAgZm9yICh2YXIga2V5IGluIG9wdHMpXG4gICAgICAgICAgICAgICAgbnVtSW5wdXQuc2V0QXR0cmlidXRlKGtleSwgb3B0c1trZXldKTtcbiAgICAgICAgd3JhcHBlci5hcHBlbmRDaGlsZChudW1JbnB1dCk7XG4gICAgICAgIHdyYXBwZXIuYXBwZW5kQ2hpbGQoYXJyb3dVcCk7XG4gICAgICAgIHdyYXBwZXIuYXBwZW5kQ2hpbGQoYXJyb3dEb3duKTtcbiAgICAgICAgcmV0dXJuIHdyYXBwZXI7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGdldEV2ZW50VGFyZ2V0KGV2ZW50KSB7XG4gICAgICAgIGlmICh0eXBlb2YgZXZlbnQuY29tcG9zZWRQYXRoID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgICAgIHZhciBwYXRoID0gZXZlbnQuY29tcG9zZWRQYXRoKCk7XG4gICAgICAgICAgICByZXR1cm4gcGF0aFswXTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZXZlbnQudGFyZ2V0O1xuICAgIH1cblxuICAgIHZhciBkb05vdGhpbmcgPSBmdW5jdGlvbiAoKSB7IHJldHVybiB1bmRlZmluZWQ7IH07XG4gICAgdmFyIG1vbnRoVG9TdHIgPSBmdW5jdGlvbiAobW9udGhOdW1iZXIsIHNob3J0aGFuZCwgbG9jYWxlKSB7IHJldHVybiBsb2NhbGUubW9udGhzW3Nob3J0aGFuZCA/IFwic2hvcnRoYW5kXCIgOiBcImxvbmdoYW5kXCJdW21vbnRoTnVtYmVyXTsgfTtcbiAgICB2YXIgcmV2Rm9ybWF0ID0ge1xuICAgICAgICBEOiBkb05vdGhpbmcsXG4gICAgICAgIEY6IGZ1bmN0aW9uIChkYXRlT2JqLCBtb250aE5hbWUsIGxvY2FsZSkge1xuICAgICAgICAgICAgZGF0ZU9iai5zZXRNb250aChsb2NhbGUubW9udGhzLmxvbmdoYW5kLmluZGV4T2YobW9udGhOYW1lKSk7XG4gICAgICAgIH0sXG4gICAgICAgIEc6IGZ1bmN0aW9uIChkYXRlT2JqLCBob3VyKSB7XG4gICAgICAgICAgICBkYXRlT2JqLnNldEhvdXJzKHBhcnNlRmxvYXQoaG91cikpO1xuICAgICAgICB9LFxuICAgICAgICBIOiBmdW5jdGlvbiAoZGF0ZU9iaiwgaG91cikge1xuICAgICAgICAgICAgZGF0ZU9iai5zZXRIb3VycyhwYXJzZUZsb2F0KGhvdXIpKTtcbiAgICAgICAgfSxcbiAgICAgICAgSjogZnVuY3Rpb24gKGRhdGVPYmosIGRheSkge1xuICAgICAgICAgICAgZGF0ZU9iai5zZXREYXRlKHBhcnNlRmxvYXQoZGF5KSk7XG4gICAgICAgIH0sXG4gICAgICAgIEs6IGZ1bmN0aW9uIChkYXRlT2JqLCBhbVBNLCBsb2NhbGUpIHtcbiAgICAgICAgICAgIGRhdGVPYmouc2V0SG91cnMoKGRhdGVPYmouZ2V0SG91cnMoKSAlIDEyKSArXG4gICAgICAgICAgICAgICAgMTIgKiBpbnQobmV3IFJlZ0V4cChsb2NhbGUuYW1QTVsxXSwgXCJpXCIpLnRlc3QoYW1QTSkpKTtcbiAgICAgICAgfSxcbiAgICAgICAgTTogZnVuY3Rpb24gKGRhdGVPYmosIHNob3J0TW9udGgsIGxvY2FsZSkge1xuICAgICAgICAgICAgZGF0ZU9iai5zZXRNb250aChsb2NhbGUubW9udGhzLnNob3J0aGFuZC5pbmRleE9mKHNob3J0TW9udGgpKTtcbiAgICAgICAgfSxcbiAgICAgICAgUzogZnVuY3Rpb24gKGRhdGVPYmosIHNlY29uZHMpIHtcbiAgICAgICAgICAgIGRhdGVPYmouc2V0U2Vjb25kcyhwYXJzZUZsb2F0KHNlY29uZHMpKTtcbiAgICAgICAgfSxcbiAgICAgICAgVTogZnVuY3Rpb24gKF8sIHVuaXhTZWNvbmRzKSB7IHJldHVybiBuZXcgRGF0ZShwYXJzZUZsb2F0KHVuaXhTZWNvbmRzKSAqIDEwMDApOyB9LFxuICAgICAgICBXOiBmdW5jdGlvbiAoZGF0ZU9iaiwgd2Vla051bSwgbG9jYWxlKSB7XG4gICAgICAgICAgICB2YXIgd2Vla051bWJlciA9IHBhcnNlSW50KHdlZWtOdW0pO1xuICAgICAgICAgICAgdmFyIGRhdGUgPSBuZXcgRGF0ZShkYXRlT2JqLmdldEZ1bGxZZWFyKCksIDAsIDIgKyAod2Vla051bWJlciAtIDEpICogNywgMCwgMCwgMCwgMCk7XG4gICAgICAgICAgICBkYXRlLnNldERhdGUoZGF0ZS5nZXREYXRlKCkgLSBkYXRlLmdldERheSgpICsgbG9jYWxlLmZpcnN0RGF5T2ZXZWVrKTtcbiAgICAgICAgICAgIHJldHVybiBkYXRlO1xuICAgICAgICB9LFxuICAgICAgICBZOiBmdW5jdGlvbiAoZGF0ZU9iaiwgeWVhcikge1xuICAgICAgICAgICAgZGF0ZU9iai5zZXRGdWxsWWVhcihwYXJzZUZsb2F0KHllYXIpKTtcbiAgICAgICAgfSxcbiAgICAgICAgWjogZnVuY3Rpb24gKF8sIElTT0RhdGUpIHsgcmV0dXJuIG5ldyBEYXRlKElTT0RhdGUpOyB9LFxuICAgICAgICBkOiBmdW5jdGlvbiAoZGF0ZU9iaiwgZGF5KSB7XG4gICAgICAgICAgICBkYXRlT2JqLnNldERhdGUocGFyc2VGbG9hdChkYXkpKTtcbiAgICAgICAgfSxcbiAgICAgICAgaDogZnVuY3Rpb24gKGRhdGVPYmosIGhvdXIpIHtcbiAgICAgICAgICAgIGRhdGVPYmouc2V0SG91cnMocGFyc2VGbG9hdChob3VyKSk7XG4gICAgICAgIH0sXG4gICAgICAgIGk6IGZ1bmN0aW9uIChkYXRlT2JqLCBtaW51dGVzKSB7XG4gICAgICAgICAgICBkYXRlT2JqLnNldE1pbnV0ZXMocGFyc2VGbG9hdChtaW51dGVzKSk7XG4gICAgICAgIH0sXG4gICAgICAgIGo6IGZ1bmN0aW9uIChkYXRlT2JqLCBkYXkpIHtcbiAgICAgICAgICAgIGRhdGVPYmouc2V0RGF0ZShwYXJzZUZsb2F0KGRheSkpO1xuICAgICAgICB9LFxuICAgICAgICBsOiBkb05vdGhpbmcsXG4gICAgICAgIG06IGZ1bmN0aW9uIChkYXRlT2JqLCBtb250aCkge1xuICAgICAgICAgICAgZGF0ZU9iai5zZXRNb250aChwYXJzZUZsb2F0KG1vbnRoKSAtIDEpO1xuICAgICAgICB9LFxuICAgICAgICBuOiBmdW5jdGlvbiAoZGF0ZU9iaiwgbW9udGgpIHtcbiAgICAgICAgICAgIGRhdGVPYmouc2V0TW9udGgocGFyc2VGbG9hdChtb250aCkgLSAxKTtcbiAgICAgICAgfSxcbiAgICAgICAgczogZnVuY3Rpb24gKGRhdGVPYmosIHNlY29uZHMpIHtcbiAgICAgICAgICAgIGRhdGVPYmouc2V0U2Vjb25kcyhwYXJzZUZsb2F0KHNlY29uZHMpKTtcbiAgICAgICAgfSxcbiAgICAgICAgdTogZnVuY3Rpb24gKF8sIHVuaXhNaWxsU2Vjb25kcykge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBEYXRlKHBhcnNlRmxvYXQodW5peE1pbGxTZWNvbmRzKSk7XG4gICAgICAgIH0sXG4gICAgICAgIHc6IGRvTm90aGluZyxcbiAgICAgICAgeTogZnVuY3Rpb24gKGRhdGVPYmosIHllYXIpIHtcbiAgICAgICAgICAgIGRhdGVPYmouc2V0RnVsbFllYXIoMjAwMCArIHBhcnNlRmxvYXQoeWVhcikpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICB2YXIgdG9rZW5SZWdleCA9IHtcbiAgICAgICAgRDogXCIoXFxcXHcrKVwiLFxuICAgICAgICBGOiBcIihcXFxcdyspXCIsXG4gICAgICAgIEc6IFwiKFxcXFxkXFxcXGR8XFxcXGQpXCIsXG4gICAgICAgIEg6IFwiKFxcXFxkXFxcXGR8XFxcXGQpXCIsXG4gICAgICAgIEo6IFwiKFxcXFxkXFxcXGR8XFxcXGQpXFxcXHcrXCIsXG4gICAgICAgIEs6IFwiXCIsXG4gICAgICAgIE06IFwiKFxcXFx3KylcIixcbiAgICAgICAgUzogXCIoXFxcXGRcXFxcZHxcXFxcZClcIixcbiAgICAgICAgVTogXCIoLispXCIsXG4gICAgICAgIFc6IFwiKFxcXFxkXFxcXGR8XFxcXGQpXCIsXG4gICAgICAgIFk6IFwiKFxcXFxkezR9KVwiLFxuICAgICAgICBaOiBcIiguKylcIixcbiAgICAgICAgZDogXCIoXFxcXGRcXFxcZHxcXFxcZClcIixcbiAgICAgICAgaDogXCIoXFxcXGRcXFxcZHxcXFxcZClcIixcbiAgICAgICAgaTogXCIoXFxcXGRcXFxcZHxcXFxcZClcIixcbiAgICAgICAgajogXCIoXFxcXGRcXFxcZHxcXFxcZClcIixcbiAgICAgICAgbDogXCIoXFxcXHcrKVwiLFxuICAgICAgICBtOiBcIihcXFxcZFxcXFxkfFxcXFxkKVwiLFxuICAgICAgICBuOiBcIihcXFxcZFxcXFxkfFxcXFxkKVwiLFxuICAgICAgICBzOiBcIihcXFxcZFxcXFxkfFxcXFxkKVwiLFxuICAgICAgICB1OiBcIiguKylcIixcbiAgICAgICAgdzogXCIoXFxcXGRcXFxcZHxcXFxcZClcIixcbiAgICAgICAgeTogXCIoXFxcXGR7Mn0pXCJcbiAgICB9O1xuICAgIHZhciBmb3JtYXRzID0ge1xuICAgICAgICAvLyBnZXQgdGhlIGRhdGUgaW4gVVRDXG4gICAgICAgIFo6IGZ1bmN0aW9uIChkYXRlKSB7IHJldHVybiBkYXRlLnRvSVNPU3RyaW5nKCk7IH0sXG4gICAgICAgIC8vIHdlZWtkYXkgbmFtZSwgc2hvcnQsIGUuZy4gVGh1XG4gICAgICAgIEQ6IGZ1bmN0aW9uIChkYXRlLCBsb2NhbGUsIG9wdGlvbnMpIHtcbiAgICAgICAgICAgIHJldHVybiBsb2NhbGUud2Vla2RheXMuc2hvcnRoYW5kW2Zvcm1hdHMudyhkYXRlLCBsb2NhbGUsIG9wdGlvbnMpXTtcbiAgICAgICAgfSxcbiAgICAgICAgLy8gZnVsbCBtb250aCBuYW1lIGUuZy4gSmFudWFyeVxuICAgICAgICBGOiBmdW5jdGlvbiAoZGF0ZSwgbG9jYWxlLCBvcHRpb25zKSB7XG4gICAgICAgICAgICByZXR1cm4gbW9udGhUb1N0cihmb3JtYXRzLm4oZGF0ZSwgbG9jYWxlLCBvcHRpb25zKSAtIDEsIGZhbHNlLCBsb2NhbGUpO1xuICAgICAgICB9LFxuICAgICAgICAvLyBwYWRkZWQgaG91ciAxLTEyXG4gICAgICAgIEc6IGZ1bmN0aW9uIChkYXRlLCBsb2NhbGUsIG9wdGlvbnMpIHtcbiAgICAgICAgICAgIHJldHVybiBwYWQoZm9ybWF0cy5oKGRhdGUsIGxvY2FsZSwgb3B0aW9ucykpO1xuICAgICAgICB9LFxuICAgICAgICAvLyBob3VycyB3aXRoIGxlYWRpbmcgemVybyBlLmcuIDAzXG4gICAgICAgIEg6IGZ1bmN0aW9uIChkYXRlKSB7IHJldHVybiBwYWQoZGF0ZS5nZXRIb3VycygpKTsgfSxcbiAgICAgICAgLy8gZGF5ICgxLTMwKSB3aXRoIG9yZGluYWwgc3VmZml4IGUuZy4gMXN0LCAybmRcbiAgICAgICAgSjogZnVuY3Rpb24gKGRhdGUsIGxvY2FsZSkge1xuICAgICAgICAgICAgcmV0dXJuIGxvY2FsZS5vcmRpbmFsICE9PSB1bmRlZmluZWRcbiAgICAgICAgICAgICAgICA/IGRhdGUuZ2V0RGF0ZSgpICsgbG9jYWxlLm9yZGluYWwoZGF0ZS5nZXREYXRlKCkpXG4gICAgICAgICAgICAgICAgOiBkYXRlLmdldERhdGUoKTtcbiAgICAgICAgfSxcbiAgICAgICAgLy8gQU0vUE1cbiAgICAgICAgSzogZnVuY3Rpb24gKGRhdGUsIGxvY2FsZSkgeyByZXR1cm4gbG9jYWxlLmFtUE1baW50KGRhdGUuZ2V0SG91cnMoKSA+IDExKV07IH0sXG4gICAgICAgIC8vIHNob3J0aGFuZCBtb250aCBlLmcuIEphbiwgU2VwLCBPY3QsIGV0Y1xuICAgICAgICBNOiBmdW5jdGlvbiAoZGF0ZSwgbG9jYWxlKSB7XG4gICAgICAgICAgICByZXR1cm4gbW9udGhUb1N0cihkYXRlLmdldE1vbnRoKCksIHRydWUsIGxvY2FsZSk7XG4gICAgICAgIH0sXG4gICAgICAgIC8vIHNlY29uZHMgMDAtNTlcbiAgICAgICAgUzogZnVuY3Rpb24gKGRhdGUpIHsgcmV0dXJuIHBhZChkYXRlLmdldFNlY29uZHMoKSk7IH0sXG4gICAgICAgIC8vIHVuaXggdGltZXN0YW1wXG4gICAgICAgIFU6IGZ1bmN0aW9uIChkYXRlKSB7IHJldHVybiBkYXRlLmdldFRpbWUoKSAvIDEwMDA7IH0sXG4gICAgICAgIFc6IGZ1bmN0aW9uIChkYXRlLCBfLCBvcHRpb25zKSB7XG4gICAgICAgICAgICByZXR1cm4gb3B0aW9ucy5nZXRXZWVrKGRhdGUpO1xuICAgICAgICB9LFxuICAgICAgICAvLyBmdWxsIHllYXIgZS5nLiAyMDE2XG4gICAgICAgIFk6IGZ1bmN0aW9uIChkYXRlKSB7IHJldHVybiBkYXRlLmdldEZ1bGxZZWFyKCk7IH0sXG4gICAgICAgIC8vIGRheSBpbiBtb250aCwgcGFkZGVkICgwMS0zMClcbiAgICAgICAgZDogZnVuY3Rpb24gKGRhdGUpIHsgcmV0dXJuIHBhZChkYXRlLmdldERhdGUoKSk7IH0sXG4gICAgICAgIC8vIGhvdXIgZnJvbSAxLTEyIChhbS9wbSlcbiAgICAgICAgaDogZnVuY3Rpb24gKGRhdGUpIHsgcmV0dXJuIChkYXRlLmdldEhvdXJzKCkgJSAxMiA/IGRhdGUuZ2V0SG91cnMoKSAlIDEyIDogMTIpOyB9LFxuICAgICAgICAvLyBtaW51dGVzLCBwYWRkZWQgd2l0aCBsZWFkaW5nIHplcm8gZS5nLiAwOVxuICAgICAgICBpOiBmdW5jdGlvbiAoZGF0ZSkgeyByZXR1cm4gcGFkKGRhdGUuZ2V0TWludXRlcygpKTsgfSxcbiAgICAgICAgLy8gZGF5IGluIG1vbnRoICgxLTMwKVxuICAgICAgICBqOiBmdW5jdGlvbiAoZGF0ZSkgeyByZXR1cm4gZGF0ZS5nZXREYXRlKCk7IH0sXG4gICAgICAgIC8vIHdlZWtkYXkgbmFtZSwgZnVsbCwgZS5nLiBUaHVyc2RheVxuICAgICAgICBsOiBmdW5jdGlvbiAoZGF0ZSwgbG9jYWxlKSB7XG4gICAgICAgICAgICByZXR1cm4gbG9jYWxlLndlZWtkYXlzLmxvbmdoYW5kW2RhdGUuZ2V0RGF5KCldO1xuICAgICAgICB9LFxuICAgICAgICAvLyBwYWRkZWQgbW9udGggbnVtYmVyICgwMS0xMilcbiAgICAgICAgbTogZnVuY3Rpb24gKGRhdGUpIHsgcmV0dXJuIHBhZChkYXRlLmdldE1vbnRoKCkgKyAxKTsgfSxcbiAgICAgICAgLy8gdGhlIG1vbnRoIG51bWJlciAoMS0xMilcbiAgICAgICAgbjogZnVuY3Rpb24gKGRhdGUpIHsgcmV0dXJuIGRhdGUuZ2V0TW9udGgoKSArIDE7IH0sXG4gICAgICAgIC8vIHNlY29uZHMgMC01OVxuICAgICAgICBzOiBmdW5jdGlvbiAoZGF0ZSkgeyByZXR1cm4gZGF0ZS5nZXRTZWNvbmRzKCk7IH0sXG4gICAgICAgIC8vIFVuaXggTWlsbGlzZWNvbmRzXG4gICAgICAgIHU6IGZ1bmN0aW9uIChkYXRlKSB7IHJldHVybiBkYXRlLmdldFRpbWUoKTsgfSxcbiAgICAgICAgLy8gbnVtYmVyIG9mIHRoZSBkYXkgb2YgdGhlIHdlZWtcbiAgICAgICAgdzogZnVuY3Rpb24gKGRhdGUpIHsgcmV0dXJuIGRhdGUuZ2V0RGF5KCk7IH0sXG4gICAgICAgIC8vIGxhc3QgdHdvIGRpZ2l0cyBvZiB5ZWFyIGUuZy4gMTYgZm9yIDIwMTZcbiAgICAgICAgeTogZnVuY3Rpb24gKGRhdGUpIHsgcmV0dXJuIFN0cmluZyhkYXRlLmdldEZ1bGxZZWFyKCkpLnN1YnN0cmluZygyKTsgfVxuICAgIH07XG5cbiAgICB2YXIgY3JlYXRlRGF0ZUZvcm1hdHRlciA9IGZ1bmN0aW9uIChfYSkge1xuICAgICAgICB2YXIgX2IgPSBfYS5jb25maWcsIGNvbmZpZyA9IF9iID09PSB2b2lkIDAgPyBkZWZhdWx0cyA6IF9iLCBfYyA9IF9hLmwxMG4sIGwxMG4gPSBfYyA9PT0gdm9pZCAwID8gZW5nbGlzaCA6IF9jO1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKGRhdGVPYmosIGZybXQsIG92ZXJyaWRlTG9jYWxlKSB7XG4gICAgICAgICAgICB2YXIgbG9jYWxlID0gb3ZlcnJpZGVMb2NhbGUgfHwgbDEwbjtcbiAgICAgICAgICAgIGlmIChjb25maWcuZm9ybWF0RGF0ZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGNvbmZpZy5mb3JtYXREYXRlKGRhdGVPYmosIGZybXQsIGxvY2FsZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gZnJtdFxuICAgICAgICAgICAgICAgIC5zcGxpdChcIlwiKVxuICAgICAgICAgICAgICAgIC5tYXAoZnVuY3Rpb24gKGMsIGksIGFycikge1xuICAgICAgICAgICAgICAgIHJldHVybiBmb3JtYXRzW2NdICYmIGFycltpIC0gMV0gIT09IFwiXFxcXFwiXG4gICAgICAgICAgICAgICAgICAgID8gZm9ybWF0c1tjXShkYXRlT2JqLCBsb2NhbGUsIGNvbmZpZylcbiAgICAgICAgICAgICAgICAgICAgOiBjICE9PSBcIlxcXFxcIlxuICAgICAgICAgICAgICAgICAgICAgICAgPyBjXG4gICAgICAgICAgICAgICAgICAgICAgICA6IFwiXCI7XG4gICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgIC5qb2luKFwiXCIpO1xuICAgICAgICB9O1xuICAgIH07XG4gICAgdmFyIGNyZWF0ZURhdGVQYXJzZXIgPSBmdW5jdGlvbiAoX2EpIHtcbiAgICAgICAgdmFyIF9iID0gX2EuY29uZmlnLCBjb25maWcgPSBfYiA9PT0gdm9pZCAwID8gZGVmYXVsdHMgOiBfYiwgX2MgPSBfYS5sMTBuLCBsMTBuID0gX2MgPT09IHZvaWQgMCA/IGVuZ2xpc2ggOiBfYztcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIChkYXRlLCBnaXZlbkZvcm1hdCwgdGltZWxlc3MsIGN1c3RvbUxvY2FsZSkge1xuICAgICAgICAgICAgaWYgKGRhdGUgIT09IDAgJiYgIWRhdGUpXG4gICAgICAgICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgICAgICAgIHZhciBsb2NhbGUgPSBjdXN0b21Mb2NhbGUgfHwgbDEwbjtcbiAgICAgICAgICAgIHZhciBwYXJzZWREYXRlO1xuICAgICAgICAgICAgdmFyIGRhdGVPcmlnID0gZGF0ZTtcbiAgICAgICAgICAgIGlmIChkYXRlIGluc3RhbmNlb2YgRGF0ZSlcbiAgICAgICAgICAgICAgICBwYXJzZWREYXRlID0gbmV3IERhdGUoZGF0ZS5nZXRUaW1lKCkpO1xuICAgICAgICAgICAgZWxzZSBpZiAodHlwZW9mIGRhdGUgIT09IFwic3RyaW5nXCIgJiZcbiAgICAgICAgICAgICAgICBkYXRlLnRvRml4ZWQgIT09IHVuZGVmaW5lZCAvLyB0aW1lc3RhbXBcbiAgICAgICAgICAgIClcbiAgICAgICAgICAgICAgICAvLyBjcmVhdGUgYSBjb3B5XG4gICAgICAgICAgICAgICAgcGFyc2VkRGF0ZSA9IG5ldyBEYXRlKGRhdGUpO1xuICAgICAgICAgICAgZWxzZSBpZiAodHlwZW9mIGRhdGUgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICAgICAgICAvLyBkYXRlIHN0cmluZ1xuICAgICAgICAgICAgICAgIHZhciBmb3JtYXQgPSBnaXZlbkZvcm1hdCB8fCAoY29uZmlnIHx8IGRlZmF1bHRzKS5kYXRlRm9ybWF0O1xuICAgICAgICAgICAgICAgIHZhciBkYXRlc3RyID0gU3RyaW5nKGRhdGUpLnRyaW0oKTtcbiAgICAgICAgICAgICAgICBpZiAoZGF0ZXN0ciA9PT0gXCJ0b2RheVwiKSB7XG4gICAgICAgICAgICAgICAgICAgIHBhcnNlZERhdGUgPSBuZXcgRGF0ZSgpO1xuICAgICAgICAgICAgICAgICAgICB0aW1lbGVzcyA9IHRydWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKC9aJC8udGVzdChkYXRlc3RyKSB8fFxuICAgICAgICAgICAgICAgICAgICAvR01UJC8udGVzdChkYXRlc3RyKSAvLyBkYXRlc3RyaW5ncyB3LyB0aW1lem9uZVxuICAgICAgICAgICAgICAgIClcbiAgICAgICAgICAgICAgICAgICAgcGFyc2VkRGF0ZSA9IG5ldyBEYXRlKGRhdGUpO1xuICAgICAgICAgICAgICAgIGVsc2UgaWYgKGNvbmZpZyAmJiBjb25maWcucGFyc2VEYXRlKVxuICAgICAgICAgICAgICAgICAgICBwYXJzZWREYXRlID0gY29uZmlnLnBhcnNlRGF0ZShkYXRlLCBmb3JtYXQpO1xuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBwYXJzZWREYXRlID1cbiAgICAgICAgICAgICAgICAgICAgICAgICFjb25maWcgfHwgIWNvbmZpZy5ub0NhbGVuZGFyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPyBuZXcgRGF0ZShuZXcgRGF0ZSgpLmdldEZ1bGxZZWFyKCksIDAsIDEsIDAsIDAsIDAsIDApXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgOiBuZXcgRGF0ZShuZXcgRGF0ZSgpLnNldEhvdXJzKDAsIDAsIDAsIDApKTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIG1hdGNoZWQgPSB2b2lkIDAsIG9wcyA9IFtdO1xuICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMCwgbWF0Y2hJbmRleCA9IDAsIHJlZ2V4U3RyID0gXCJcIjsgaSA8IGZvcm1hdC5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHRva2VuXzEgPSBmb3JtYXRbaV07XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgaXNCYWNrU2xhc2ggPSB0b2tlbl8xID09PSBcIlxcXFxcIjtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBlc2NhcGVkID0gZm9ybWF0W2kgLSAxXSA9PT0gXCJcXFxcXCIgfHwgaXNCYWNrU2xhc2g7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodG9rZW5SZWdleFt0b2tlbl8xXSAmJiAhZXNjYXBlZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlZ2V4U3RyICs9IHRva2VuUmVnZXhbdG9rZW5fMV07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIG1hdGNoID0gbmV3IFJlZ0V4cChyZWdleFN0cikuZXhlYyhkYXRlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAobWF0Y2ggJiYgKG1hdGNoZWQgPSB0cnVlKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvcHNbdG9rZW5fMSAhPT0gXCJZXCIgPyBcInB1c2hcIiA6IFwidW5zaGlmdFwiXSh7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmbjogcmV2Rm9ybWF0W3Rva2VuXzFdLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFsOiBtYXRjaFsrK21hdGNoSW5kZXhdXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKCFpc0JhY2tTbGFzaClcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZWdleFN0ciArPSBcIi5cIjsgLy8gZG9uJ3QgcmVhbGx5IGNhcmVcbiAgICAgICAgICAgICAgICAgICAgICAgIG9wcy5mb3JFYWNoKGZ1bmN0aW9uIChfYSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBmbiA9IF9hLmZuLCB2YWwgPSBfYS52YWw7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIChwYXJzZWREYXRlID0gZm4ocGFyc2VkRGF0ZSwgdmFsLCBsb2NhbGUpIHx8IHBhcnNlZERhdGUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcGFyc2VkRGF0ZSA9IG1hdGNoZWQgPyBwYXJzZWREYXRlIDogdW5kZWZpbmVkO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG4gICAgICAgICAgICBpZiAoIShwYXJzZWREYXRlIGluc3RhbmNlb2YgRGF0ZSAmJiAhaXNOYU4ocGFyc2VkRGF0ZS5nZXRUaW1lKCkpKSkge1xuICAgICAgICAgICAgICAgIGNvbmZpZy5lcnJvckhhbmRsZXIobmV3IEVycm9yKFwiSW52YWxpZCBkYXRlIHByb3ZpZGVkOiBcIiArIGRhdGVPcmlnKSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0aW1lbGVzcyA9PT0gdHJ1ZSlcbiAgICAgICAgICAgICAgICBwYXJzZWREYXRlLnNldEhvdXJzKDAsIDAsIDAsIDApO1xuICAgICAgICAgICAgcmV0dXJuIHBhcnNlZERhdGU7XG4gICAgICAgIH07XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBDb21wdXRlIHRoZSBkaWZmZXJlbmNlIGluIGRhdGVzLCBtZWFzdXJlZCBpbiBtc1xuICAgICAqL1xuICAgIGZ1bmN0aW9uIGNvbXBhcmVEYXRlcyhkYXRlMSwgZGF0ZTIsIHRpbWVsZXNzKSB7XG4gICAgICAgIGlmICh0aW1lbGVzcyA9PT0gdm9pZCAwKSB7IHRpbWVsZXNzID0gdHJ1ZTsgfVxuICAgICAgICBpZiAodGltZWxlc3MgIT09IGZhbHNlKSB7XG4gICAgICAgICAgICByZXR1cm4gKG5ldyBEYXRlKGRhdGUxLmdldFRpbWUoKSkuc2V0SG91cnMoMCwgMCwgMCwgMCkgLVxuICAgICAgICAgICAgICAgIG5ldyBEYXRlKGRhdGUyLmdldFRpbWUoKSkuc2V0SG91cnMoMCwgMCwgMCwgMCkpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBkYXRlMS5nZXRUaW1lKCkgLSBkYXRlMi5nZXRUaW1lKCk7XG4gICAgfVxuICAgIHZhciBpc0JldHdlZW4gPSBmdW5jdGlvbiAodHMsIHRzMSwgdHMyKSB7XG4gICAgICAgIHJldHVybiB0cyA+IE1hdGgubWluKHRzMSwgdHMyKSAmJiB0cyA8IE1hdGgubWF4KHRzMSwgdHMyKTtcbiAgICB9O1xuICAgIHZhciBkdXJhdGlvbiA9IHtcbiAgICAgICAgREFZOiA4NjQwMDAwMFxuICAgIH07XG5cbiAgICBpZiAodHlwZW9mIE9iamVjdC5hc3NpZ24gIT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICBPYmplY3QuYXNzaWduID0gZnVuY3Rpb24gKHRhcmdldCkge1xuICAgICAgICAgICAgdmFyIGFyZ3MgPSBbXTtcbiAgICAgICAgICAgIGZvciAodmFyIF9pID0gMTsgX2kgPCBhcmd1bWVudHMubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgICAgICAgICAgYXJnc1tfaSAtIDFdID0gYXJndW1lbnRzW19pXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghdGFyZ2V0KSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgVHlwZUVycm9yKFwiQ2Fubm90IGNvbnZlcnQgdW5kZWZpbmVkIG9yIG51bGwgdG8gb2JqZWN0XCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIF9sb29wXzEgPSBmdW5jdGlvbiAoc291cmNlKSB7XG4gICAgICAgICAgICAgICAgaWYgKHNvdXJjZSkge1xuICAgICAgICAgICAgICAgICAgICBPYmplY3Qua2V5cyhzb3VyY2UpLmZvckVhY2goZnVuY3Rpb24gKGtleSkgeyByZXR1cm4gKHRhcmdldFtrZXldID0gc291cmNlW2tleV0pOyB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgZm9yICh2YXIgX2EgPSAwLCBhcmdzXzEgPSBhcmdzOyBfYSA8IGFyZ3NfMS5sZW5ndGg7IF9hKyspIHtcbiAgICAgICAgICAgICAgICB2YXIgc291cmNlID0gYXJnc18xW19hXTtcbiAgICAgICAgICAgICAgICBfbG9vcF8xKHNvdXJjZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdGFyZ2V0O1xuICAgICAgICB9O1xuICAgIH1cblxuICAgIHZhciBERUJPVU5DRURfQ0hBTkdFX01TID0gMzAwO1xuICAgIGZ1bmN0aW9uIEZsYXRwaWNrckluc3RhbmNlKGVsZW1lbnQsIGluc3RhbmNlQ29uZmlnKSB7XG4gICAgICAgIHZhciBzZWxmID0ge1xuICAgICAgICAgICAgY29uZmlnOiBfX2Fzc2lnbih7fSwgZGVmYXVsdHMsIGZsYXRwaWNrci5kZWZhdWx0Q29uZmlnKSxcbiAgICAgICAgICAgIGwxMG46IGVuZ2xpc2hcbiAgICAgICAgfTtcbiAgICAgICAgc2VsZi5wYXJzZURhdGUgPSBjcmVhdGVEYXRlUGFyc2VyKHsgY29uZmlnOiBzZWxmLmNvbmZpZywgbDEwbjogc2VsZi5sMTBuIH0pO1xuICAgICAgICBzZWxmLl9oYW5kbGVycyA9IFtdO1xuICAgICAgICBzZWxmLnBsdWdpbkVsZW1lbnRzID0gW107XG4gICAgICAgIHNlbGYubG9hZGVkUGx1Z2lucyA9IFtdO1xuICAgICAgICBzZWxmLl9iaW5kID0gYmluZDtcbiAgICAgICAgc2VsZi5fc2V0SG91cnNGcm9tRGF0ZSA9IHNldEhvdXJzRnJvbURhdGU7XG4gICAgICAgIHNlbGYuX3Bvc2l0aW9uQ2FsZW5kYXIgPSBwb3NpdGlvbkNhbGVuZGFyO1xuICAgICAgICBzZWxmLmNoYW5nZU1vbnRoID0gY2hhbmdlTW9udGg7XG4gICAgICAgIHNlbGYuY2hhbmdlWWVhciA9IGNoYW5nZVllYXI7XG4gICAgICAgIHNlbGYuY2xlYXIgPSBjbGVhcjtcbiAgICAgICAgc2VsZi5jbG9zZSA9IGNsb3NlO1xuICAgICAgICBzZWxmLl9jcmVhdGVFbGVtZW50ID0gY3JlYXRlRWxlbWVudDtcbiAgICAgICAgc2VsZi5kZXN0cm95ID0gZGVzdHJveTtcbiAgICAgICAgc2VsZi5pc0VuYWJsZWQgPSBpc0VuYWJsZWQ7XG4gICAgICAgIHNlbGYuanVtcFRvRGF0ZSA9IGp1bXBUb0RhdGU7XG4gICAgICAgIHNlbGYub3BlbiA9IG9wZW47XG4gICAgICAgIHNlbGYucmVkcmF3ID0gcmVkcmF3O1xuICAgICAgICBzZWxmLnNldCA9IHNldDtcbiAgICAgICAgc2VsZi5zZXREYXRlID0gc2V0RGF0ZTtcbiAgICAgICAgc2VsZi50b2dnbGUgPSB0b2dnbGU7XG4gICAgICAgIGZ1bmN0aW9uIHNldHVwSGVscGVyRnVuY3Rpb25zKCkge1xuICAgICAgICAgICAgc2VsZi51dGlscyA9IHtcbiAgICAgICAgICAgICAgICBnZXREYXlzSW5Nb250aDogZnVuY3Rpb24gKG1vbnRoLCB5cikge1xuICAgICAgICAgICAgICAgICAgICBpZiAobW9udGggPT09IHZvaWQgMCkgeyBtb250aCA9IHNlbGYuY3VycmVudE1vbnRoOyB9XG4gICAgICAgICAgICAgICAgICAgIGlmICh5ciA9PT0gdm9pZCAwKSB7IHlyID0gc2VsZi5jdXJyZW50WWVhcjsgfVxuICAgICAgICAgICAgICAgICAgICBpZiAobW9udGggPT09IDEgJiYgKCh5ciAlIDQgPT09IDAgJiYgeXIgJSAxMDAgIT09IDApIHx8IHlyICUgNDAwID09PSAwKSlcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiAyOTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHNlbGYubDEwbi5kYXlzSW5Nb250aFttb250aF07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiBpbml0KCkge1xuICAgICAgICAgICAgc2VsZi5lbGVtZW50ID0gc2VsZi5pbnB1dCA9IGVsZW1lbnQ7XG4gICAgICAgICAgICBzZWxmLmlzT3BlbiA9IGZhbHNlO1xuICAgICAgICAgICAgcGFyc2VDb25maWcoKTtcbiAgICAgICAgICAgIHNldHVwTG9jYWxlKCk7XG4gICAgICAgICAgICBzZXR1cElucHV0cygpO1xuICAgICAgICAgICAgc2V0dXBEYXRlcygpO1xuICAgICAgICAgICAgc2V0dXBIZWxwZXJGdW5jdGlvbnMoKTtcbiAgICAgICAgICAgIGlmICghc2VsZi5pc01vYmlsZSlcbiAgICAgICAgICAgICAgICBidWlsZCgpO1xuICAgICAgICAgICAgYmluZEV2ZW50cygpO1xuICAgICAgICAgICAgaWYgKHNlbGYuc2VsZWN0ZWREYXRlcy5sZW5ndGggfHwgc2VsZi5jb25maWcubm9DYWxlbmRhcikge1xuICAgICAgICAgICAgICAgIGlmIChzZWxmLmNvbmZpZy5lbmFibGVUaW1lKSB7XG4gICAgICAgICAgICAgICAgICAgIHNldEhvdXJzRnJvbURhdGUoc2VsZi5jb25maWcubm9DYWxlbmRhclxuICAgICAgICAgICAgICAgICAgICAgICAgPyBzZWxmLmxhdGVzdFNlbGVjdGVkRGF0ZU9iaiB8fCBzZWxmLmNvbmZpZy5taW5EYXRlXG4gICAgICAgICAgICAgICAgICAgICAgICA6IHVuZGVmaW5lZCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHVwZGF0ZVZhbHVlKGZhbHNlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHNldENhbGVuZGFyV2lkdGgoKTtcbiAgICAgICAgICAgIHNlbGYuc2hvd1RpbWVJbnB1dCA9XG4gICAgICAgICAgICAgICAgc2VsZi5zZWxlY3RlZERhdGVzLmxlbmd0aCA+IDAgfHwgc2VsZi5jb25maWcubm9DYWxlbmRhcjtcbiAgICAgICAgICAgIHZhciBpc1NhZmFyaSA9IC9eKCg/IWNocm9tZXxhbmRyb2lkKS4pKnNhZmFyaS9pLnRlc3QobmF2aWdhdG9yLnVzZXJBZ2VudCk7XG4gICAgICAgICAgICAvKiBUT0RPOiBpbnZlc3RpZ2F0ZSB0aGlzIGZ1cnRoZXJcbiAgICAgICAgXG4gICAgICAgICAgICAgIEN1cnJlbnRseSwgdGhlcmUgaXMgd2VpcmQgcG9zaXRpb25pbmcgYmVoYXZpb3IgaW4gc2FmYXJpIGNhdXNpbmcgcGFnZXNcbiAgICAgICAgICAgICAgdG8gc2Nyb2xsIHVwLiBodHRwczovL2dpdGh1Yi5jb20vY2htbG4vZmxhdHBpY2tyL2lzc3Vlcy81NjNcbiAgICAgICAgXG4gICAgICAgICAgICAgIEhvd2V2ZXIsIG1vc3QgYnJvd3NlcnMgYXJlIG5vdCBTYWZhcmkgYW5kIHBvc2l0aW9uaW5nIGlzIGV4cGVuc2l2ZSB3aGVuIHVzZWRcbiAgICAgICAgICAgICAgaW4gc2NhbGUuIGh0dHBzOi8vZ2l0aHViLmNvbS9jaG1sbi9mbGF0cGlja3IvaXNzdWVzLzEwOTZcbiAgICAgICAgICAgICovXG4gICAgICAgICAgICBpZiAoIXNlbGYuaXNNb2JpbGUgJiYgaXNTYWZhcmkpIHtcbiAgICAgICAgICAgICAgICBwb3NpdGlvbkNhbGVuZGFyKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0cmlnZ2VyRXZlbnQoXCJvblJlYWR5XCIpO1xuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIGJpbmRUb0luc3RhbmNlKGZuKSB7XG4gICAgICAgICAgICByZXR1cm4gZm4uYmluZChzZWxmKTtcbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiBzZXRDYWxlbmRhcldpZHRoKCkge1xuICAgICAgICAgICAgdmFyIGNvbmZpZyA9IHNlbGYuY29uZmlnO1xuICAgICAgICAgICAgaWYgKGNvbmZpZy53ZWVrTnVtYmVycyA9PT0gZmFsc2UgJiYgY29uZmlnLnNob3dNb250aHMgPT09IDEpXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgZWxzZSBpZiAoY29uZmlnLm5vQ2FsZW5kYXIgIT09IHRydWUpIHtcbiAgICAgICAgICAgICAgICB3aW5kb3cucmVxdWVzdEFuaW1hdGlvbkZyYW1lKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHNlbGYuY2FsZW5kYXJDb250YWluZXIgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgc2VsZi5jYWxlbmRhckNvbnRhaW5lci5zdHlsZS52aXNpYmlsaXR5ID0gXCJoaWRkZW5cIjtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNlbGYuY2FsZW5kYXJDb250YWluZXIuc3R5bGUuZGlzcGxheSA9IFwiYmxvY2tcIjtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAoc2VsZi5kYXlzQ29udGFpbmVyICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBkYXlzV2lkdGggPSAoc2VsZi5kYXlzLm9mZnNldFdpZHRoICsgMSkgKiBjb25maWcuc2hvd01vbnRocztcbiAgICAgICAgICAgICAgICAgICAgICAgIHNlbGYuZGF5c0NvbnRhaW5lci5zdHlsZS53aWR0aCA9IGRheXNXaWR0aCArIFwicHhcIjtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNlbGYuY2FsZW5kYXJDb250YWluZXIuc3R5bGUud2lkdGggPVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRheXNXaWR0aCArXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIChzZWxmLndlZWtXcmFwcGVyICE9PSB1bmRlZmluZWRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgID8gc2VsZi53ZWVrV3JhcHBlci5vZmZzZXRXaWR0aFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgOiAwKSArXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwicHhcIjtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNlbGYuY2FsZW5kYXJDb250YWluZXIuc3R5bGUucmVtb3ZlUHJvcGVydHkoXCJ2aXNpYmlsaXR5XCIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgc2VsZi5jYWxlbmRhckNvbnRhaW5lci5zdHlsZS5yZW1vdmVQcm9wZXJ0eShcImRpc3BsYXlcIik7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIGhhbmRsZXIgZm9yIGFsbCBldmVudHMgdGFyZ2V0aW5nIHRoZSB0aW1lIGlucHV0c1xuICAgICAgICAgKi9cbiAgICAgICAgZnVuY3Rpb24gdXBkYXRlVGltZShlKSB7XG4gICAgICAgICAgICBpZiAoc2VsZi5zZWxlY3RlZERhdGVzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgICAgIHNldERlZmF1bHRUaW1lKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoZSAhPT0gdW5kZWZpbmVkICYmIGUudHlwZSAhPT0gXCJibHVyXCIpIHtcbiAgICAgICAgICAgICAgICB0aW1lV3JhcHBlcihlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciBwcmV2VmFsdWUgPSBzZWxmLl9pbnB1dC52YWx1ZTtcbiAgICAgICAgICAgIHNldEhvdXJzRnJvbUlucHV0cygpO1xuICAgICAgICAgICAgdXBkYXRlVmFsdWUoKTtcbiAgICAgICAgICAgIGlmIChzZWxmLl9pbnB1dC52YWx1ZSAhPT0gcHJldlZhbHVlKSB7XG4gICAgICAgICAgICAgICAgc2VsZi5fZGVib3VuY2VkQ2hhbmdlKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gYW1wbTJtaWxpdGFyeShob3VyLCBhbVBNKSB7XG4gICAgICAgICAgICByZXR1cm4gKGhvdXIgJSAxMikgKyAxMiAqIGludChhbVBNID09PSBzZWxmLmwxMG4uYW1QTVsxXSk7XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gbWlsaXRhcnkyYW1wbShob3VyKSB7XG4gICAgICAgICAgICBzd2l0Y2ggKGhvdXIgJSAyNCkge1xuICAgICAgICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgICAgICBjYXNlIDEyOlxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gMTI7XG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGhvdXIgJSAxMjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvKipcbiAgICAgICAgICogU3luY3MgdGhlIHNlbGVjdGVkIGRhdGUgb2JqZWN0IHRpbWUgd2l0aCB1c2VyJ3MgdGltZSBpbnB1dFxuICAgICAgICAgKi9cbiAgICAgICAgZnVuY3Rpb24gc2V0SG91cnNGcm9tSW5wdXRzKCkge1xuICAgICAgICAgICAgaWYgKHNlbGYuaG91ckVsZW1lbnQgPT09IHVuZGVmaW5lZCB8fCBzZWxmLm1pbnV0ZUVsZW1lbnQgPT09IHVuZGVmaW5lZClcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB2YXIgaG91cnMgPSAocGFyc2VJbnQoc2VsZi5ob3VyRWxlbWVudC52YWx1ZS5zbGljZSgtMiksIDEwKSB8fCAwKSAlIDI0LCBtaW51dGVzID0gKHBhcnNlSW50KHNlbGYubWludXRlRWxlbWVudC52YWx1ZSwgMTApIHx8IDApICUgNjAsIHNlY29uZHMgPSBzZWxmLnNlY29uZEVsZW1lbnQgIT09IHVuZGVmaW5lZFxuICAgICAgICAgICAgICAgID8gKHBhcnNlSW50KHNlbGYuc2Vjb25kRWxlbWVudC52YWx1ZSwgMTApIHx8IDApICUgNjBcbiAgICAgICAgICAgICAgICA6IDA7XG4gICAgICAgICAgICBpZiAoc2VsZi5hbVBNICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICBob3VycyA9IGFtcG0ybWlsaXRhcnkoaG91cnMsIHNlbGYuYW1QTS50ZXh0Q29udGVudCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgbGltaXRNaW5Ib3VycyA9IHNlbGYuY29uZmlnLm1pblRpbWUgIT09IHVuZGVmaW5lZCB8fFxuICAgICAgICAgICAgICAgIChzZWxmLmNvbmZpZy5taW5EYXRlICYmXG4gICAgICAgICAgICAgICAgICAgIHNlbGYubWluRGF0ZUhhc1RpbWUgJiZcbiAgICAgICAgICAgICAgICAgICAgc2VsZi5sYXRlc3RTZWxlY3RlZERhdGVPYmogJiZcbiAgICAgICAgICAgICAgICAgICAgY29tcGFyZURhdGVzKHNlbGYubGF0ZXN0U2VsZWN0ZWREYXRlT2JqLCBzZWxmLmNvbmZpZy5taW5EYXRlLCB0cnVlKSA9PT1cbiAgICAgICAgICAgICAgICAgICAgICAgIDApO1xuICAgICAgICAgICAgdmFyIGxpbWl0TWF4SG91cnMgPSBzZWxmLmNvbmZpZy5tYXhUaW1lICE9PSB1bmRlZmluZWQgfHxcbiAgICAgICAgICAgICAgICAoc2VsZi5jb25maWcubWF4RGF0ZSAmJlxuICAgICAgICAgICAgICAgICAgICBzZWxmLm1heERhdGVIYXNUaW1lICYmXG4gICAgICAgICAgICAgICAgICAgIHNlbGYubGF0ZXN0U2VsZWN0ZWREYXRlT2JqICYmXG4gICAgICAgICAgICAgICAgICAgIGNvbXBhcmVEYXRlcyhzZWxmLmxhdGVzdFNlbGVjdGVkRGF0ZU9iaiwgc2VsZi5jb25maWcubWF4RGF0ZSwgdHJ1ZSkgPT09XG4gICAgICAgICAgICAgICAgICAgICAgICAwKTtcbiAgICAgICAgICAgIGlmIChsaW1pdE1heEhvdXJzKSB7XG4gICAgICAgICAgICAgICAgdmFyIG1heFRpbWUgPSBzZWxmLmNvbmZpZy5tYXhUaW1lICE9PSB1bmRlZmluZWRcbiAgICAgICAgICAgICAgICAgICAgPyBzZWxmLmNvbmZpZy5tYXhUaW1lXG4gICAgICAgICAgICAgICAgICAgIDogc2VsZi5jb25maWcubWF4RGF0ZTtcbiAgICAgICAgICAgICAgICBob3VycyA9IE1hdGgubWluKGhvdXJzLCBtYXhUaW1lLmdldEhvdXJzKCkpO1xuICAgICAgICAgICAgICAgIGlmIChob3VycyA9PT0gbWF4VGltZS5nZXRIb3VycygpKVxuICAgICAgICAgICAgICAgICAgICBtaW51dGVzID0gTWF0aC5taW4obWludXRlcywgbWF4VGltZS5nZXRNaW51dGVzKCkpO1xuICAgICAgICAgICAgICAgIGlmIChtaW51dGVzID09PSBtYXhUaW1lLmdldE1pbnV0ZXMoKSlcbiAgICAgICAgICAgICAgICAgICAgc2Vjb25kcyA9IE1hdGgubWluKHNlY29uZHMsIG1heFRpbWUuZ2V0U2Vjb25kcygpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChsaW1pdE1pbkhvdXJzKSB7XG4gICAgICAgICAgICAgICAgdmFyIG1pblRpbWUgPSBzZWxmLmNvbmZpZy5taW5UaW1lICE9PSB1bmRlZmluZWRcbiAgICAgICAgICAgICAgICAgICAgPyBzZWxmLmNvbmZpZy5taW5UaW1lXG4gICAgICAgICAgICAgICAgICAgIDogc2VsZi5jb25maWcubWluRGF0ZTtcbiAgICAgICAgICAgICAgICBob3VycyA9IE1hdGgubWF4KGhvdXJzLCBtaW5UaW1lLmdldEhvdXJzKCkpO1xuICAgICAgICAgICAgICAgIGlmIChob3VycyA9PT0gbWluVGltZS5nZXRIb3VycygpKVxuICAgICAgICAgICAgICAgICAgICBtaW51dGVzID0gTWF0aC5tYXgobWludXRlcywgbWluVGltZS5nZXRNaW51dGVzKCkpO1xuICAgICAgICAgICAgICAgIGlmIChtaW51dGVzID09PSBtaW5UaW1lLmdldE1pbnV0ZXMoKSlcbiAgICAgICAgICAgICAgICAgICAgc2Vjb25kcyA9IE1hdGgubWF4KHNlY29uZHMsIG1pblRpbWUuZ2V0U2Vjb25kcygpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHNldEhvdXJzKGhvdXJzLCBtaW51dGVzLCBzZWNvbmRzKTtcbiAgICAgICAgfVxuICAgICAgICAvKipcbiAgICAgICAgICogU3luY3MgdGltZSBpbnB1dCB2YWx1ZXMgd2l0aCBhIGRhdGVcbiAgICAgICAgICovXG4gICAgICAgIGZ1bmN0aW9uIHNldEhvdXJzRnJvbURhdGUoZGF0ZU9iaikge1xuICAgICAgICAgICAgdmFyIGRhdGUgPSBkYXRlT2JqIHx8IHNlbGYubGF0ZXN0U2VsZWN0ZWREYXRlT2JqO1xuICAgICAgICAgICAgaWYgKGRhdGUpXG4gICAgICAgICAgICAgICAgc2V0SG91cnMoZGF0ZS5nZXRIb3VycygpLCBkYXRlLmdldE1pbnV0ZXMoKSwgZGF0ZS5nZXRTZWNvbmRzKCkpO1xuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIHNldERlZmF1bHRIb3VycygpIHtcbiAgICAgICAgICAgIHZhciBob3VycyA9IHNlbGYuY29uZmlnLmRlZmF1bHRIb3VyO1xuICAgICAgICAgICAgdmFyIG1pbnV0ZXMgPSBzZWxmLmNvbmZpZy5kZWZhdWx0TWludXRlO1xuICAgICAgICAgICAgdmFyIHNlY29uZHMgPSBzZWxmLmNvbmZpZy5kZWZhdWx0U2Vjb25kcztcbiAgICAgICAgICAgIGlmIChzZWxmLmNvbmZpZy5taW5EYXRlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICB2YXIgbWluSHIgPSBzZWxmLmNvbmZpZy5taW5EYXRlLmdldEhvdXJzKCk7XG4gICAgICAgICAgICAgICAgdmFyIG1pbk1pbnV0ZXMgPSBzZWxmLmNvbmZpZy5taW5EYXRlLmdldE1pbnV0ZXMoKTtcbiAgICAgICAgICAgICAgICBob3VycyA9IE1hdGgubWF4KGhvdXJzLCBtaW5Icik7XG4gICAgICAgICAgICAgICAgaWYgKGhvdXJzID09PSBtaW5IcilcbiAgICAgICAgICAgICAgICAgICAgbWludXRlcyA9IE1hdGgubWF4KG1pbk1pbnV0ZXMsIG1pbnV0ZXMpO1xuICAgICAgICAgICAgICAgIGlmIChob3VycyA9PT0gbWluSHIgJiYgbWludXRlcyA9PT0gbWluTWludXRlcylcbiAgICAgICAgICAgICAgICAgICAgc2Vjb25kcyA9IHNlbGYuY29uZmlnLm1pbkRhdGUuZ2V0U2Vjb25kcygpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHNlbGYuY29uZmlnLm1heERhdGUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIHZhciBtYXhIciA9IHNlbGYuY29uZmlnLm1heERhdGUuZ2V0SG91cnMoKTtcbiAgICAgICAgICAgICAgICB2YXIgbWF4TWludXRlcyA9IHNlbGYuY29uZmlnLm1heERhdGUuZ2V0TWludXRlcygpO1xuICAgICAgICAgICAgICAgIGhvdXJzID0gTWF0aC5taW4oaG91cnMsIG1heEhyKTtcbiAgICAgICAgICAgICAgICBpZiAoaG91cnMgPT09IG1heEhyKVxuICAgICAgICAgICAgICAgICAgICBtaW51dGVzID0gTWF0aC5taW4obWF4TWludXRlcywgbWludXRlcyk7XG4gICAgICAgICAgICAgICAgaWYgKGhvdXJzID09PSBtYXhIciAmJiBtaW51dGVzID09PSBtYXhNaW51dGVzKVxuICAgICAgICAgICAgICAgICAgICBzZWNvbmRzID0gc2VsZi5jb25maWcubWF4RGF0ZS5nZXRTZWNvbmRzKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBzZXRIb3Vycyhob3VycywgbWludXRlcywgc2Vjb25kcyk7XG4gICAgICAgIH1cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFNldHMgdGhlIGhvdXJzLCBtaW51dGVzLCBhbmQgb3B0aW9uYWxseSBzZWNvbmRzXG4gICAgICAgICAqIG9mIHRoZSBsYXRlc3Qgc2VsZWN0ZWQgZGF0ZSBvYmplY3QgYW5kIHRoZVxuICAgICAgICAgKiBjb3JyZXNwb25kaW5nIHRpbWUgaW5wdXRzXG4gICAgICAgICAqIEBwYXJhbSB7TnVtYmVyfSBob3VycyB0aGUgaG91ci4gd2hldGhlciBpdHMgbWlsaXRhcnlcbiAgICAgICAgICogICAgICAgICAgICAgICAgIG9yIGFtLXBtIGdldHMgaW5mZXJyZWQgZnJvbSBjb25maWdcbiAgICAgICAgICogQHBhcmFtIHtOdW1iZXJ9IG1pbnV0ZXMgdGhlIG1pbnV0ZXNcbiAgICAgICAgICogQHBhcmFtIHtOdW1iZXJ9IHNlY29uZHMgdGhlIHNlY29uZHMgKG9wdGlvbmFsKVxuICAgICAgICAgKi9cbiAgICAgICAgZnVuY3Rpb24gc2V0SG91cnMoaG91cnMsIG1pbnV0ZXMsIHNlY29uZHMpIHtcbiAgICAgICAgICAgIGlmIChzZWxmLmxhdGVzdFNlbGVjdGVkRGF0ZU9iaiAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgc2VsZi5sYXRlc3RTZWxlY3RlZERhdGVPYmouc2V0SG91cnMoaG91cnMgJSAyNCwgbWludXRlcywgc2Vjb25kcyB8fCAwLCAwKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghc2VsZi5ob3VyRWxlbWVudCB8fCAhc2VsZi5taW51dGVFbGVtZW50IHx8IHNlbGYuaXNNb2JpbGUpXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgc2VsZi5ob3VyRWxlbWVudC52YWx1ZSA9IHBhZCghc2VsZi5jb25maWcudGltZV8yNGhyXG4gICAgICAgICAgICAgICAgPyAoKDEyICsgaG91cnMpICUgMTIpICsgMTIgKiBpbnQoaG91cnMgJSAxMiA9PT0gMClcbiAgICAgICAgICAgICAgICA6IGhvdXJzKTtcbiAgICAgICAgICAgIHNlbGYubWludXRlRWxlbWVudC52YWx1ZSA9IHBhZChtaW51dGVzKTtcbiAgICAgICAgICAgIGlmIChzZWxmLmFtUE0gIT09IHVuZGVmaW5lZClcbiAgICAgICAgICAgICAgICBzZWxmLmFtUE0udGV4dENvbnRlbnQgPSBzZWxmLmwxMG4uYW1QTVtpbnQoaG91cnMgPj0gMTIpXTtcbiAgICAgICAgICAgIGlmIChzZWxmLnNlY29uZEVsZW1lbnQgIT09IHVuZGVmaW5lZClcbiAgICAgICAgICAgICAgICBzZWxmLnNlY29uZEVsZW1lbnQudmFsdWUgPSBwYWQoc2Vjb25kcyk7XG4gICAgICAgIH1cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEhhbmRsZXMgdGhlIHllYXIgaW5wdXQgYW5kIGluY3JlbWVudGluZyBldmVudHNcbiAgICAgICAgICogQHBhcmFtIHtFdmVudH0gZXZlbnQgdGhlIGtleXVwIG9yIGluY3JlbWVudCBldmVudFxuICAgICAgICAgKi9cbiAgICAgICAgZnVuY3Rpb24gb25ZZWFySW5wdXQoZXZlbnQpIHtcbiAgICAgICAgICAgIHZhciB5ZWFyID0gcGFyc2VJbnQoZXZlbnQudGFyZ2V0LnZhbHVlKSArIChldmVudC5kZWx0YSB8fCAwKTtcbiAgICAgICAgICAgIGlmICh5ZWFyIC8gMTAwMCA+IDEgfHxcbiAgICAgICAgICAgICAgICAoZXZlbnQua2V5ID09PSBcIkVudGVyXCIgJiYgIS9bXlxcZF0vLnRlc3QoeWVhci50b1N0cmluZygpKSkpIHtcbiAgICAgICAgICAgICAgICBjaGFuZ2VZZWFyKHllYXIpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBFc3NlbnRpYWxseSBhZGRFdmVudExpc3RlbmVyICsgdHJhY2tpbmdcbiAgICAgICAgICogQHBhcmFtIHtFbGVtZW50fSBlbGVtZW50IHRoZSBlbGVtZW50IHRvIGFkZEV2ZW50TGlzdGVuZXIgdG9cbiAgICAgICAgICogQHBhcmFtIHtTdHJpbmd9IGV2ZW50IHRoZSBldmVudCBuYW1lXG4gICAgICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGhhbmRsZXIgdGhlIGV2ZW50IGhhbmRsZXJcbiAgICAgICAgICovXG4gICAgICAgIGZ1bmN0aW9uIGJpbmQoZWxlbWVudCwgZXZlbnQsIGhhbmRsZXIsIG9wdGlvbnMpIHtcbiAgICAgICAgICAgIGlmIChldmVudCBpbnN0YW5jZW9mIEFycmF5KVxuICAgICAgICAgICAgICAgIHJldHVybiBldmVudC5mb3JFYWNoKGZ1bmN0aW9uIChldikgeyByZXR1cm4gYmluZChlbGVtZW50LCBldiwgaGFuZGxlciwgb3B0aW9ucyk7IH0pO1xuICAgICAgICAgICAgaWYgKGVsZW1lbnQgaW5zdGFuY2VvZiBBcnJheSlcbiAgICAgICAgICAgICAgICByZXR1cm4gZWxlbWVudC5mb3JFYWNoKGZ1bmN0aW9uIChlbCkgeyByZXR1cm4gYmluZChlbCwgZXZlbnQsIGhhbmRsZXIsIG9wdGlvbnMpOyB9KTtcbiAgICAgICAgICAgIGVsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lcihldmVudCwgaGFuZGxlciwgb3B0aW9ucyk7XG4gICAgICAgICAgICBzZWxmLl9oYW5kbGVycy5wdXNoKHtcbiAgICAgICAgICAgICAgICBlbGVtZW50OiBlbGVtZW50LFxuICAgICAgICAgICAgICAgIGV2ZW50OiBldmVudCxcbiAgICAgICAgICAgICAgICBoYW5kbGVyOiBoYW5kbGVyLFxuICAgICAgICAgICAgICAgIG9wdGlvbnM6IG9wdGlvbnNcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBBIG1vdXNlZG93biBoYW5kbGVyIHdoaWNoIG1pbWljcyBjbGljay5cbiAgICAgICAgICogTWluaW1pemVzIGxhdGVuY3ksIHNpbmNlIHdlIGRvbid0IG5lZWQgdG8gd2FpdCBmb3IgbW91c2V1cCBpbiBtb3N0IGNhc2VzLlxuICAgICAgICAgKiBBbHNvLCBhdm9pZHMgaGFuZGxpbmcgcmlnaHQgY2xpY2tzLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBoYW5kbGVyIHRoZSBldmVudCBoYW5kbGVyXG4gICAgICAgICAqL1xuICAgICAgICBmdW5jdGlvbiBvbkNsaWNrKGhhbmRsZXIpIHtcbiAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbiAoZXZ0KSB7XG4gICAgICAgICAgICAgICAgZXZ0LndoaWNoID09PSAxICYmIGhhbmRsZXIoZXZ0KTtcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gdHJpZ2dlckNoYW5nZSgpIHtcbiAgICAgICAgICAgIHRyaWdnZXJFdmVudChcIm9uQ2hhbmdlXCIpO1xuICAgICAgICB9XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBBZGRzIGFsbCB0aGUgbmVjZXNzYXJ5IGV2ZW50IGxpc3RlbmVyc1xuICAgICAgICAgKi9cbiAgICAgICAgZnVuY3Rpb24gYmluZEV2ZW50cygpIHtcbiAgICAgICAgICAgIGlmIChzZWxmLmNvbmZpZy53cmFwKSB7XG4gICAgICAgICAgICAgICAgW1wib3BlblwiLCBcImNsb3NlXCIsIFwidG9nZ2xlXCIsIFwiY2xlYXJcIl0uZm9yRWFjaChmdW5jdGlvbiAoZXZ0KSB7XG4gICAgICAgICAgICAgICAgICAgIEFycmF5LnByb3RvdHlwZS5mb3JFYWNoLmNhbGwoc2VsZi5lbGVtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoXCJbZGF0YS1cIiArIGV2dCArIFwiXVwiKSwgZnVuY3Rpb24gKGVsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gYmluZChlbCwgXCJjbGlja1wiLCBzZWxmW2V2dF0pO1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChzZWxmLmlzTW9iaWxlKSB7XG4gICAgICAgICAgICAgICAgc2V0dXBNb2JpbGUoKTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgZGVib3VuY2VkUmVzaXplID0gZGVib3VuY2Uob25SZXNpemUsIDUwKTtcbiAgICAgICAgICAgIHNlbGYuX2RlYm91bmNlZENoYW5nZSA9IGRlYm91bmNlKHRyaWdnZXJDaGFuZ2UsIERFQk9VTkNFRF9DSEFOR0VfTVMpO1xuICAgICAgICAgICAgaWYgKHNlbGYuZGF5c0NvbnRhaW5lciAmJiAhL2lQaG9uZXxpUGFkfGlQb2QvaS50ZXN0KG5hdmlnYXRvci51c2VyQWdlbnQpKVxuICAgICAgICAgICAgICAgIGJpbmQoc2VsZi5kYXlzQ29udGFpbmVyLCBcIm1vdXNlb3ZlclwiLCBmdW5jdGlvbiAoZSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoc2VsZi5jb25maWcubW9kZSA9PT0gXCJyYW5nZVwiKVxuICAgICAgICAgICAgICAgICAgICAgICAgb25Nb3VzZU92ZXIoZS50YXJnZXQpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgYmluZCh3aW5kb3cuZG9jdW1lbnQuYm9keSwgXCJrZXlkb3duXCIsIG9uS2V5RG93bik7XG4gICAgICAgICAgICBpZiAoIXNlbGYuY29uZmlnLmlubGluZSAmJiAhc2VsZi5jb25maWcuc3RhdGljKVxuICAgICAgICAgICAgICAgIGJpbmQod2luZG93LCBcInJlc2l6ZVwiLCBkZWJvdW5jZWRSZXNpemUpO1xuICAgICAgICAgICAgaWYgKHdpbmRvdy5vbnRvdWNoc3RhcnQgIT09IHVuZGVmaW5lZClcbiAgICAgICAgICAgICAgICBiaW5kKHdpbmRvdy5kb2N1bWVudCwgXCJ0b3VjaHN0YXJ0XCIsIGRvY3VtZW50Q2xpY2spO1xuICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgIGJpbmQod2luZG93LmRvY3VtZW50LCBcIm1vdXNlZG93blwiLCBvbkNsaWNrKGRvY3VtZW50Q2xpY2spKTtcbiAgICAgICAgICAgIGJpbmQod2luZG93LmRvY3VtZW50LCBcImZvY3VzXCIsIGRvY3VtZW50Q2xpY2ssIHsgY2FwdHVyZTogdHJ1ZSB9KTtcbiAgICAgICAgICAgIGlmIChzZWxmLmNvbmZpZy5jbGlja09wZW5zID09PSB0cnVlKSB7XG4gICAgICAgICAgICAgICAgYmluZChzZWxmLl9pbnB1dCwgXCJmb2N1c1wiLCBzZWxmLm9wZW4pO1xuICAgICAgICAgICAgICAgIGJpbmQoc2VsZi5faW5wdXQsIFwibW91c2Vkb3duXCIsIG9uQ2xpY2soc2VsZi5vcGVuKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoc2VsZi5kYXlzQ29udGFpbmVyICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICBiaW5kKHNlbGYubW9udGhOYXYsIFwibW91c2Vkb3duXCIsIG9uQ2xpY2sob25Nb250aE5hdkNsaWNrKSk7XG4gICAgICAgICAgICAgICAgYmluZChzZWxmLm1vbnRoTmF2LCBbXCJrZXl1cFwiLCBcImluY3JlbWVudFwiXSwgb25ZZWFySW5wdXQpO1xuICAgICAgICAgICAgICAgIGJpbmQoc2VsZi5kYXlzQ29udGFpbmVyLCBcIm1vdXNlZG93blwiLCBvbkNsaWNrKHNlbGVjdERhdGUpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChzZWxmLnRpbWVDb250YWluZXIgIT09IHVuZGVmaW5lZCAmJlxuICAgICAgICAgICAgICAgIHNlbGYubWludXRlRWxlbWVudCAhPT0gdW5kZWZpbmVkICYmXG4gICAgICAgICAgICAgICAgc2VsZi5ob3VyRWxlbWVudCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgdmFyIHNlbFRleHQgPSBmdW5jdGlvbiAoZSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZS50YXJnZXQuc2VsZWN0KCk7XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICBiaW5kKHNlbGYudGltZUNvbnRhaW5lciwgW1wiaW5jcmVtZW50XCJdLCB1cGRhdGVUaW1lKTtcbiAgICAgICAgICAgICAgICBiaW5kKHNlbGYudGltZUNvbnRhaW5lciwgXCJibHVyXCIsIHVwZGF0ZVRpbWUsIHsgY2FwdHVyZTogdHJ1ZSB9KTtcbiAgICAgICAgICAgICAgICBiaW5kKHNlbGYudGltZUNvbnRhaW5lciwgXCJtb3VzZWRvd25cIiwgb25DbGljayh0aW1lSW5jcmVtZW50KSk7XG4gICAgICAgICAgICAgICAgYmluZChbc2VsZi5ob3VyRWxlbWVudCwgc2VsZi5taW51dGVFbGVtZW50XSwgW1wiZm9jdXNcIiwgXCJjbGlja1wiXSwgc2VsVGV4dCk7XG4gICAgICAgICAgICAgICAgaWYgKHNlbGYuc2Vjb25kRWxlbWVudCAhPT0gdW5kZWZpbmVkKVxuICAgICAgICAgICAgICAgICAgICBiaW5kKHNlbGYuc2Vjb25kRWxlbWVudCwgXCJmb2N1c1wiLCBmdW5jdGlvbiAoKSB7IHJldHVybiBzZWxmLnNlY29uZEVsZW1lbnQgJiYgc2VsZi5zZWNvbmRFbGVtZW50LnNlbGVjdCgpOyB9KTtcbiAgICAgICAgICAgICAgICBpZiAoc2VsZi5hbVBNICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgYmluZChzZWxmLmFtUE0sIFwibW91c2Vkb3duXCIsIG9uQ2xpY2soZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHVwZGF0ZVRpbWUoZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB0cmlnZ2VyQ2hhbmdlKCk7XG4gICAgICAgICAgICAgICAgICAgIH0pKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFNldCB0aGUgY2FsZW5kYXIgdmlldyB0byBhIHBhcnRpY3VsYXIgZGF0ZS5cbiAgICAgICAgICogQHBhcmFtIHtEYXRlfSBqdW1wRGF0ZSB0aGUgZGF0ZSB0byBzZXQgdGhlIHZpZXcgdG9cbiAgICAgICAgICogQHBhcmFtIHtib29sZWFufSB0cmlnZ2VyQ2hhbmdlIGlmIGNoYW5nZSBldmVudHMgc2hvdWxkIGJlIHRyaWdnZXJlZFxuICAgICAgICAgKi9cbiAgICAgICAgZnVuY3Rpb24ganVtcFRvRGF0ZShqdW1wRGF0ZSwgdHJpZ2dlckNoYW5nZSkge1xuICAgICAgICAgICAgdmFyIGp1bXBUbyA9IGp1bXBEYXRlICE9PSB1bmRlZmluZWRcbiAgICAgICAgICAgICAgICA/IHNlbGYucGFyc2VEYXRlKGp1bXBEYXRlKVxuICAgICAgICAgICAgICAgIDogc2VsZi5sYXRlc3RTZWxlY3RlZERhdGVPYmogfHxcbiAgICAgICAgICAgICAgICAgICAgKHNlbGYuY29uZmlnLm1pbkRhdGUgJiYgc2VsZi5jb25maWcubWluRGF0ZSA+IHNlbGYubm93XG4gICAgICAgICAgICAgICAgICAgICAgICA/IHNlbGYuY29uZmlnLm1pbkRhdGVcbiAgICAgICAgICAgICAgICAgICAgICAgIDogc2VsZi5jb25maWcubWF4RGF0ZSAmJiBzZWxmLmNvbmZpZy5tYXhEYXRlIDwgc2VsZi5ub3dcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA/IHNlbGYuY29uZmlnLm1heERhdGVcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA6IHNlbGYubm93KTtcbiAgICAgICAgICAgIHZhciBvbGRZZWFyID0gc2VsZi5jdXJyZW50WWVhcjtcbiAgICAgICAgICAgIHZhciBvbGRNb250aCA9IHNlbGYuY3VycmVudE1vbnRoO1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBpZiAoanVtcFRvICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgc2VsZi5jdXJyZW50WWVhciA9IGp1bXBUby5nZXRGdWxsWWVhcigpO1xuICAgICAgICAgICAgICAgICAgICBzZWxmLmN1cnJlbnRNb250aCA9IGp1bXBUby5nZXRNb250aCgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbiAgICAgICAgICAgICAgICBlLm1lc3NhZ2UgPSBcIkludmFsaWQgZGF0ZSBzdXBwbGllZDogXCIgKyBqdW1wVG87XG4gICAgICAgICAgICAgICAgc2VsZi5jb25maWcuZXJyb3JIYW5kbGVyKGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRyaWdnZXJDaGFuZ2UgJiYgc2VsZi5jdXJyZW50WWVhciAhPT0gb2xkWWVhcikge1xuICAgICAgICAgICAgICAgIHRyaWdnZXJFdmVudChcIm9uWWVhckNoYW5nZVwiKTtcbiAgICAgICAgICAgICAgICBidWlsZE1vbnRoU3dpdGNoKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodHJpZ2dlckNoYW5nZSAmJlxuICAgICAgICAgICAgICAgIChzZWxmLmN1cnJlbnRZZWFyICE9PSBvbGRZZWFyIHx8IHNlbGYuY3VycmVudE1vbnRoICE9PSBvbGRNb250aCkpIHtcbiAgICAgICAgICAgICAgICB0cmlnZ2VyRXZlbnQoXCJvbk1vbnRoQ2hhbmdlXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgc2VsZi5yZWRyYXcoKTtcbiAgICAgICAgfVxuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIHVwL2Rvd24gYXJyb3cgaGFuZGxlciBmb3IgdGltZSBpbnB1dHNcbiAgICAgICAgICogQHBhcmFtIHtFdmVudH0gZSB0aGUgY2xpY2sgZXZlbnRcbiAgICAgICAgICovXG4gICAgICAgIGZ1bmN0aW9uIHRpbWVJbmNyZW1lbnQoZSkge1xuICAgICAgICAgICAgaWYgKH5lLnRhcmdldC5jbGFzc05hbWUuaW5kZXhPZihcImFycm93XCIpKVxuICAgICAgICAgICAgICAgIGluY3JlbWVudE51bUlucHV0KGUsIGUudGFyZ2V0LmNsYXNzTGlzdC5jb250YWlucyhcImFycm93VXBcIikgPyAxIDogLTEpO1xuICAgICAgICB9XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBJbmNyZW1lbnRzL2RlY3JlbWVudHMgdGhlIHZhbHVlIG9mIGlucHV0IGFzc29jaS1cbiAgICAgICAgICogYXRlZCB3aXRoIHRoZSB1cC9kb3duIGFycm93IGJ5IGRpc3BhdGNoaW5nIGFuXG4gICAgICAgICAqIFwiaW5jcmVtZW50XCIgZXZlbnQgb24gdGhlIGlucHV0LlxuICAgICAgICAgKlxuICAgICAgICAgKiBAcGFyYW0ge0V2ZW50fSBlIHRoZSBjbGljayBldmVudFxuICAgICAgICAgKiBAcGFyYW0ge051bWJlcn0gZGVsdGEgdGhlIGRpZmYgKHVzdWFsbHkgMSBvciAtMSlcbiAgICAgICAgICogQHBhcmFtIHtFbGVtZW50fSBpbnB1dEVsZW0gdGhlIGlucHV0IGVsZW1lbnRcbiAgICAgICAgICovXG4gICAgICAgIGZ1bmN0aW9uIGluY3JlbWVudE51bUlucHV0KGUsIGRlbHRhLCBpbnB1dEVsZW0pIHtcbiAgICAgICAgICAgIHZhciB0YXJnZXQgPSBlICYmIGUudGFyZ2V0O1xuICAgICAgICAgICAgdmFyIGlucHV0ID0gaW5wdXRFbGVtIHx8XG4gICAgICAgICAgICAgICAgKHRhcmdldCAmJiB0YXJnZXQucGFyZW50Tm9kZSAmJiB0YXJnZXQucGFyZW50Tm9kZS5maXJzdENoaWxkKTtcbiAgICAgICAgICAgIHZhciBldmVudCA9IGNyZWF0ZUV2ZW50KFwiaW5jcmVtZW50XCIpO1xuICAgICAgICAgICAgZXZlbnQuZGVsdGEgPSBkZWx0YTtcbiAgICAgICAgICAgIGlucHV0ICYmIGlucHV0LmRpc3BhdGNoRXZlbnQoZXZlbnQpO1xuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIGJ1aWxkKCkge1xuICAgICAgICAgICAgdmFyIGZyYWdtZW50ID0gd2luZG93LmRvY3VtZW50LmNyZWF0ZURvY3VtZW50RnJhZ21lbnQoKTtcbiAgICAgICAgICAgIHNlbGYuY2FsZW5kYXJDb250YWluZXIgPSBjcmVhdGVFbGVtZW50KFwiZGl2XCIsIFwiZmxhdHBpY2tyLWNhbGVuZGFyXCIpO1xuICAgICAgICAgICAgc2VsZi5jYWxlbmRhckNvbnRhaW5lci50YWJJbmRleCA9IC0xO1xuICAgICAgICAgICAgaWYgKCFzZWxmLmNvbmZpZy5ub0NhbGVuZGFyKSB7XG4gICAgICAgICAgICAgICAgZnJhZ21lbnQuYXBwZW5kQ2hpbGQoYnVpbGRNb250aE5hdigpKTtcbiAgICAgICAgICAgICAgICBzZWxmLmlubmVyQ29udGFpbmVyID0gY3JlYXRlRWxlbWVudChcImRpdlwiLCBcImZsYXRwaWNrci1pbm5lckNvbnRhaW5lclwiKTtcbiAgICAgICAgICAgICAgICBpZiAoc2VsZi5jb25maWcud2Vla051bWJlcnMpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIF9hID0gYnVpbGRXZWVrcygpLCB3ZWVrV3JhcHBlciA9IF9hLndlZWtXcmFwcGVyLCB3ZWVrTnVtYmVycyA9IF9hLndlZWtOdW1iZXJzO1xuICAgICAgICAgICAgICAgICAgICBzZWxmLmlubmVyQ29udGFpbmVyLmFwcGVuZENoaWxkKHdlZWtXcmFwcGVyKTtcbiAgICAgICAgICAgICAgICAgICAgc2VsZi53ZWVrTnVtYmVycyA9IHdlZWtOdW1iZXJzO1xuICAgICAgICAgICAgICAgICAgICBzZWxmLndlZWtXcmFwcGVyID0gd2Vla1dyYXBwZXI7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHNlbGYuckNvbnRhaW5lciA9IGNyZWF0ZUVsZW1lbnQoXCJkaXZcIiwgXCJmbGF0cGlja3ItckNvbnRhaW5lclwiKTtcbiAgICAgICAgICAgICAgICBzZWxmLnJDb250YWluZXIuYXBwZW5kQ2hpbGQoYnVpbGRXZWVrZGF5cygpKTtcbiAgICAgICAgICAgICAgICBpZiAoIXNlbGYuZGF5c0NvbnRhaW5lcikge1xuICAgICAgICAgICAgICAgICAgICBzZWxmLmRheXNDb250YWluZXIgPSBjcmVhdGVFbGVtZW50KFwiZGl2XCIsIFwiZmxhdHBpY2tyLWRheXNcIik7XG4gICAgICAgICAgICAgICAgICAgIHNlbGYuZGF5c0NvbnRhaW5lci50YWJJbmRleCA9IC0xO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBidWlsZERheXMoKTtcbiAgICAgICAgICAgICAgICBzZWxmLnJDb250YWluZXIuYXBwZW5kQ2hpbGQoc2VsZi5kYXlzQ29udGFpbmVyKTtcbiAgICAgICAgICAgICAgICBzZWxmLmlubmVyQ29udGFpbmVyLmFwcGVuZENoaWxkKHNlbGYuckNvbnRhaW5lcik7XG4gICAgICAgICAgICAgICAgZnJhZ21lbnQuYXBwZW5kQ2hpbGQoc2VsZi5pbm5lckNvbnRhaW5lcik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoc2VsZi5jb25maWcuZW5hYmxlVGltZSkge1xuICAgICAgICAgICAgICAgIGZyYWdtZW50LmFwcGVuZENoaWxkKGJ1aWxkVGltZSgpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRvZ2dsZUNsYXNzKHNlbGYuY2FsZW5kYXJDb250YWluZXIsIFwicmFuZ2VNb2RlXCIsIHNlbGYuY29uZmlnLm1vZGUgPT09IFwicmFuZ2VcIik7XG4gICAgICAgICAgICB0b2dnbGVDbGFzcyhzZWxmLmNhbGVuZGFyQ29udGFpbmVyLCBcImFuaW1hdGVcIiwgc2VsZi5jb25maWcuYW5pbWF0ZSA9PT0gdHJ1ZSk7XG4gICAgICAgICAgICB0b2dnbGVDbGFzcyhzZWxmLmNhbGVuZGFyQ29udGFpbmVyLCBcIm11bHRpTW9udGhcIiwgc2VsZi5jb25maWcuc2hvd01vbnRocyA+IDEpO1xuICAgICAgICAgICAgc2VsZi5jYWxlbmRhckNvbnRhaW5lci5hcHBlbmRDaGlsZChmcmFnbWVudCk7XG4gICAgICAgICAgICB2YXIgY3VzdG9tQXBwZW5kID0gc2VsZi5jb25maWcuYXBwZW5kVG8gIT09IHVuZGVmaW5lZCAmJlxuICAgICAgICAgICAgICAgIHNlbGYuY29uZmlnLmFwcGVuZFRvLm5vZGVUeXBlICE9PSB1bmRlZmluZWQ7XG4gICAgICAgICAgICBpZiAoc2VsZi5jb25maWcuaW5saW5lIHx8IHNlbGYuY29uZmlnLnN0YXRpYykge1xuICAgICAgICAgICAgICAgIHNlbGYuY2FsZW5kYXJDb250YWluZXIuY2xhc3NMaXN0LmFkZChzZWxmLmNvbmZpZy5pbmxpbmUgPyBcImlubGluZVwiIDogXCJzdGF0aWNcIik7XG4gICAgICAgICAgICAgICAgaWYgKHNlbGYuY29uZmlnLmlubGluZSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoIWN1c3RvbUFwcGVuZCAmJiBzZWxmLmVsZW1lbnQucGFyZW50Tm9kZSlcbiAgICAgICAgICAgICAgICAgICAgICAgIHNlbGYuZWxlbWVudC5wYXJlbnROb2RlLmluc2VydEJlZm9yZShzZWxmLmNhbGVuZGFyQ29udGFpbmVyLCBzZWxmLl9pbnB1dC5uZXh0U2libGluZyk7XG4gICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKHNlbGYuY29uZmlnLmFwcGVuZFRvICE9PSB1bmRlZmluZWQpXG4gICAgICAgICAgICAgICAgICAgICAgICBzZWxmLmNvbmZpZy5hcHBlbmRUby5hcHBlbmRDaGlsZChzZWxmLmNhbGVuZGFyQ29udGFpbmVyKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHNlbGYuY29uZmlnLnN0YXRpYykge1xuICAgICAgICAgICAgICAgICAgICB2YXIgd3JhcHBlciA9IGNyZWF0ZUVsZW1lbnQoXCJkaXZcIiwgXCJmbGF0cGlja3Itd3JhcHBlclwiKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHNlbGYuZWxlbWVudC5wYXJlbnROb2RlKVxuICAgICAgICAgICAgICAgICAgICAgICAgc2VsZi5lbGVtZW50LnBhcmVudE5vZGUuaW5zZXJ0QmVmb3JlKHdyYXBwZXIsIHNlbGYuZWxlbWVudCk7XG4gICAgICAgICAgICAgICAgICAgIHdyYXBwZXIuYXBwZW5kQ2hpbGQoc2VsZi5lbGVtZW50KTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHNlbGYuYWx0SW5wdXQpXG4gICAgICAgICAgICAgICAgICAgICAgICB3cmFwcGVyLmFwcGVuZENoaWxkKHNlbGYuYWx0SW5wdXQpO1xuICAgICAgICAgICAgICAgICAgICB3cmFwcGVyLmFwcGVuZENoaWxkKHNlbGYuY2FsZW5kYXJDb250YWluZXIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghc2VsZi5jb25maWcuc3RhdGljICYmICFzZWxmLmNvbmZpZy5pbmxpbmUpXG4gICAgICAgICAgICAgICAgKHNlbGYuY29uZmlnLmFwcGVuZFRvICE9PSB1bmRlZmluZWRcbiAgICAgICAgICAgICAgICAgICAgPyBzZWxmLmNvbmZpZy5hcHBlbmRUb1xuICAgICAgICAgICAgICAgICAgICA6IHdpbmRvdy5kb2N1bWVudC5ib2R5KS5hcHBlbmRDaGlsZChzZWxmLmNhbGVuZGFyQ29udGFpbmVyKTtcbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiBjcmVhdGVEYXkoY2xhc3NOYW1lLCBkYXRlLCBkYXlOdW1iZXIsIGkpIHtcbiAgICAgICAgICAgIHZhciBkYXRlSXNFbmFibGVkID0gaXNFbmFibGVkKGRhdGUsIHRydWUpLCBkYXlFbGVtZW50ID0gY3JlYXRlRWxlbWVudChcInNwYW5cIiwgXCJmbGF0cGlja3ItZGF5IFwiICsgY2xhc3NOYW1lLCBkYXRlLmdldERhdGUoKS50b1N0cmluZygpKTtcbiAgICAgICAgICAgIGRheUVsZW1lbnQuZGF0ZU9iaiA9IGRhdGU7XG4gICAgICAgICAgICBkYXlFbGVtZW50LiRpID0gaTtcbiAgICAgICAgICAgIGRheUVsZW1lbnQuc2V0QXR0cmlidXRlKFwiYXJpYS1sYWJlbFwiLCBzZWxmLmZvcm1hdERhdGUoZGF0ZSwgc2VsZi5jb25maWcuYXJpYURhdGVGb3JtYXQpKTtcbiAgICAgICAgICAgIGlmIChjbGFzc05hbWUuaW5kZXhPZihcImhpZGRlblwiKSA9PT0gLTEgJiZcbiAgICAgICAgICAgICAgICBjb21wYXJlRGF0ZXMoZGF0ZSwgc2VsZi5ub3cpID09PSAwKSB7XG4gICAgICAgICAgICAgICAgc2VsZi50b2RheURhdGVFbGVtID0gZGF5RWxlbWVudDtcbiAgICAgICAgICAgICAgICBkYXlFbGVtZW50LmNsYXNzTGlzdC5hZGQoXCJ0b2RheVwiKTtcbiAgICAgICAgICAgICAgICBkYXlFbGVtZW50LnNldEF0dHJpYnV0ZShcImFyaWEtY3VycmVudFwiLCBcImRhdGVcIik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoZGF0ZUlzRW5hYmxlZCkge1xuICAgICAgICAgICAgICAgIGRheUVsZW1lbnQudGFiSW5kZXggPSAtMTtcbiAgICAgICAgICAgICAgICBpZiAoaXNEYXRlU2VsZWN0ZWQoZGF0ZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgZGF5RWxlbWVudC5jbGFzc0xpc3QuYWRkKFwic2VsZWN0ZWRcIik7XG4gICAgICAgICAgICAgICAgICAgIHNlbGYuc2VsZWN0ZWREYXRlRWxlbSA9IGRheUVsZW1lbnQ7XG4gICAgICAgICAgICAgICAgICAgIGlmIChzZWxmLmNvbmZpZy5tb2RlID09PSBcInJhbmdlXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRvZ2dsZUNsYXNzKGRheUVsZW1lbnQsIFwic3RhcnRSYW5nZVwiLCBzZWxmLnNlbGVjdGVkRGF0ZXNbMF0gJiZcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb21wYXJlRGF0ZXMoZGF0ZSwgc2VsZi5zZWxlY3RlZERhdGVzWzBdLCB0cnVlKSA9PT0gMCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB0b2dnbGVDbGFzcyhkYXlFbGVtZW50LCBcImVuZFJhbmdlXCIsIHNlbGYuc2VsZWN0ZWREYXRlc1sxXSAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbXBhcmVEYXRlcyhkYXRlLCBzZWxmLnNlbGVjdGVkRGF0ZXNbMV0sIHRydWUpID09PSAwKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjbGFzc05hbWUgPT09IFwibmV4dE1vbnRoRGF5XCIpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZGF5RWxlbWVudC5jbGFzc0xpc3QuYWRkKFwiaW5SYW5nZVwiKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGRheUVsZW1lbnQuY2xhc3NMaXN0LmFkZChcImZsYXRwaWNrci1kaXNhYmxlZFwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChzZWxmLmNvbmZpZy5tb2RlID09PSBcInJhbmdlXCIpIHtcbiAgICAgICAgICAgICAgICBpZiAoaXNEYXRlSW5SYW5nZShkYXRlKSAmJiAhaXNEYXRlU2VsZWN0ZWQoZGF0ZSkpXG4gICAgICAgICAgICAgICAgICAgIGRheUVsZW1lbnQuY2xhc3NMaXN0LmFkZChcImluUmFuZ2VcIik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoc2VsZi53ZWVrTnVtYmVycyAmJlxuICAgICAgICAgICAgICAgIHNlbGYuY29uZmlnLnNob3dNb250aHMgPT09IDEgJiZcbiAgICAgICAgICAgICAgICBjbGFzc05hbWUgIT09IFwicHJldk1vbnRoRGF5XCIgJiZcbiAgICAgICAgICAgICAgICBkYXlOdW1iZXIgJSA3ID09PSAxKSB7XG4gICAgICAgICAgICAgICAgc2VsZi53ZWVrTnVtYmVycy5pbnNlcnRBZGphY2VudEhUTUwoXCJiZWZvcmVlbmRcIiwgXCI8c3BhbiBjbGFzcz0nZmxhdHBpY2tyLWRheSc+XCIgKyBzZWxmLmNvbmZpZy5nZXRXZWVrKGRhdGUpICsgXCI8L3NwYW4+XCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdHJpZ2dlckV2ZW50KFwib25EYXlDcmVhdGVcIiwgZGF5RWxlbWVudCk7XG4gICAgICAgICAgICByZXR1cm4gZGF5RWxlbWVudDtcbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiBmb2N1c09uRGF5RWxlbSh0YXJnZXROb2RlKSB7XG4gICAgICAgICAgICB0YXJnZXROb2RlLmZvY3VzKCk7XG4gICAgICAgICAgICBpZiAoc2VsZi5jb25maWcubW9kZSA9PT0gXCJyYW5nZVwiKVxuICAgICAgICAgICAgICAgIG9uTW91c2VPdmVyKHRhcmdldE5vZGUpO1xuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIGdldEZpcnN0QXZhaWxhYmxlRGF5KGRlbHRhKSB7XG4gICAgICAgICAgICB2YXIgc3RhcnRNb250aCA9IGRlbHRhID4gMCA/IDAgOiBzZWxmLmNvbmZpZy5zaG93TW9udGhzIC0gMTtcbiAgICAgICAgICAgIHZhciBlbmRNb250aCA9IGRlbHRhID4gMCA/IHNlbGYuY29uZmlnLnNob3dNb250aHMgOiAtMTtcbiAgICAgICAgICAgIGZvciAodmFyIG0gPSBzdGFydE1vbnRoOyBtICE9IGVuZE1vbnRoOyBtICs9IGRlbHRhKSB7XG4gICAgICAgICAgICAgICAgdmFyIG1vbnRoID0gc2VsZi5kYXlzQ29udGFpbmVyLmNoaWxkcmVuW21dO1xuICAgICAgICAgICAgICAgIHZhciBzdGFydEluZGV4ID0gZGVsdGEgPiAwID8gMCA6IG1vbnRoLmNoaWxkcmVuLmxlbmd0aCAtIDE7XG4gICAgICAgICAgICAgICAgdmFyIGVuZEluZGV4ID0gZGVsdGEgPiAwID8gbW9udGguY2hpbGRyZW4ubGVuZ3RoIDogLTE7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IHN0YXJ0SW5kZXg7IGkgIT0gZW5kSW5kZXg7IGkgKz0gZGVsdGEpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGMgPSBtb250aC5jaGlsZHJlbltpXTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGMuY2xhc3NOYW1lLmluZGV4T2YoXCJoaWRkZW5cIikgPT09IC0xICYmIGlzRW5hYmxlZChjLmRhdGVPYmopKVxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGM7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiBnZXROZXh0QXZhaWxhYmxlRGF5KGN1cnJlbnQsIGRlbHRhKSB7XG4gICAgICAgICAgICB2YXIgZ2l2ZW5Nb250aCA9IGN1cnJlbnQuY2xhc3NOYW1lLmluZGV4T2YoXCJNb250aFwiKSA9PT0gLTFcbiAgICAgICAgICAgICAgICA/IGN1cnJlbnQuZGF0ZU9iai5nZXRNb250aCgpXG4gICAgICAgICAgICAgICAgOiBzZWxmLmN1cnJlbnRNb250aDtcbiAgICAgICAgICAgIHZhciBlbmRNb250aCA9IGRlbHRhID4gMCA/IHNlbGYuY29uZmlnLnNob3dNb250aHMgOiAtMTtcbiAgICAgICAgICAgIHZhciBsb29wRGVsdGEgPSBkZWx0YSA+IDAgPyAxIDogLTE7XG4gICAgICAgICAgICBmb3IgKHZhciBtID0gZ2l2ZW5Nb250aCAtIHNlbGYuY3VycmVudE1vbnRoOyBtICE9IGVuZE1vbnRoOyBtICs9IGxvb3BEZWx0YSkge1xuICAgICAgICAgICAgICAgIHZhciBtb250aCA9IHNlbGYuZGF5c0NvbnRhaW5lci5jaGlsZHJlblttXTtcbiAgICAgICAgICAgICAgICB2YXIgc3RhcnRJbmRleCA9IGdpdmVuTW9udGggLSBzZWxmLmN1cnJlbnRNb250aCA9PT0gbVxuICAgICAgICAgICAgICAgICAgICA/IGN1cnJlbnQuJGkgKyBkZWx0YVxuICAgICAgICAgICAgICAgICAgICA6IGRlbHRhIDwgMFxuICAgICAgICAgICAgICAgICAgICAgICAgPyBtb250aC5jaGlsZHJlbi5sZW5ndGggLSAxXG4gICAgICAgICAgICAgICAgICAgICAgICA6IDA7XG4gICAgICAgICAgICAgICAgdmFyIG51bU1vbnRoRGF5cyA9IG1vbnRoLmNoaWxkcmVuLmxlbmd0aDtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gc3RhcnRJbmRleDsgaSA+PSAwICYmIGkgPCBudW1Nb250aERheXMgJiYgaSAhPSAoZGVsdGEgPiAwID8gbnVtTW9udGhEYXlzIDogLTEpOyBpICs9IGxvb3BEZWx0YSkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgYyA9IG1vbnRoLmNoaWxkcmVuW2ldO1xuICAgICAgICAgICAgICAgICAgICBpZiAoYy5jbGFzc05hbWUuaW5kZXhPZihcImhpZGRlblwiKSA9PT0gLTEgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgIGlzRW5hYmxlZChjLmRhdGVPYmopICYmXG4gICAgICAgICAgICAgICAgICAgICAgICBNYXRoLmFicyhjdXJyZW50LiRpIC0gaSkgPj0gTWF0aC5hYnMoZGVsdGEpKVxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZvY3VzT25EYXlFbGVtKGMpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHNlbGYuY2hhbmdlTW9udGgobG9vcERlbHRhKTtcbiAgICAgICAgICAgIGZvY3VzT25EYXkoZ2V0Rmlyc3RBdmFpbGFibGVEYXkobG9vcERlbHRhKSwgMCk7XG4gICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIGZvY3VzT25EYXkoY3VycmVudCwgb2Zmc2V0KSB7XG4gICAgICAgICAgICB2YXIgZGF5Rm9jdXNlZCA9IGlzSW5WaWV3KGRvY3VtZW50LmFjdGl2ZUVsZW1lbnQgfHwgZG9jdW1lbnQuYm9keSk7XG4gICAgICAgICAgICB2YXIgc3RhcnRFbGVtID0gY3VycmVudCAhPT0gdW5kZWZpbmVkXG4gICAgICAgICAgICAgICAgPyBjdXJyZW50XG4gICAgICAgICAgICAgICAgOiBkYXlGb2N1c2VkXG4gICAgICAgICAgICAgICAgICAgID8gZG9jdW1lbnQuYWN0aXZlRWxlbWVudFxuICAgICAgICAgICAgICAgICAgICA6IHNlbGYuc2VsZWN0ZWREYXRlRWxlbSAhPT0gdW5kZWZpbmVkICYmIGlzSW5WaWV3KHNlbGYuc2VsZWN0ZWREYXRlRWxlbSlcbiAgICAgICAgICAgICAgICAgICAgICAgID8gc2VsZi5zZWxlY3RlZERhdGVFbGVtXG4gICAgICAgICAgICAgICAgICAgICAgICA6IHNlbGYudG9kYXlEYXRlRWxlbSAhPT0gdW5kZWZpbmVkICYmIGlzSW5WaWV3KHNlbGYudG9kYXlEYXRlRWxlbSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA/IHNlbGYudG9kYXlEYXRlRWxlbVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDogZ2V0Rmlyc3RBdmFpbGFibGVEYXkob2Zmc2V0ID4gMCA/IDEgOiAtMSk7XG4gICAgICAgICAgICBpZiAoc3RhcnRFbGVtID09PSB1bmRlZmluZWQpXG4gICAgICAgICAgICAgICAgcmV0dXJuIHNlbGYuX2lucHV0LmZvY3VzKCk7XG4gICAgICAgICAgICBpZiAoIWRheUZvY3VzZWQpXG4gICAgICAgICAgICAgICAgcmV0dXJuIGZvY3VzT25EYXlFbGVtKHN0YXJ0RWxlbSk7XG4gICAgICAgICAgICBnZXROZXh0QXZhaWxhYmxlRGF5KHN0YXJ0RWxlbSwgb2Zmc2V0KTtcbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiBidWlsZE1vbnRoRGF5cyh5ZWFyLCBtb250aCkge1xuICAgICAgICAgICAgdmFyIGZpcnN0T2ZNb250aCA9IChuZXcgRGF0ZSh5ZWFyLCBtb250aCwgMSkuZ2V0RGF5KCkgLSBzZWxmLmwxMG4uZmlyc3REYXlPZldlZWsgKyA3KSAlIDc7XG4gICAgICAgICAgICB2YXIgcHJldk1vbnRoRGF5cyA9IHNlbGYudXRpbHMuZ2V0RGF5c0luTW9udGgoKG1vbnRoIC0gMSArIDEyKSAlIDEyKTtcbiAgICAgICAgICAgIHZhciBkYXlzSW5Nb250aCA9IHNlbGYudXRpbHMuZ2V0RGF5c0luTW9udGgobW9udGgpLCBkYXlzID0gd2luZG93LmRvY3VtZW50LmNyZWF0ZURvY3VtZW50RnJhZ21lbnQoKSwgaXNNdWx0aU1vbnRoID0gc2VsZi5jb25maWcuc2hvd01vbnRocyA+IDEsIHByZXZNb250aERheUNsYXNzID0gaXNNdWx0aU1vbnRoID8gXCJwcmV2TW9udGhEYXkgaGlkZGVuXCIgOiBcInByZXZNb250aERheVwiLCBuZXh0TW9udGhEYXlDbGFzcyA9IGlzTXVsdGlNb250aCA/IFwibmV4dE1vbnRoRGF5IGhpZGRlblwiIDogXCJuZXh0TW9udGhEYXlcIjtcbiAgICAgICAgICAgIHZhciBkYXlOdW1iZXIgPSBwcmV2TW9udGhEYXlzICsgMSAtIGZpcnN0T2ZNb250aCwgZGF5SW5kZXggPSAwO1xuICAgICAgICAgICAgLy8gcHJlcGVuZCBkYXlzIGZyb20gdGhlIGVuZGluZyBvZiBwcmV2aW91cyBtb250aFxuICAgICAgICAgICAgZm9yICg7IGRheU51bWJlciA8PSBwcmV2TW9udGhEYXlzOyBkYXlOdW1iZXIrKywgZGF5SW5kZXgrKykge1xuICAgICAgICAgICAgICAgIGRheXMuYXBwZW5kQ2hpbGQoY3JlYXRlRGF5KHByZXZNb250aERheUNsYXNzLCBuZXcgRGF0ZSh5ZWFyLCBtb250aCAtIDEsIGRheU51bWJlciksIGRheU51bWJlciwgZGF5SW5kZXgpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIFN0YXJ0IGF0IDEgc2luY2UgdGhlcmUgaXMgbm8gMHRoIGRheVxuICAgICAgICAgICAgZm9yIChkYXlOdW1iZXIgPSAxOyBkYXlOdW1iZXIgPD0gZGF5c0luTW9udGg7IGRheU51bWJlcisrLCBkYXlJbmRleCsrKSB7XG4gICAgICAgICAgICAgICAgZGF5cy5hcHBlbmRDaGlsZChjcmVhdGVEYXkoXCJcIiwgbmV3IERhdGUoeWVhciwgbW9udGgsIGRheU51bWJlciksIGRheU51bWJlciwgZGF5SW5kZXgpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIGFwcGVuZCBkYXlzIGZyb20gdGhlIG5leHQgbW9udGhcbiAgICAgICAgICAgIGZvciAodmFyIGRheU51bSA9IGRheXNJbk1vbnRoICsgMTsgZGF5TnVtIDw9IDQyIC0gZmlyc3RPZk1vbnRoICYmXG4gICAgICAgICAgICAgICAgKHNlbGYuY29uZmlnLnNob3dNb250aHMgPT09IDEgfHwgZGF5SW5kZXggJSA3ICE9PSAwKTsgZGF5TnVtKyssIGRheUluZGV4KyspIHtcbiAgICAgICAgICAgICAgICBkYXlzLmFwcGVuZENoaWxkKGNyZWF0ZURheShuZXh0TW9udGhEYXlDbGFzcywgbmV3IERhdGUoeWVhciwgbW9udGggKyAxLCBkYXlOdW0gJSBkYXlzSW5Nb250aCksIGRheU51bSwgZGF5SW5kZXgpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vdXBkYXRlTmF2aWdhdGlvbkN1cnJlbnRNb250aCgpO1xuICAgICAgICAgICAgdmFyIGRheUNvbnRhaW5lciA9IGNyZWF0ZUVsZW1lbnQoXCJkaXZcIiwgXCJkYXlDb250YWluZXJcIik7XG4gICAgICAgICAgICBkYXlDb250YWluZXIuYXBwZW5kQ2hpbGQoZGF5cyk7XG4gICAgICAgICAgICByZXR1cm4gZGF5Q29udGFpbmVyO1xuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIGJ1aWxkRGF5cygpIHtcbiAgICAgICAgICAgIGlmIChzZWxmLmRheXNDb250YWluZXIgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNsZWFyTm9kZShzZWxmLmRheXNDb250YWluZXIpO1xuICAgICAgICAgICAgLy8gVE9ETzogd2VlayBudW1iZXJzIGZvciBlYWNoIG1vbnRoXG4gICAgICAgICAgICBpZiAoc2VsZi53ZWVrTnVtYmVycylcbiAgICAgICAgICAgICAgICBjbGVhck5vZGUoc2VsZi53ZWVrTnVtYmVycyk7XG4gICAgICAgICAgICB2YXIgZnJhZyA9IGRvY3VtZW50LmNyZWF0ZURvY3VtZW50RnJhZ21lbnQoKTtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgc2VsZi5jb25maWcuc2hvd01vbnRoczsgaSsrKSB7XG4gICAgICAgICAgICAgICAgdmFyIGQgPSBuZXcgRGF0ZShzZWxmLmN1cnJlbnRZZWFyLCBzZWxmLmN1cnJlbnRNb250aCwgMSk7XG4gICAgICAgICAgICAgICAgZC5zZXRNb250aChzZWxmLmN1cnJlbnRNb250aCArIGkpO1xuICAgICAgICAgICAgICAgIGZyYWcuYXBwZW5kQ2hpbGQoYnVpbGRNb250aERheXMoZC5nZXRGdWxsWWVhcigpLCBkLmdldE1vbnRoKCkpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHNlbGYuZGF5c0NvbnRhaW5lci5hcHBlbmRDaGlsZChmcmFnKTtcbiAgICAgICAgICAgIHNlbGYuZGF5cyA9IHNlbGYuZGF5c0NvbnRhaW5lci5maXJzdENoaWxkO1xuICAgICAgICAgICAgaWYgKHNlbGYuY29uZmlnLm1vZGUgPT09IFwicmFuZ2VcIiAmJiBzZWxmLnNlbGVjdGVkRGF0ZXMubGVuZ3RoID09PSAxKSB7XG4gICAgICAgICAgICAgICAgb25Nb3VzZU92ZXIoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiBidWlsZE1vbnRoU3dpdGNoKCkge1xuICAgICAgICAgICAgaWYgKHNlbGYuY29uZmlnLnNob3dNb250aHMgPiAxIHx8XG4gICAgICAgICAgICAgICAgc2VsZi5jb25maWcubW9udGhTZWxlY3RvclR5cGUgIT09IFwiZHJvcGRvd25cIilcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB2YXIgc2hvdWxkQnVpbGRNb250aCA9IGZ1bmN0aW9uIChtb250aCkge1xuICAgICAgICAgICAgICAgIGlmIChzZWxmLmNvbmZpZy5taW5EYXRlICE9PSB1bmRlZmluZWQgJiZcbiAgICAgICAgICAgICAgICAgICAgc2VsZi5jdXJyZW50WWVhciA9PT0gc2VsZi5jb25maWcubWluRGF0ZS5nZXRGdWxsWWVhcigpICYmXG4gICAgICAgICAgICAgICAgICAgIG1vbnRoIDwgc2VsZi5jb25maWcubWluRGF0ZS5nZXRNb250aCgpKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuICEoc2VsZi5jb25maWcubWF4RGF0ZSAhPT0gdW5kZWZpbmVkICYmXG4gICAgICAgICAgICAgICAgICAgIHNlbGYuY3VycmVudFllYXIgPT09IHNlbGYuY29uZmlnLm1heERhdGUuZ2V0RnVsbFllYXIoKSAmJlxuICAgICAgICAgICAgICAgICAgICBtb250aCA+IHNlbGYuY29uZmlnLm1heERhdGUuZ2V0TW9udGgoKSk7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgc2VsZi5tb250aHNEcm9wZG93bkNvbnRhaW5lci50YWJJbmRleCA9IC0xO1xuICAgICAgICAgICAgc2VsZi5tb250aHNEcm9wZG93bkNvbnRhaW5lci5pbm5lckhUTUwgPSBcIlwiO1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCAxMjsgaSsrKSB7XG4gICAgICAgICAgICAgICAgaWYgKCFzaG91bGRCdWlsZE1vbnRoKGkpKVxuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICB2YXIgbW9udGggPSBjcmVhdGVFbGVtZW50KFwib3B0aW9uXCIsIFwiZmxhdHBpY2tyLW1vbnRoRHJvcGRvd24tbW9udGhcIik7XG4gICAgICAgICAgICAgICAgbW9udGgudmFsdWUgPSBuZXcgRGF0ZShzZWxmLmN1cnJlbnRZZWFyLCBpKS5nZXRNb250aCgpLnRvU3RyaW5nKCk7XG4gICAgICAgICAgICAgICAgbW9udGgudGV4dENvbnRlbnQgPSBtb250aFRvU3RyKGksIHNlbGYuY29uZmlnLnNob3J0aGFuZEN1cnJlbnRNb250aCwgc2VsZi5sMTBuKTtcbiAgICAgICAgICAgICAgICBtb250aC50YWJJbmRleCA9IC0xO1xuICAgICAgICAgICAgICAgIGlmIChzZWxmLmN1cnJlbnRNb250aCA9PT0gaSkge1xuICAgICAgICAgICAgICAgICAgICBtb250aC5zZWxlY3RlZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHNlbGYubW9udGhzRHJvcGRvd25Db250YWluZXIuYXBwZW5kQ2hpbGQobW9udGgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIGJ1aWxkTW9udGgoKSB7XG4gICAgICAgICAgICB2YXIgY29udGFpbmVyID0gY3JlYXRlRWxlbWVudChcImRpdlwiLCBcImZsYXRwaWNrci1tb250aFwiKTtcbiAgICAgICAgICAgIHZhciBtb250aE5hdkZyYWdtZW50ID0gd2luZG93LmRvY3VtZW50LmNyZWF0ZURvY3VtZW50RnJhZ21lbnQoKTtcbiAgICAgICAgICAgIHZhciBtb250aEVsZW1lbnQ7XG4gICAgICAgICAgICBpZiAoc2VsZi5jb25maWcuc2hvd01vbnRocyA+IDEgfHxcbiAgICAgICAgICAgICAgICBzZWxmLmNvbmZpZy5tb250aFNlbGVjdG9yVHlwZSA9PT0gXCJzdGF0aWNcIikge1xuICAgICAgICAgICAgICAgIG1vbnRoRWxlbWVudCA9IGNyZWF0ZUVsZW1lbnQoXCJzcGFuXCIsIFwiY3VyLW1vbnRoXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgc2VsZi5tb250aHNEcm9wZG93bkNvbnRhaW5lciA9IGNyZWF0ZUVsZW1lbnQoXCJzZWxlY3RcIiwgXCJmbGF0cGlja3ItbW9udGhEcm9wZG93bi1tb250aHNcIik7XG4gICAgICAgICAgICAgICAgYmluZChzZWxmLm1vbnRoc0Ryb3Bkb3duQ29udGFpbmVyLCBcImNoYW5nZVwiLCBmdW5jdGlvbiAoZSkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgdGFyZ2V0ID0gZS50YXJnZXQ7XG4gICAgICAgICAgICAgICAgICAgIHZhciBzZWxlY3RlZE1vbnRoID0gcGFyc2VJbnQodGFyZ2V0LnZhbHVlLCAxMCk7XG4gICAgICAgICAgICAgICAgICAgIHNlbGYuY2hhbmdlTW9udGgoc2VsZWN0ZWRNb250aCAtIHNlbGYuY3VycmVudE1vbnRoKTtcbiAgICAgICAgICAgICAgICAgICAgdHJpZ2dlckV2ZW50KFwib25Nb250aENoYW5nZVwiKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBidWlsZE1vbnRoU3dpdGNoKCk7XG4gICAgICAgICAgICAgICAgbW9udGhFbGVtZW50ID0gc2VsZi5tb250aHNEcm9wZG93bkNvbnRhaW5lcjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciB5ZWFySW5wdXQgPSBjcmVhdGVOdW1iZXJJbnB1dChcImN1ci15ZWFyXCIsIHsgdGFiaW5kZXg6IFwiLTFcIiB9KTtcbiAgICAgICAgICAgIHZhciB5ZWFyRWxlbWVudCA9IHllYXJJbnB1dC5nZXRFbGVtZW50c0J5VGFnTmFtZShcImlucHV0XCIpWzBdO1xuICAgICAgICAgICAgeWVhckVsZW1lbnQuc2V0QXR0cmlidXRlKFwiYXJpYS1sYWJlbFwiLCBzZWxmLmwxMG4ueWVhckFyaWFMYWJlbCk7XG4gICAgICAgICAgICBpZiAoc2VsZi5jb25maWcubWluRGF0ZSkge1xuICAgICAgICAgICAgICAgIHllYXJFbGVtZW50LnNldEF0dHJpYnV0ZShcIm1pblwiLCBzZWxmLmNvbmZpZy5taW5EYXRlLmdldEZ1bGxZZWFyKCkudG9TdHJpbmcoKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoc2VsZi5jb25maWcubWF4RGF0ZSkge1xuICAgICAgICAgICAgICAgIHllYXJFbGVtZW50LnNldEF0dHJpYnV0ZShcIm1heFwiLCBzZWxmLmNvbmZpZy5tYXhEYXRlLmdldEZ1bGxZZWFyKCkudG9TdHJpbmcoKSk7XG4gICAgICAgICAgICAgICAgeWVhckVsZW1lbnQuZGlzYWJsZWQgPVxuICAgICAgICAgICAgICAgICAgICAhIXNlbGYuY29uZmlnLm1pbkRhdGUgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgIHNlbGYuY29uZmlnLm1pbkRhdGUuZ2V0RnVsbFllYXIoKSA9PT0gc2VsZi5jb25maWcubWF4RGF0ZS5nZXRGdWxsWWVhcigpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIGN1cnJlbnRNb250aCA9IGNyZWF0ZUVsZW1lbnQoXCJkaXZcIiwgXCJmbGF0cGlja3ItY3VycmVudC1tb250aFwiKTtcbiAgICAgICAgICAgIGN1cnJlbnRNb250aC5hcHBlbmRDaGlsZChtb250aEVsZW1lbnQpO1xuICAgICAgICAgICAgY3VycmVudE1vbnRoLmFwcGVuZENoaWxkKHllYXJJbnB1dCk7XG4gICAgICAgICAgICBtb250aE5hdkZyYWdtZW50LmFwcGVuZENoaWxkKGN1cnJlbnRNb250aCk7XG4gICAgICAgICAgICBjb250YWluZXIuYXBwZW5kQ2hpbGQobW9udGhOYXZGcmFnbWVudCk7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIGNvbnRhaW5lcjogY29udGFpbmVyLFxuICAgICAgICAgICAgICAgIHllYXJFbGVtZW50OiB5ZWFyRWxlbWVudCxcbiAgICAgICAgICAgICAgICBtb250aEVsZW1lbnQ6IG1vbnRoRWxlbWVudFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiBidWlsZE1vbnRocygpIHtcbiAgICAgICAgICAgIGNsZWFyTm9kZShzZWxmLm1vbnRoTmF2KTtcbiAgICAgICAgICAgIHNlbGYubW9udGhOYXYuYXBwZW5kQ2hpbGQoc2VsZi5wcmV2TW9udGhOYXYpO1xuICAgICAgICAgICAgaWYgKHNlbGYuY29uZmlnLnNob3dNb250aHMpIHtcbiAgICAgICAgICAgICAgICBzZWxmLnllYXJFbGVtZW50cyA9IFtdO1xuICAgICAgICAgICAgICAgIHNlbGYubW9udGhFbGVtZW50cyA9IFtdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZm9yICh2YXIgbSA9IHNlbGYuY29uZmlnLnNob3dNb250aHM7IG0tLTspIHtcbiAgICAgICAgICAgICAgICB2YXIgbW9udGggPSBidWlsZE1vbnRoKCk7XG4gICAgICAgICAgICAgICAgc2VsZi55ZWFyRWxlbWVudHMucHVzaChtb250aC55ZWFyRWxlbWVudCk7XG4gICAgICAgICAgICAgICAgc2VsZi5tb250aEVsZW1lbnRzLnB1c2gobW9udGgubW9udGhFbGVtZW50KTtcbiAgICAgICAgICAgICAgICBzZWxmLm1vbnRoTmF2LmFwcGVuZENoaWxkKG1vbnRoLmNvbnRhaW5lcik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBzZWxmLm1vbnRoTmF2LmFwcGVuZENoaWxkKHNlbGYubmV4dE1vbnRoTmF2KTtcbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiBidWlsZE1vbnRoTmF2KCkge1xuICAgICAgICAgICAgc2VsZi5tb250aE5hdiA9IGNyZWF0ZUVsZW1lbnQoXCJkaXZcIiwgXCJmbGF0cGlja3ItbW9udGhzXCIpO1xuICAgICAgICAgICAgc2VsZi55ZWFyRWxlbWVudHMgPSBbXTtcbiAgICAgICAgICAgIHNlbGYubW9udGhFbGVtZW50cyA9IFtdO1xuICAgICAgICAgICAgc2VsZi5wcmV2TW9udGhOYXYgPSBjcmVhdGVFbGVtZW50KFwic3BhblwiLCBcImZsYXRwaWNrci1wcmV2LW1vbnRoXCIpO1xuICAgICAgICAgICAgc2VsZi5wcmV2TW9udGhOYXYuaW5uZXJIVE1MID0gc2VsZi5jb25maWcucHJldkFycm93O1xuICAgICAgICAgICAgc2VsZi5uZXh0TW9udGhOYXYgPSBjcmVhdGVFbGVtZW50KFwic3BhblwiLCBcImZsYXRwaWNrci1uZXh0LW1vbnRoXCIpO1xuICAgICAgICAgICAgc2VsZi5uZXh0TW9udGhOYXYuaW5uZXJIVE1MID0gc2VsZi5jb25maWcubmV4dEFycm93O1xuICAgICAgICAgICAgYnVpbGRNb250aHMoKTtcbiAgICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShzZWxmLCBcIl9oaWRlUHJldk1vbnRoQXJyb3dcIiwge1xuICAgICAgICAgICAgICAgIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gc2VsZi5fX2hpZGVQcmV2TW9udGhBcnJvdzsgfSxcbiAgICAgICAgICAgICAgICBzZXQ6IGZ1bmN0aW9uIChib29sKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChzZWxmLl9faGlkZVByZXZNb250aEFycm93ICE9PSBib29sKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0b2dnbGVDbGFzcyhzZWxmLnByZXZNb250aE5hdiwgXCJmbGF0cGlja3ItZGlzYWJsZWRcIiwgYm9vbCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBzZWxmLl9faGlkZVByZXZNb250aEFycm93ID0gYm9vbDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHNlbGYsIFwiX2hpZGVOZXh0TW9udGhBcnJvd1wiLCB7XG4gICAgICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBzZWxmLl9faGlkZU5leHRNb250aEFycm93OyB9LFxuICAgICAgICAgICAgICAgIHNldDogZnVuY3Rpb24gKGJvb2wpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHNlbGYuX19oaWRlTmV4dE1vbnRoQXJyb3cgIT09IGJvb2wpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRvZ2dsZUNsYXNzKHNlbGYubmV4dE1vbnRoTmF2LCBcImZsYXRwaWNrci1kaXNhYmxlZFwiLCBib29sKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNlbGYuX19oaWRlTmV4dE1vbnRoQXJyb3cgPSBib29sO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBzZWxmLmN1cnJlbnRZZWFyRWxlbWVudCA9IHNlbGYueWVhckVsZW1lbnRzWzBdO1xuICAgICAgICAgICAgdXBkYXRlTmF2aWdhdGlvbkN1cnJlbnRNb250aCgpO1xuICAgICAgICAgICAgcmV0dXJuIHNlbGYubW9udGhOYXY7XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gYnVpbGRUaW1lKCkge1xuICAgICAgICAgICAgc2VsZi5jYWxlbmRhckNvbnRhaW5lci5jbGFzc0xpc3QuYWRkKFwiaGFzVGltZVwiKTtcbiAgICAgICAgICAgIGlmIChzZWxmLmNvbmZpZy5ub0NhbGVuZGFyKVxuICAgICAgICAgICAgICAgIHNlbGYuY2FsZW5kYXJDb250YWluZXIuY2xhc3NMaXN0LmFkZChcIm5vQ2FsZW5kYXJcIik7XG4gICAgICAgICAgICBzZWxmLnRpbWVDb250YWluZXIgPSBjcmVhdGVFbGVtZW50KFwiZGl2XCIsIFwiZmxhdHBpY2tyLXRpbWVcIik7XG4gICAgICAgICAgICBzZWxmLnRpbWVDb250YWluZXIudGFiSW5kZXggPSAtMTtcbiAgICAgICAgICAgIHZhciBzZXBhcmF0b3IgPSBjcmVhdGVFbGVtZW50KFwic3BhblwiLCBcImZsYXRwaWNrci10aW1lLXNlcGFyYXRvclwiLCBcIjpcIik7XG4gICAgICAgICAgICB2YXIgaG91cklucHV0ID0gY3JlYXRlTnVtYmVySW5wdXQoXCJmbGF0cGlja3ItaG91clwiLCB7XG4gICAgICAgICAgICAgICAgXCJhcmlhLWxhYmVsXCI6IHNlbGYubDEwbi5ob3VyQXJpYUxhYmVsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHNlbGYuaG91ckVsZW1lbnQgPSBob3VySW5wdXQuZ2V0RWxlbWVudHNCeVRhZ05hbWUoXCJpbnB1dFwiKVswXTtcbiAgICAgICAgICAgIHZhciBtaW51dGVJbnB1dCA9IGNyZWF0ZU51bWJlcklucHV0KFwiZmxhdHBpY2tyLW1pbnV0ZVwiLCB7XG4gICAgICAgICAgICAgICAgXCJhcmlhLWxhYmVsXCI6IHNlbGYubDEwbi5taW51dGVBcmlhTGFiZWxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgc2VsZi5taW51dGVFbGVtZW50ID0gbWludXRlSW5wdXQuZ2V0RWxlbWVudHNCeVRhZ05hbWUoXCJpbnB1dFwiKVswXTtcbiAgICAgICAgICAgIHNlbGYuaG91ckVsZW1lbnQudGFiSW5kZXggPSBzZWxmLm1pbnV0ZUVsZW1lbnQudGFiSW5kZXggPSAtMTtcbiAgICAgICAgICAgIHNlbGYuaG91ckVsZW1lbnQudmFsdWUgPSBwYWQoc2VsZi5sYXRlc3RTZWxlY3RlZERhdGVPYmpcbiAgICAgICAgICAgICAgICA/IHNlbGYubGF0ZXN0U2VsZWN0ZWREYXRlT2JqLmdldEhvdXJzKClcbiAgICAgICAgICAgICAgICA6IHNlbGYuY29uZmlnLnRpbWVfMjRoclxuICAgICAgICAgICAgICAgICAgICA/IHNlbGYuY29uZmlnLmRlZmF1bHRIb3VyXG4gICAgICAgICAgICAgICAgICAgIDogbWlsaXRhcnkyYW1wbShzZWxmLmNvbmZpZy5kZWZhdWx0SG91cikpO1xuICAgICAgICAgICAgc2VsZi5taW51dGVFbGVtZW50LnZhbHVlID0gcGFkKHNlbGYubGF0ZXN0U2VsZWN0ZWREYXRlT2JqXG4gICAgICAgICAgICAgICAgPyBzZWxmLmxhdGVzdFNlbGVjdGVkRGF0ZU9iai5nZXRNaW51dGVzKClcbiAgICAgICAgICAgICAgICA6IHNlbGYuY29uZmlnLmRlZmF1bHRNaW51dGUpO1xuICAgICAgICAgICAgc2VsZi5ob3VyRWxlbWVudC5zZXRBdHRyaWJ1dGUoXCJzdGVwXCIsIHNlbGYuY29uZmlnLmhvdXJJbmNyZW1lbnQudG9TdHJpbmcoKSk7XG4gICAgICAgICAgICBzZWxmLm1pbnV0ZUVsZW1lbnQuc2V0QXR0cmlidXRlKFwic3RlcFwiLCBzZWxmLmNvbmZpZy5taW51dGVJbmNyZW1lbnQudG9TdHJpbmcoKSk7XG4gICAgICAgICAgICBzZWxmLmhvdXJFbGVtZW50LnNldEF0dHJpYnV0ZShcIm1pblwiLCBzZWxmLmNvbmZpZy50aW1lXzI0aHIgPyBcIjBcIiA6IFwiMVwiKTtcbiAgICAgICAgICAgIHNlbGYuaG91ckVsZW1lbnQuc2V0QXR0cmlidXRlKFwibWF4XCIsIHNlbGYuY29uZmlnLnRpbWVfMjRociA/IFwiMjNcIiA6IFwiMTJcIik7XG4gICAgICAgICAgICBzZWxmLm1pbnV0ZUVsZW1lbnQuc2V0QXR0cmlidXRlKFwibWluXCIsIFwiMFwiKTtcbiAgICAgICAgICAgIHNlbGYubWludXRlRWxlbWVudC5zZXRBdHRyaWJ1dGUoXCJtYXhcIiwgXCI1OVwiKTtcbiAgICAgICAgICAgIHNlbGYudGltZUNvbnRhaW5lci5hcHBlbmRDaGlsZChob3VySW5wdXQpO1xuICAgICAgICAgICAgc2VsZi50aW1lQ29udGFpbmVyLmFwcGVuZENoaWxkKHNlcGFyYXRvcik7XG4gICAgICAgICAgICBzZWxmLnRpbWVDb250YWluZXIuYXBwZW5kQ2hpbGQobWludXRlSW5wdXQpO1xuICAgICAgICAgICAgaWYgKHNlbGYuY29uZmlnLnRpbWVfMjRocilcbiAgICAgICAgICAgICAgICBzZWxmLnRpbWVDb250YWluZXIuY2xhc3NMaXN0LmFkZChcInRpbWUyNGhyXCIpO1xuICAgICAgICAgICAgaWYgKHNlbGYuY29uZmlnLmVuYWJsZVNlY29uZHMpIHtcbiAgICAgICAgICAgICAgICBzZWxmLnRpbWVDb250YWluZXIuY2xhc3NMaXN0LmFkZChcImhhc1NlY29uZHNcIik7XG4gICAgICAgICAgICAgICAgdmFyIHNlY29uZElucHV0ID0gY3JlYXRlTnVtYmVySW5wdXQoXCJmbGF0cGlja3Itc2Vjb25kXCIpO1xuICAgICAgICAgICAgICAgIHNlbGYuc2Vjb25kRWxlbWVudCA9IHNlY29uZElucHV0LmdldEVsZW1lbnRzQnlUYWdOYW1lKFwiaW5wdXRcIilbMF07XG4gICAgICAgICAgICAgICAgc2VsZi5zZWNvbmRFbGVtZW50LnZhbHVlID0gcGFkKHNlbGYubGF0ZXN0U2VsZWN0ZWREYXRlT2JqXG4gICAgICAgICAgICAgICAgICAgID8gc2VsZi5sYXRlc3RTZWxlY3RlZERhdGVPYmouZ2V0U2Vjb25kcygpXG4gICAgICAgICAgICAgICAgICAgIDogc2VsZi5jb25maWcuZGVmYXVsdFNlY29uZHMpO1xuICAgICAgICAgICAgICAgIHNlbGYuc2Vjb25kRWxlbWVudC5zZXRBdHRyaWJ1dGUoXCJzdGVwXCIsIHNlbGYubWludXRlRWxlbWVudC5nZXRBdHRyaWJ1dGUoXCJzdGVwXCIpKTtcbiAgICAgICAgICAgICAgICBzZWxmLnNlY29uZEVsZW1lbnQuc2V0QXR0cmlidXRlKFwibWluXCIsIFwiMFwiKTtcbiAgICAgICAgICAgICAgICBzZWxmLnNlY29uZEVsZW1lbnQuc2V0QXR0cmlidXRlKFwibWF4XCIsIFwiNTlcIik7XG4gICAgICAgICAgICAgICAgc2VsZi50aW1lQ29udGFpbmVyLmFwcGVuZENoaWxkKGNyZWF0ZUVsZW1lbnQoXCJzcGFuXCIsIFwiZmxhdHBpY2tyLXRpbWUtc2VwYXJhdG9yXCIsIFwiOlwiKSk7XG4gICAgICAgICAgICAgICAgc2VsZi50aW1lQ29udGFpbmVyLmFwcGVuZENoaWxkKHNlY29uZElucHV0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghc2VsZi5jb25maWcudGltZV8yNGhyKSB7XG4gICAgICAgICAgICAgICAgLy8gYWRkIHNlbGYuYW1QTSBpZiBhcHByb3ByaWF0ZVxuICAgICAgICAgICAgICAgIHNlbGYuYW1QTSA9IGNyZWF0ZUVsZW1lbnQoXCJzcGFuXCIsIFwiZmxhdHBpY2tyLWFtLXBtXCIsIHNlbGYubDEwbi5hbVBNW2ludCgoc2VsZi5sYXRlc3RTZWxlY3RlZERhdGVPYmpcbiAgICAgICAgICAgICAgICAgICAgPyBzZWxmLmhvdXJFbGVtZW50LnZhbHVlXG4gICAgICAgICAgICAgICAgICAgIDogc2VsZi5jb25maWcuZGVmYXVsdEhvdXIpID4gMTEpXSk7XG4gICAgICAgICAgICAgICAgc2VsZi5hbVBNLnRpdGxlID0gc2VsZi5sMTBuLnRvZ2dsZVRpdGxlO1xuICAgICAgICAgICAgICAgIHNlbGYuYW1QTS50YWJJbmRleCA9IC0xO1xuICAgICAgICAgICAgICAgIHNlbGYudGltZUNvbnRhaW5lci5hcHBlbmRDaGlsZChzZWxmLmFtUE0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHNlbGYudGltZUNvbnRhaW5lcjtcbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiBidWlsZFdlZWtkYXlzKCkge1xuICAgICAgICAgICAgaWYgKCFzZWxmLndlZWtkYXlDb250YWluZXIpXG4gICAgICAgICAgICAgICAgc2VsZi53ZWVrZGF5Q29udGFpbmVyID0gY3JlYXRlRWxlbWVudChcImRpdlwiLCBcImZsYXRwaWNrci13ZWVrZGF5c1wiKTtcbiAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICBjbGVhck5vZGUoc2VsZi53ZWVrZGF5Q29udGFpbmVyKTtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSBzZWxmLmNvbmZpZy5zaG93TW9udGhzOyBpLS07KSB7XG4gICAgICAgICAgICAgICAgdmFyIGNvbnRhaW5lciA9IGNyZWF0ZUVsZW1lbnQoXCJkaXZcIiwgXCJmbGF0cGlja3Itd2Vla2RheWNvbnRhaW5lclwiKTtcbiAgICAgICAgICAgICAgICBzZWxmLndlZWtkYXlDb250YWluZXIuYXBwZW5kQ2hpbGQoY29udGFpbmVyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHVwZGF0ZVdlZWtkYXlzKCk7XG4gICAgICAgICAgICByZXR1cm4gc2VsZi53ZWVrZGF5Q29udGFpbmVyO1xuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIHVwZGF0ZVdlZWtkYXlzKCkge1xuICAgICAgICAgICAgdmFyIGZpcnN0RGF5T2ZXZWVrID0gc2VsZi5sMTBuLmZpcnN0RGF5T2ZXZWVrO1xuICAgICAgICAgICAgdmFyIHdlZWtkYXlzID0gc2VsZi5sMTBuLndlZWtkYXlzLnNob3J0aGFuZC5zbGljZSgpO1xuICAgICAgICAgICAgaWYgKGZpcnN0RGF5T2ZXZWVrID4gMCAmJiBmaXJzdERheU9mV2VlayA8IHdlZWtkYXlzLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIHdlZWtkYXlzID0gd2Vla2RheXMuc3BsaWNlKGZpcnN0RGF5T2ZXZWVrLCB3ZWVrZGF5cy5sZW5ndGgpLmNvbmNhdCh3ZWVrZGF5cy5zcGxpY2UoMCwgZmlyc3REYXlPZldlZWspKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZvciAodmFyIGkgPSBzZWxmLmNvbmZpZy5zaG93TW9udGhzOyBpLS07KSB7XG4gICAgICAgICAgICAgICAgc2VsZi53ZWVrZGF5Q29udGFpbmVyLmNoaWxkcmVuW2ldLmlubmVySFRNTCA9IFwiXFxuICAgICAgPHNwYW4gY2xhc3M9J2ZsYXRwaWNrci13ZWVrZGF5Jz5cXG4gICAgICAgIFwiICsgd2Vla2RheXMuam9pbihcIjwvc3Bhbj48c3BhbiBjbGFzcz0nZmxhdHBpY2tyLXdlZWtkYXknPlwiKSArIFwiXFxuICAgICAgPC9zcGFuPlxcbiAgICAgIFwiO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG4gICAgICAgIGZ1bmN0aW9uIGJ1aWxkV2Vla3MoKSB7XG4gICAgICAgICAgICBzZWxmLmNhbGVuZGFyQ29udGFpbmVyLmNsYXNzTGlzdC5hZGQoXCJoYXNXZWVrc1wiKTtcbiAgICAgICAgICAgIHZhciB3ZWVrV3JhcHBlciA9IGNyZWF0ZUVsZW1lbnQoXCJkaXZcIiwgXCJmbGF0cGlja3Itd2Vla3dyYXBwZXJcIik7XG4gICAgICAgICAgICB3ZWVrV3JhcHBlci5hcHBlbmRDaGlsZChjcmVhdGVFbGVtZW50KFwic3BhblwiLCBcImZsYXRwaWNrci13ZWVrZGF5XCIsIHNlbGYubDEwbi53ZWVrQWJicmV2aWF0aW9uKSk7XG4gICAgICAgICAgICB2YXIgd2Vla051bWJlcnMgPSBjcmVhdGVFbGVtZW50KFwiZGl2XCIsIFwiZmxhdHBpY2tyLXdlZWtzXCIpO1xuICAgICAgICAgICAgd2Vla1dyYXBwZXIuYXBwZW5kQ2hpbGQod2Vla051bWJlcnMpO1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICB3ZWVrV3JhcHBlcjogd2Vla1dyYXBwZXIsXG4gICAgICAgICAgICAgICAgd2Vla051bWJlcnM6IHdlZWtOdW1iZXJzXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIGNoYW5nZU1vbnRoKHZhbHVlLCBpc09mZnNldCkge1xuICAgICAgICAgICAgaWYgKGlzT2Zmc2V0ID09PSB2b2lkIDApIHsgaXNPZmZzZXQgPSB0cnVlOyB9XG4gICAgICAgICAgICB2YXIgZGVsdGEgPSBpc09mZnNldCA/IHZhbHVlIDogdmFsdWUgLSBzZWxmLmN1cnJlbnRNb250aDtcbiAgICAgICAgICAgIGlmICgoZGVsdGEgPCAwICYmIHNlbGYuX2hpZGVQcmV2TW9udGhBcnJvdyA9PT0gdHJ1ZSkgfHxcbiAgICAgICAgICAgICAgICAoZGVsdGEgPiAwICYmIHNlbGYuX2hpZGVOZXh0TW9udGhBcnJvdyA9PT0gdHJ1ZSkpXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgc2VsZi5jdXJyZW50TW9udGggKz0gZGVsdGE7XG4gICAgICAgICAgICBpZiAoc2VsZi5jdXJyZW50TW9udGggPCAwIHx8IHNlbGYuY3VycmVudE1vbnRoID4gMTEpIHtcbiAgICAgICAgICAgICAgICBzZWxmLmN1cnJlbnRZZWFyICs9IHNlbGYuY3VycmVudE1vbnRoID4gMTEgPyAxIDogLTE7XG4gICAgICAgICAgICAgICAgc2VsZi5jdXJyZW50TW9udGggPSAoc2VsZi5jdXJyZW50TW9udGggKyAxMikgJSAxMjtcbiAgICAgICAgICAgICAgICB0cmlnZ2VyRXZlbnQoXCJvblllYXJDaGFuZ2VcIik7XG4gICAgICAgICAgICAgICAgYnVpbGRNb250aFN3aXRjaCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYnVpbGREYXlzKCk7XG4gICAgICAgICAgICB0cmlnZ2VyRXZlbnQoXCJvbk1vbnRoQ2hhbmdlXCIpO1xuICAgICAgICAgICAgdXBkYXRlTmF2aWdhdGlvbkN1cnJlbnRNb250aCgpO1xuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIGNsZWFyKHRyaWdnZXJDaGFuZ2VFdmVudCwgdG9Jbml0aWFsKSB7XG4gICAgICAgICAgICBpZiAodHJpZ2dlckNoYW5nZUV2ZW50ID09PSB2b2lkIDApIHsgdHJpZ2dlckNoYW5nZUV2ZW50ID0gdHJ1ZTsgfVxuICAgICAgICAgICAgaWYgKHRvSW5pdGlhbCA9PT0gdm9pZCAwKSB7IHRvSW5pdGlhbCA9IHRydWU7IH1cbiAgICAgICAgICAgIHNlbGYuaW5wdXQudmFsdWUgPSBcIlwiO1xuICAgICAgICAgICAgaWYgKHNlbGYuYWx0SW5wdXQgIT09IHVuZGVmaW5lZClcbiAgICAgICAgICAgICAgICBzZWxmLmFsdElucHV0LnZhbHVlID0gXCJcIjtcbiAgICAgICAgICAgIGlmIChzZWxmLm1vYmlsZUlucHV0ICE9PSB1bmRlZmluZWQpXG4gICAgICAgICAgICAgICAgc2VsZi5tb2JpbGVJbnB1dC52YWx1ZSA9IFwiXCI7XG4gICAgICAgICAgICBzZWxmLnNlbGVjdGVkRGF0ZXMgPSBbXTtcbiAgICAgICAgICAgIHNlbGYubGF0ZXN0U2VsZWN0ZWREYXRlT2JqID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgaWYgKHRvSW5pdGlhbCA9PT0gdHJ1ZSkge1xuICAgICAgICAgICAgICAgIHNlbGYuY3VycmVudFllYXIgPSBzZWxmLl9pbml0aWFsRGF0ZS5nZXRGdWxsWWVhcigpO1xuICAgICAgICAgICAgICAgIHNlbGYuY3VycmVudE1vbnRoID0gc2VsZi5faW5pdGlhbERhdGUuZ2V0TW9udGgoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHNlbGYuc2hvd1RpbWVJbnB1dCA9IGZhbHNlO1xuICAgICAgICAgICAgaWYgKHNlbGYuY29uZmlnLmVuYWJsZVRpbWUgPT09IHRydWUpIHtcbiAgICAgICAgICAgICAgICBzZXREZWZhdWx0SG91cnMoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHNlbGYucmVkcmF3KCk7XG4gICAgICAgICAgICBpZiAodHJpZ2dlckNoYW5nZUV2ZW50KVxuICAgICAgICAgICAgICAgIC8vIHRyaWdnZXJDaGFuZ2VFdmVudCBpcyB0cnVlIChkZWZhdWx0KSBvciBhbiBFdmVudFxuICAgICAgICAgICAgICAgIHRyaWdnZXJFdmVudChcIm9uQ2hhbmdlXCIpO1xuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIGNsb3NlKCkge1xuICAgICAgICAgICAgc2VsZi5pc09wZW4gPSBmYWxzZTtcbiAgICAgICAgICAgIGlmICghc2VsZi5pc01vYmlsZSkge1xuICAgICAgICAgICAgICAgIGlmIChzZWxmLmNhbGVuZGFyQ29udGFpbmVyICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgc2VsZi5jYWxlbmRhckNvbnRhaW5lci5jbGFzc0xpc3QucmVtb3ZlKFwib3BlblwiKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHNlbGYuX2lucHV0ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgc2VsZi5faW5wdXQuY2xhc3NMaXN0LnJlbW92ZShcImFjdGl2ZVwiKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0cmlnZ2VyRXZlbnQoXCJvbkNsb3NlXCIpO1xuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIGRlc3Ryb3koKSB7XG4gICAgICAgICAgICBpZiAoc2VsZi5jb25maWcgIT09IHVuZGVmaW5lZClcbiAgICAgICAgICAgICAgICB0cmlnZ2VyRXZlbnQoXCJvbkRlc3Ryb3lcIik7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gc2VsZi5faGFuZGxlcnMubGVuZ3RoOyBpLS07KSB7XG4gICAgICAgICAgICAgICAgdmFyIGggPSBzZWxmLl9oYW5kbGVyc1tpXTtcbiAgICAgICAgICAgICAgICBoLmVsZW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcihoLmV2ZW50LCBoLmhhbmRsZXIsIGgub3B0aW9ucyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBzZWxmLl9oYW5kbGVycyA9IFtdO1xuICAgICAgICAgICAgaWYgKHNlbGYubW9iaWxlSW5wdXQpIHtcbiAgICAgICAgICAgICAgICBpZiAoc2VsZi5tb2JpbGVJbnB1dC5wYXJlbnROb2RlKVxuICAgICAgICAgICAgICAgICAgICBzZWxmLm1vYmlsZUlucHV0LnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQoc2VsZi5tb2JpbGVJbnB1dCk7XG4gICAgICAgICAgICAgICAgc2VsZi5tb2JpbGVJbnB1dCA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHNlbGYuY2FsZW5kYXJDb250YWluZXIgJiYgc2VsZi5jYWxlbmRhckNvbnRhaW5lci5wYXJlbnROb2RlKSB7XG4gICAgICAgICAgICAgICAgaWYgKHNlbGYuY29uZmlnLnN0YXRpYyAmJiBzZWxmLmNhbGVuZGFyQ29udGFpbmVyLnBhcmVudE5vZGUpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHdyYXBwZXIgPSBzZWxmLmNhbGVuZGFyQ29udGFpbmVyLnBhcmVudE5vZGU7XG4gICAgICAgICAgICAgICAgICAgIHdyYXBwZXIubGFzdENoaWxkICYmIHdyYXBwZXIucmVtb3ZlQ2hpbGQod3JhcHBlci5sYXN0Q2hpbGQpO1xuICAgICAgICAgICAgICAgICAgICBpZiAod3JhcHBlci5wYXJlbnROb2RlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB3aGlsZSAod3JhcHBlci5maXJzdENoaWxkKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHdyYXBwZXIucGFyZW50Tm9kZS5pbnNlcnRCZWZvcmUod3JhcHBlci5maXJzdENoaWxkLCB3cmFwcGVyKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHdyYXBwZXIucGFyZW50Tm9kZS5yZW1vdmVDaGlsZCh3cmFwcGVyKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgICAgIHNlbGYuY2FsZW5kYXJDb250YWluZXIucGFyZW50Tm9kZS5yZW1vdmVDaGlsZChzZWxmLmNhbGVuZGFyQ29udGFpbmVyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChzZWxmLmFsdElucHV0KSB7XG4gICAgICAgICAgICAgICAgc2VsZi5pbnB1dC50eXBlID0gXCJ0ZXh0XCI7XG4gICAgICAgICAgICAgICAgaWYgKHNlbGYuYWx0SW5wdXQucGFyZW50Tm9kZSlcbiAgICAgICAgICAgICAgICAgICAgc2VsZi5hbHRJbnB1dC5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKHNlbGYuYWx0SW5wdXQpO1xuICAgICAgICAgICAgICAgIGRlbGV0ZSBzZWxmLmFsdElucHV0O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHNlbGYuaW5wdXQpIHtcbiAgICAgICAgICAgICAgICBzZWxmLmlucHV0LnR5cGUgPSBzZWxmLmlucHV0Ll90eXBlO1xuICAgICAgICAgICAgICAgIHNlbGYuaW5wdXQuY2xhc3NMaXN0LnJlbW92ZShcImZsYXRwaWNrci1pbnB1dFwiKTtcbiAgICAgICAgICAgICAgICBzZWxmLmlucHV0LnJlbW92ZUF0dHJpYnV0ZShcInJlYWRvbmx5XCIpO1xuICAgICAgICAgICAgICAgIHNlbGYuaW5wdXQudmFsdWUgPSBcIlwiO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgW1xuICAgICAgICAgICAgICAgIFwiX3Nob3dUaW1lSW5wdXRcIixcbiAgICAgICAgICAgICAgICBcImxhdGVzdFNlbGVjdGVkRGF0ZU9ialwiLFxuICAgICAgICAgICAgICAgIFwiX2hpZGVOZXh0TW9udGhBcnJvd1wiLFxuICAgICAgICAgICAgICAgIFwiX2hpZGVQcmV2TW9udGhBcnJvd1wiLFxuICAgICAgICAgICAgICAgIFwiX19oaWRlTmV4dE1vbnRoQXJyb3dcIixcbiAgICAgICAgICAgICAgICBcIl9faGlkZVByZXZNb250aEFycm93XCIsXG4gICAgICAgICAgICAgICAgXCJpc01vYmlsZVwiLFxuICAgICAgICAgICAgICAgIFwiaXNPcGVuXCIsXG4gICAgICAgICAgICAgICAgXCJzZWxlY3RlZERhdGVFbGVtXCIsXG4gICAgICAgICAgICAgICAgXCJtaW5EYXRlSGFzVGltZVwiLFxuICAgICAgICAgICAgICAgIFwibWF4RGF0ZUhhc1RpbWVcIixcbiAgICAgICAgICAgICAgICBcImRheXNcIixcbiAgICAgICAgICAgICAgICBcImRheXNDb250YWluZXJcIixcbiAgICAgICAgICAgICAgICBcIl9pbnB1dFwiLFxuICAgICAgICAgICAgICAgIFwiX3Bvc2l0aW9uRWxlbWVudFwiLFxuICAgICAgICAgICAgICAgIFwiaW5uZXJDb250YWluZXJcIixcbiAgICAgICAgICAgICAgICBcInJDb250YWluZXJcIixcbiAgICAgICAgICAgICAgICBcIm1vbnRoTmF2XCIsXG4gICAgICAgICAgICAgICAgXCJ0b2RheURhdGVFbGVtXCIsXG4gICAgICAgICAgICAgICAgXCJjYWxlbmRhckNvbnRhaW5lclwiLFxuICAgICAgICAgICAgICAgIFwid2Vla2RheUNvbnRhaW5lclwiLFxuICAgICAgICAgICAgICAgIFwicHJldk1vbnRoTmF2XCIsXG4gICAgICAgICAgICAgICAgXCJuZXh0TW9udGhOYXZcIixcbiAgICAgICAgICAgICAgICBcIm1vbnRoc0Ryb3Bkb3duQ29udGFpbmVyXCIsXG4gICAgICAgICAgICAgICAgXCJjdXJyZW50TW9udGhFbGVtZW50XCIsXG4gICAgICAgICAgICAgICAgXCJjdXJyZW50WWVhckVsZW1lbnRcIixcbiAgICAgICAgICAgICAgICBcIm5hdmlnYXRpb25DdXJyZW50TW9udGhcIixcbiAgICAgICAgICAgICAgICBcInNlbGVjdGVkRGF0ZUVsZW1cIixcbiAgICAgICAgICAgICAgICBcImNvbmZpZ1wiLFxuICAgICAgICAgICAgXS5mb3JFYWNoKGZ1bmN0aW9uIChrKSB7XG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgZGVsZXRlIHNlbGZba107XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNhdGNoIChfKSB7IH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIGlzQ2FsZW5kYXJFbGVtKGVsZW0pIHtcbiAgICAgICAgICAgIGlmIChzZWxmLmNvbmZpZy5hcHBlbmRUbyAmJiBzZWxmLmNvbmZpZy5hcHBlbmRUby5jb250YWlucyhlbGVtKSlcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIHJldHVybiBzZWxmLmNhbGVuZGFyQ29udGFpbmVyLmNvbnRhaW5zKGVsZW0pO1xuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIGRvY3VtZW50Q2xpY2soZSkge1xuICAgICAgICAgICAgaWYgKHNlbGYuaXNPcGVuICYmICFzZWxmLmNvbmZpZy5pbmxpbmUpIHtcbiAgICAgICAgICAgICAgICB2YXIgZXZlbnRUYXJnZXRfMSA9IGdldEV2ZW50VGFyZ2V0KGUpO1xuICAgICAgICAgICAgICAgIHZhciBpc0NhbGVuZGFyRWxlbWVudCA9IGlzQ2FsZW5kYXJFbGVtKGV2ZW50VGFyZ2V0XzEpO1xuICAgICAgICAgICAgICAgIHZhciBpc0lucHV0ID0gZXZlbnRUYXJnZXRfMSA9PT0gc2VsZi5pbnB1dCB8fFxuICAgICAgICAgICAgICAgICAgICBldmVudFRhcmdldF8xID09PSBzZWxmLmFsdElucHV0IHx8XG4gICAgICAgICAgICAgICAgICAgIHNlbGYuZWxlbWVudC5jb250YWlucyhldmVudFRhcmdldF8xKSB8fFxuICAgICAgICAgICAgICAgICAgICAvLyB3ZWIgY29tcG9uZW50c1xuICAgICAgICAgICAgICAgICAgICAvLyBlLnBhdGggaXMgbm90IHByZXNlbnQgaW4gYWxsIGJyb3dzZXJzLiBjaXJjdW12ZW50aW5nIHR5cGVjaGVja3NcbiAgICAgICAgICAgICAgICAgICAgKGUucGF0aCAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgZS5wYXRoLmluZGV4T2YgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgICh+ZS5wYXRoLmluZGV4T2Yoc2VsZi5pbnB1dCkgfHxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB+ZS5wYXRoLmluZGV4T2Yoc2VsZi5hbHRJbnB1dCkpKTtcbiAgICAgICAgICAgICAgICB2YXIgbG9zdEZvY3VzID0gZS50eXBlID09PSBcImJsdXJcIlxuICAgICAgICAgICAgICAgICAgICA/IGlzSW5wdXQgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgIGUucmVsYXRlZFRhcmdldCAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgIWlzQ2FsZW5kYXJFbGVtKGUucmVsYXRlZFRhcmdldClcbiAgICAgICAgICAgICAgICAgICAgOiAhaXNJbnB1dCAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgIWlzQ2FsZW5kYXJFbGVtZW50ICYmXG4gICAgICAgICAgICAgICAgICAgICAgICAhaXNDYWxlbmRhckVsZW0oZS5yZWxhdGVkVGFyZ2V0KTtcbiAgICAgICAgICAgICAgICB2YXIgaXNJZ25vcmVkID0gIXNlbGYuY29uZmlnLmlnbm9yZWRGb2N1c0VsZW1lbnRzLnNvbWUoZnVuY3Rpb24gKGVsZW0pIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGVsZW0uY29udGFpbnMoZXZlbnRUYXJnZXRfMSk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgaWYgKGxvc3RGb2N1cyAmJiBpc0lnbm9yZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgc2VsZi5jbG9zZSgpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoc2VsZi5jb25maWcubW9kZSA9PT0gXCJyYW5nZVwiICYmIHNlbGYuc2VsZWN0ZWREYXRlcy5sZW5ndGggPT09IDEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNlbGYuY2xlYXIoZmFsc2UpO1xuICAgICAgICAgICAgICAgICAgICAgICAgc2VsZi5yZWRyYXcoKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiBjaGFuZ2VZZWFyKG5ld1llYXIpIHtcbiAgICAgICAgICAgIGlmICghbmV3WWVhciB8fFxuICAgICAgICAgICAgICAgIChzZWxmLmNvbmZpZy5taW5EYXRlICYmIG5ld1llYXIgPCBzZWxmLmNvbmZpZy5taW5EYXRlLmdldEZ1bGxZZWFyKCkpIHx8XG4gICAgICAgICAgICAgICAgKHNlbGYuY29uZmlnLm1heERhdGUgJiYgbmV3WWVhciA+IHNlbGYuY29uZmlnLm1heERhdGUuZ2V0RnVsbFllYXIoKSkpXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgdmFyIG5ld1llYXJOdW0gPSBuZXdZZWFyLCBpc05ld1llYXIgPSBzZWxmLmN1cnJlbnRZZWFyICE9PSBuZXdZZWFyTnVtO1xuICAgICAgICAgICAgc2VsZi5jdXJyZW50WWVhciA9IG5ld1llYXJOdW0gfHwgc2VsZi5jdXJyZW50WWVhcjtcbiAgICAgICAgICAgIGlmIChzZWxmLmNvbmZpZy5tYXhEYXRlICYmXG4gICAgICAgICAgICAgICAgc2VsZi5jdXJyZW50WWVhciA9PT0gc2VsZi5jb25maWcubWF4RGF0ZS5nZXRGdWxsWWVhcigpKSB7XG4gICAgICAgICAgICAgICAgc2VsZi5jdXJyZW50TW9udGggPSBNYXRoLm1pbihzZWxmLmNvbmZpZy5tYXhEYXRlLmdldE1vbnRoKCksIHNlbGYuY3VycmVudE1vbnRoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHNlbGYuY29uZmlnLm1pbkRhdGUgJiZcbiAgICAgICAgICAgICAgICBzZWxmLmN1cnJlbnRZZWFyID09PSBzZWxmLmNvbmZpZy5taW5EYXRlLmdldEZ1bGxZZWFyKCkpIHtcbiAgICAgICAgICAgICAgICBzZWxmLmN1cnJlbnRNb250aCA9IE1hdGgubWF4KHNlbGYuY29uZmlnLm1pbkRhdGUuZ2V0TW9udGgoKSwgc2VsZi5jdXJyZW50TW9udGgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGlzTmV3WWVhcikge1xuICAgICAgICAgICAgICAgIHNlbGYucmVkcmF3KCk7XG4gICAgICAgICAgICAgICAgdHJpZ2dlckV2ZW50KFwib25ZZWFyQ2hhbmdlXCIpO1xuICAgICAgICAgICAgICAgIGJ1aWxkTW9udGhTd2l0Y2goKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiBpc0VuYWJsZWQoZGF0ZSwgdGltZWxlc3MpIHtcbiAgICAgICAgICAgIGlmICh0aW1lbGVzcyA9PT0gdm9pZCAwKSB7IHRpbWVsZXNzID0gdHJ1ZTsgfVxuICAgICAgICAgICAgdmFyIGRhdGVUb0NoZWNrID0gc2VsZi5wYXJzZURhdGUoZGF0ZSwgdW5kZWZpbmVkLCB0aW1lbGVzcyk7IC8vIHRpbWVsZXNzXG4gICAgICAgICAgICBpZiAoKHNlbGYuY29uZmlnLm1pbkRhdGUgJiZcbiAgICAgICAgICAgICAgICBkYXRlVG9DaGVjayAmJlxuICAgICAgICAgICAgICAgIGNvbXBhcmVEYXRlcyhkYXRlVG9DaGVjaywgc2VsZi5jb25maWcubWluRGF0ZSwgdGltZWxlc3MgIT09IHVuZGVmaW5lZCA/IHRpbWVsZXNzIDogIXNlbGYubWluRGF0ZUhhc1RpbWUpIDwgMCkgfHxcbiAgICAgICAgICAgICAgICAoc2VsZi5jb25maWcubWF4RGF0ZSAmJlxuICAgICAgICAgICAgICAgICAgICBkYXRlVG9DaGVjayAmJlxuICAgICAgICAgICAgICAgICAgICBjb21wYXJlRGF0ZXMoZGF0ZVRvQ2hlY2ssIHNlbGYuY29uZmlnLm1heERhdGUsIHRpbWVsZXNzICE9PSB1bmRlZmluZWQgPyB0aW1lbGVzcyA6ICFzZWxmLm1heERhdGVIYXNUaW1lKSA+IDApKVxuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIGlmIChzZWxmLmNvbmZpZy5lbmFibGUubGVuZ3RoID09PSAwICYmIHNlbGYuY29uZmlnLmRpc2FibGUubGVuZ3RoID09PSAwKVxuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgaWYgKGRhdGVUb0NoZWNrID09PSB1bmRlZmluZWQpXG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgdmFyIGJvb2wgPSBzZWxmLmNvbmZpZy5lbmFibGUubGVuZ3RoID4gMCwgYXJyYXkgPSBib29sID8gc2VsZi5jb25maWcuZW5hYmxlIDogc2VsZi5jb25maWcuZGlzYWJsZTtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwLCBkID0gdm9pZCAwOyBpIDwgYXJyYXkubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICBkID0gYXJyYXlbaV07XG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBkID09PSBcImZ1bmN0aW9uXCIgJiZcbiAgICAgICAgICAgICAgICAgICAgZChkYXRlVG9DaGVjaykgLy8gZGlzYWJsZWQgYnkgZnVuY3Rpb25cbiAgICAgICAgICAgICAgICApXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBib29sO1xuICAgICAgICAgICAgICAgIGVsc2UgaWYgKGQgaW5zdGFuY2VvZiBEYXRlICYmXG4gICAgICAgICAgICAgICAgICAgIGRhdGVUb0NoZWNrICE9PSB1bmRlZmluZWQgJiZcbiAgICAgICAgICAgICAgICAgICAgZC5nZXRUaW1lKCkgPT09IGRhdGVUb0NoZWNrLmdldFRpbWUoKSlcbiAgICAgICAgICAgICAgICAgICAgLy8gZGlzYWJsZWQgYnkgZGF0ZVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gYm9vbDtcbiAgICAgICAgICAgICAgICBlbHNlIGlmICh0eXBlb2YgZCA9PT0gXCJzdHJpbmdcIiAmJiBkYXRlVG9DaGVjayAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIGRpc2FibGVkIGJ5IGRhdGUgc3RyaW5nXG4gICAgICAgICAgICAgICAgICAgIHZhciBwYXJzZWQgPSBzZWxmLnBhcnNlRGF0ZShkLCB1bmRlZmluZWQsIHRydWUpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcGFyc2VkICYmIHBhcnNlZC5nZXRUaW1lKCkgPT09IGRhdGVUb0NoZWNrLmdldFRpbWUoKVxuICAgICAgICAgICAgICAgICAgICAgICAgPyBib29sXG4gICAgICAgICAgICAgICAgICAgICAgICA6ICFib29sO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmIChcbiAgICAgICAgICAgICAgICAvLyBkaXNhYmxlZCBieSByYW5nZVxuICAgICAgICAgICAgICAgIHR5cGVvZiBkID09PSBcIm9iamVjdFwiICYmXG4gICAgICAgICAgICAgICAgICAgIGRhdGVUb0NoZWNrICE9PSB1bmRlZmluZWQgJiZcbiAgICAgICAgICAgICAgICAgICAgZC5mcm9tICYmXG4gICAgICAgICAgICAgICAgICAgIGQudG8gJiZcbiAgICAgICAgICAgICAgICAgICAgZGF0ZVRvQ2hlY2suZ2V0VGltZSgpID49IGQuZnJvbS5nZXRUaW1lKCkgJiZcbiAgICAgICAgICAgICAgICAgICAgZGF0ZVRvQ2hlY2suZ2V0VGltZSgpIDw9IGQudG8uZ2V0VGltZSgpKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gYm9vbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiAhYm9vbDtcbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiBpc0luVmlldyhlbGVtKSB7XG4gICAgICAgICAgICBpZiAoc2VsZi5kYXlzQ29udGFpbmVyICE9PSB1bmRlZmluZWQpXG4gICAgICAgICAgICAgICAgcmV0dXJuIChlbGVtLmNsYXNzTmFtZS5pbmRleE9mKFwiaGlkZGVuXCIpID09PSAtMSAmJlxuICAgICAgICAgICAgICAgICAgICBzZWxmLmRheXNDb250YWluZXIuY29udGFpbnMoZWxlbSkpO1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIG9uS2V5RG93bihlKSB7XG4gICAgICAgICAgICAvLyBlLmtleSAgICAgICAgICAgICAgICAgICAgICBlLmtleUNvZGVcbiAgICAgICAgICAgIC8vIFwiQmFja3NwYWNlXCIgICAgICAgICAgICAgICAgICAgICAgICA4XG4gICAgICAgICAgICAvLyBcIlRhYlwiICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgOVxuICAgICAgICAgICAgLy8gXCJFbnRlclwiICAgICAgICAgICAgICAgICAgICAgICAgICAgMTNcbiAgICAgICAgICAgIC8vIFwiRXNjYXBlXCIgICAgIChJRSBcIkVzY1wiKSAgICAgICAgICAgMjdcbiAgICAgICAgICAgIC8vIFwiQXJyb3dMZWZ0XCIgIChJRSBcIkxlZnRcIikgICAgICAgICAgMzdcbiAgICAgICAgICAgIC8vIFwiQXJyb3dVcFwiICAgIChJRSBcIlVwXCIpICAgICAgICAgICAgMzhcbiAgICAgICAgICAgIC8vIFwiQXJyb3dSaWdodFwiIChJRSBcIlJpZ2h0XCIpICAgICAgICAgMzlcbiAgICAgICAgICAgIC8vIFwiQXJyb3dEb3duXCIgIChJRSBcIkRvd25cIikgICAgICAgICAgNDBcbiAgICAgICAgICAgIC8vIFwiRGVsZXRlXCIgICAgIChJRSBcIkRlbFwiKSAgICAgICAgICAgNDZcbiAgICAgICAgICAgIHZhciBpc0lucHV0ID0gZS50YXJnZXQgPT09IHNlbGYuX2lucHV0O1xuICAgICAgICAgICAgdmFyIGFsbG93SW5wdXQgPSBzZWxmLmNvbmZpZy5hbGxvd0lucHV0O1xuICAgICAgICAgICAgdmFyIGFsbG93S2V5ZG93biA9IHNlbGYuaXNPcGVuICYmICghYWxsb3dJbnB1dCB8fCAhaXNJbnB1dCk7XG4gICAgICAgICAgICB2YXIgYWxsb3dJbmxpbmVLZXlkb3duID0gc2VsZi5jb25maWcuaW5saW5lICYmIGlzSW5wdXQgJiYgIWFsbG93SW5wdXQ7XG4gICAgICAgICAgICBpZiAoZS5rZXlDb2RlID09PSAxMyAmJiBpc0lucHV0KSB7XG4gICAgICAgICAgICAgICAgaWYgKGFsbG93SW5wdXQpIHtcbiAgICAgICAgICAgICAgICAgICAgc2VsZi5zZXREYXRlKHNlbGYuX2lucHV0LnZhbHVlLCB0cnVlLCBlLnRhcmdldCA9PT0gc2VsZi5hbHRJbnB1dFxuICAgICAgICAgICAgICAgICAgICAgICAgPyBzZWxmLmNvbmZpZy5hbHRGb3JtYXRcbiAgICAgICAgICAgICAgICAgICAgICAgIDogc2VsZi5jb25maWcuZGF0ZUZvcm1hdCk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBlLnRhcmdldC5ibHVyKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBzZWxmLm9wZW4oKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChpc0NhbGVuZGFyRWxlbShlLnRhcmdldCkgfHxcbiAgICAgICAgICAgICAgICBhbGxvd0tleWRvd24gfHxcbiAgICAgICAgICAgICAgICBhbGxvd0lubGluZUtleWRvd24pIHtcbiAgICAgICAgICAgICAgICB2YXIgaXNUaW1lT2JqID0gISFzZWxmLnRpbWVDb250YWluZXIgJiZcbiAgICAgICAgICAgICAgICAgICAgc2VsZi50aW1lQ29udGFpbmVyLmNvbnRhaW5zKGUudGFyZ2V0KTtcbiAgICAgICAgICAgICAgICBzd2l0Y2ggKGUua2V5Q29kZSkge1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDEzOlxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGlzVGltZU9iaikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB1cGRhdGVUaW1lKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZm9jdXNBbmRDbG9zZSgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNlbGVjdERhdGUoZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAyNzogLy8gZXNjYXBlXG4gICAgICAgICAgICAgICAgICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBmb2N1c0FuZENsb3NlKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgY2FzZSA4OlxuICAgICAgICAgICAgICAgICAgICBjYXNlIDQ2OlxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGlzSW5wdXQgJiYgIXNlbGYuY29uZmlnLmFsbG93SW5wdXQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc2VsZi5jbGVhcigpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMzc6XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMzk6XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIWlzVGltZU9iaiAmJiAhaXNJbnB1dCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoc2VsZi5kYXlzQ29udGFpbmVyICE9PSB1bmRlZmluZWQgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKGFsbG93SW5wdXQgPT09IGZhbHNlIHx8XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAoZG9jdW1lbnQuYWN0aXZlRWxlbWVudCAmJiBpc0luVmlldyhkb2N1bWVudC5hY3RpdmVFbGVtZW50KSkpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBkZWx0YV8xID0gZS5rZXlDb2RlID09PSAzOSA/IDEgOiAtMTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFlLmN0cmxLZXkpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb2N1c09uRGF5KHVuZGVmaW5lZCwgZGVsdGFfMSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZS5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNoYW5nZU1vbnRoKGRlbHRhXzEpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZm9jdXNPbkRheShnZXRGaXJzdEF2YWlsYWJsZURheSgxKSwgMCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIGlmIChzZWxmLmhvdXJFbGVtZW50KVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNlbGYuaG91ckVsZW1lbnQuZm9jdXMoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDM4OlxuICAgICAgICAgICAgICAgICAgICBjYXNlIDQwOlxuICAgICAgICAgICAgICAgICAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGRlbHRhID0gZS5rZXlDb2RlID09PSA0MCA/IDEgOiAtMTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICgoc2VsZi5kYXlzQ29udGFpbmVyICYmIGUudGFyZ2V0LiRpICE9PSB1bmRlZmluZWQpIHx8XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZS50YXJnZXQgPT09IHNlbGYuaW5wdXQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoZS5jdHJsS2V5KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGUuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNoYW5nZVllYXIoc2VsZi5jdXJyZW50WWVhciAtIGRlbHRhKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZm9jdXNPbkRheShnZXRGaXJzdEF2YWlsYWJsZURheSgxKSwgMCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKCFpc1RpbWVPYmopXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvY3VzT25EYXkodW5kZWZpbmVkLCBkZWx0YSAqIDcpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAoZS50YXJnZXQgPT09IHNlbGYuY3VycmVudFllYXJFbGVtZW50KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2hhbmdlWWVhcihzZWxmLmN1cnJlbnRZZWFyIC0gZGVsdGEpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAoc2VsZi5jb25maWcuZW5hYmxlVGltZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICghaXNUaW1lT2JqICYmIHNlbGYuaG91ckVsZW1lbnQpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNlbGYuaG91ckVsZW1lbnQuZm9jdXMoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB1cGRhdGVUaW1lKGUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNlbGYuX2RlYm91bmNlZENoYW5nZSgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgOTpcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChpc1RpbWVPYmopIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgZWxlbXMgPSBbXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNlbGYuaG91ckVsZW1lbnQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNlbGYubWludXRlRWxlbWVudCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2VsZi5zZWNvbmRFbGVtZW50LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZWxmLmFtUE0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgXVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAuY29uY2F0KHNlbGYucGx1Z2luRWxlbWVudHMpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5maWx0ZXIoZnVuY3Rpb24gKHgpIHsgcmV0dXJuIHg7IH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBpID0gZWxlbXMuaW5kZXhPZihlLnRhcmdldCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGkgIT09IC0xKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciB0YXJnZXQgPSBlbGVtc1tpICsgKGUuc2hpZnRLZXkgPyAtMSA6IDEpXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAodGFyZ2V0IHx8IHNlbGYuX2lucHV0KS5mb2N1cygpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKCFzZWxmLmNvbmZpZy5ub0NhbGVuZGFyICYmXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc2VsZi5kYXlzQ29udGFpbmVyICYmXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc2VsZi5kYXlzQ29udGFpbmVyLmNvbnRhaW5zKGUudGFyZ2V0KSAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGUuc2hpZnRLZXkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc2VsZi5faW5wdXQuZm9jdXMoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHNlbGYuYW1QTSAhPT0gdW5kZWZpbmVkICYmIGUudGFyZ2V0ID09PSBzZWxmLmFtUE0pIHtcbiAgICAgICAgICAgICAgICBzd2l0Y2ggKGUua2V5KSB7XG4gICAgICAgICAgICAgICAgICAgIGNhc2Ugc2VsZi5sMTBuLmFtUE1bMF0uY2hhckF0KDApOlxuICAgICAgICAgICAgICAgICAgICBjYXNlIHNlbGYubDEwbi5hbVBNWzBdLmNoYXJBdCgwKS50b0xvd2VyQ2FzZSgpOlxuICAgICAgICAgICAgICAgICAgICAgICAgc2VsZi5hbVBNLnRleHRDb250ZW50ID0gc2VsZi5sMTBuLmFtUE1bMF07XG4gICAgICAgICAgICAgICAgICAgICAgICBzZXRIb3Vyc0Zyb21JbnB1dHMoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHVwZGF0ZVZhbHVlKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgY2FzZSBzZWxmLmwxMG4uYW1QTVsxXS5jaGFyQXQoMCk6XG4gICAgICAgICAgICAgICAgICAgIGNhc2Ugc2VsZi5sMTBuLmFtUE1bMV0uY2hhckF0KDApLnRvTG93ZXJDYXNlKCk6XG4gICAgICAgICAgICAgICAgICAgICAgICBzZWxmLmFtUE0udGV4dENvbnRlbnQgPSBzZWxmLmwxMG4uYW1QTVsxXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNldEhvdXJzRnJvbUlucHV0cygpO1xuICAgICAgICAgICAgICAgICAgICAgICAgdXBkYXRlVmFsdWUoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChpc0lucHV0IHx8IGlzQ2FsZW5kYXJFbGVtKGUudGFyZ2V0KSkge1xuICAgICAgICAgICAgICAgIHRyaWdnZXJFdmVudChcIm9uS2V5RG93blwiLCBlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiBvbk1vdXNlT3ZlcihlbGVtKSB7XG4gICAgICAgICAgICBpZiAoc2VsZi5zZWxlY3RlZERhdGVzLmxlbmd0aCAhPT0gMSB8fFxuICAgICAgICAgICAgICAgIChlbGVtICYmXG4gICAgICAgICAgICAgICAgICAgICghZWxlbS5jbGFzc0xpc3QuY29udGFpbnMoXCJmbGF0cGlja3ItZGF5XCIpIHx8XG4gICAgICAgICAgICAgICAgICAgICAgICBlbGVtLmNsYXNzTGlzdC5jb250YWlucyhcImZsYXRwaWNrci1kaXNhYmxlZFwiKSkpKVxuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIHZhciBob3ZlckRhdGUgPSBlbGVtXG4gICAgICAgICAgICAgICAgPyBlbGVtLmRhdGVPYmouZ2V0VGltZSgpXG4gICAgICAgICAgICAgICAgOiBzZWxmLmRheXMuZmlyc3RFbGVtZW50Q2hpbGQuZGF0ZU9iai5nZXRUaW1lKCksIGluaXRpYWxEYXRlID0gc2VsZi5wYXJzZURhdGUoc2VsZi5zZWxlY3RlZERhdGVzWzBdLCB1bmRlZmluZWQsIHRydWUpLmdldFRpbWUoKSwgcmFuZ2VTdGFydERhdGUgPSBNYXRoLm1pbihob3ZlckRhdGUsIHNlbGYuc2VsZWN0ZWREYXRlc1swXS5nZXRUaW1lKCkpLCByYW5nZUVuZERhdGUgPSBNYXRoLm1heChob3ZlckRhdGUsIHNlbGYuc2VsZWN0ZWREYXRlc1swXS5nZXRUaW1lKCkpO1xuICAgICAgICAgICAgdmFyIGNvbnRhaW5zRGlzYWJsZWQgPSBmYWxzZTtcbiAgICAgICAgICAgIHZhciBtaW5SYW5nZSA9IDAsIG1heFJhbmdlID0gMDtcbiAgICAgICAgICAgIGZvciAodmFyIHQgPSByYW5nZVN0YXJ0RGF0ZTsgdCA8IHJhbmdlRW5kRGF0ZTsgdCArPSBkdXJhdGlvbi5EQVkpIHtcbiAgICAgICAgICAgICAgICBpZiAoIWlzRW5hYmxlZChuZXcgRGF0ZSh0KSwgdHJ1ZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgY29udGFpbnNEaXNhYmxlZCA9XG4gICAgICAgICAgICAgICAgICAgICAgICBjb250YWluc0Rpc2FibGVkIHx8ICh0ID4gcmFuZ2VTdGFydERhdGUgJiYgdCA8IHJhbmdlRW5kRGF0ZSk7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0IDwgaW5pdGlhbERhdGUgJiYgKCFtaW5SYW5nZSB8fCB0ID4gbWluUmFuZ2UpKVxuICAgICAgICAgICAgICAgICAgICAgICAgbWluUmFuZ2UgPSB0O1xuICAgICAgICAgICAgICAgICAgICBlbHNlIGlmICh0ID4gaW5pdGlhbERhdGUgJiYgKCFtYXhSYW5nZSB8fCB0IDwgbWF4UmFuZ2UpKVxuICAgICAgICAgICAgICAgICAgICAgICAgbWF4UmFuZ2UgPSB0O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZvciAodmFyIG0gPSAwOyBtIDwgc2VsZi5jb25maWcuc2hvd01vbnRoczsgbSsrKSB7XG4gICAgICAgICAgICAgICAgdmFyIG1vbnRoID0gc2VsZi5kYXlzQ29udGFpbmVyLmNoaWxkcmVuW21dO1xuICAgICAgICAgICAgICAgIHZhciBfbG9vcF8xID0gZnVuY3Rpb24gKGksIGwpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGRheUVsZW0gPSBtb250aC5jaGlsZHJlbltpXSwgZGF0ZSA9IGRheUVsZW0uZGF0ZU9iajtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHRpbWVzdGFtcCA9IGRhdGUuZ2V0VGltZSgpO1xuICAgICAgICAgICAgICAgICAgICB2YXIgb3V0T2ZSYW5nZSA9IChtaW5SYW5nZSA+IDAgJiYgdGltZXN0YW1wIDwgbWluUmFuZ2UpIHx8XG4gICAgICAgICAgICAgICAgICAgICAgICAobWF4UmFuZ2UgPiAwICYmIHRpbWVzdGFtcCA+IG1heFJhbmdlKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKG91dE9mUmFuZ2UpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRheUVsZW0uY2xhc3NMaXN0LmFkZChcIm5vdEFsbG93ZWRcIik7XG4gICAgICAgICAgICAgICAgICAgICAgICBbXCJpblJhbmdlXCIsIFwic3RhcnRSYW5nZVwiLCBcImVuZFJhbmdlXCJdLmZvckVhY2goZnVuY3Rpb24gKGMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkYXlFbGVtLmNsYXNzTGlzdC5yZW1vdmUoYyk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBcImNvbnRpbnVlXCI7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAoY29udGFpbnNEaXNhYmxlZCAmJiAhb3V0T2ZSYW5nZSlcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBcImNvbnRpbnVlXCI7XG4gICAgICAgICAgICAgICAgICAgIFtcInN0YXJ0UmFuZ2VcIiwgXCJpblJhbmdlXCIsIFwiZW5kUmFuZ2VcIiwgXCJub3RBbGxvd2VkXCJdLmZvckVhY2goZnVuY3Rpb24gKGMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRheUVsZW0uY2xhc3NMaXN0LnJlbW92ZShjKTtcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChlbGVtICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGVsZW0uY2xhc3NMaXN0LmFkZChob3ZlckRhdGUgPD0gc2VsZi5zZWxlY3RlZERhdGVzWzBdLmdldFRpbWUoKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgID8gXCJzdGFydFJhbmdlXCJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA6IFwiZW5kUmFuZ2VcIik7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoaW5pdGlhbERhdGUgPCBob3ZlckRhdGUgJiYgdGltZXN0YW1wID09PSBpbml0aWFsRGF0ZSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkYXlFbGVtLmNsYXNzTGlzdC5hZGQoXCJzdGFydFJhbmdlXCIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAoaW5pdGlhbERhdGUgPiBob3ZlckRhdGUgJiYgdGltZXN0YW1wID09PSBpbml0aWFsRGF0ZSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkYXlFbGVtLmNsYXNzTGlzdC5hZGQoXCJlbmRSYW5nZVwiKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0aW1lc3RhbXAgPj0gbWluUmFuZ2UgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAobWF4UmFuZ2UgPT09IDAgfHwgdGltZXN0YW1wIDw9IG1heFJhbmdlKSAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlzQmV0d2Vlbih0aW1lc3RhbXAsIGluaXRpYWxEYXRlLCBob3ZlckRhdGUpKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRheUVsZW0uY2xhc3NMaXN0LmFkZChcImluUmFuZ2VcIik7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwLCBsID0gbW9udGguY2hpbGRyZW4ubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgIF9sb29wXzEoaSwgbCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIG9uUmVzaXplKCkge1xuICAgICAgICAgICAgaWYgKHNlbGYuaXNPcGVuICYmICFzZWxmLmNvbmZpZy5zdGF0aWMgJiYgIXNlbGYuY29uZmlnLmlubGluZSlcbiAgICAgICAgICAgICAgICBwb3NpdGlvbkNhbGVuZGFyKCk7XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gc2V0RGVmYXVsdFRpbWUoKSB7XG4gICAgICAgICAgICBzZWxmLnNldERhdGUoc2VsZi5jb25maWcubWluRGF0ZSAhPT0gdW5kZWZpbmVkXG4gICAgICAgICAgICAgICAgPyBuZXcgRGF0ZShzZWxmLmNvbmZpZy5taW5EYXRlLmdldFRpbWUoKSlcbiAgICAgICAgICAgICAgICA6IG5ldyBEYXRlKCksIHRydWUpO1xuICAgICAgICAgICAgc2V0RGVmYXVsdEhvdXJzKCk7XG4gICAgICAgICAgICB1cGRhdGVWYWx1ZSgpO1xuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIG9wZW4oZSwgcG9zaXRpb25FbGVtZW50KSB7XG4gICAgICAgICAgICBpZiAocG9zaXRpb25FbGVtZW50ID09PSB2b2lkIDApIHsgcG9zaXRpb25FbGVtZW50ID0gc2VsZi5fcG9zaXRpb25FbGVtZW50OyB9XG4gICAgICAgICAgICBpZiAoc2VsZi5pc01vYmlsZSA9PT0gdHJ1ZSkge1xuICAgICAgICAgICAgICAgIGlmIChlKSB7XG4gICAgICAgICAgICAgICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICAgICAgICAgICAgZS50YXJnZXQgJiYgZS50YXJnZXQuYmx1cigpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoc2VsZi5tb2JpbGVJbnB1dCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgIHNlbGYubW9iaWxlSW5wdXQuZm9jdXMoKTtcbiAgICAgICAgICAgICAgICAgICAgc2VsZi5tb2JpbGVJbnB1dC5jbGljaygpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0cmlnZ2VyRXZlbnQoXCJvbk9wZW5cIik7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHNlbGYuX2lucHV0LmRpc2FibGVkIHx8IHNlbGYuY29uZmlnLmlubGluZSlcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB2YXIgd2FzT3BlbiA9IHNlbGYuaXNPcGVuO1xuICAgICAgICAgICAgc2VsZi5pc09wZW4gPSB0cnVlO1xuICAgICAgICAgICAgaWYgKCF3YXNPcGVuKSB7XG4gICAgICAgICAgICAgICAgc2VsZi5jYWxlbmRhckNvbnRhaW5lci5jbGFzc0xpc3QuYWRkKFwib3BlblwiKTtcbiAgICAgICAgICAgICAgICBzZWxmLl9pbnB1dC5jbGFzc0xpc3QuYWRkKFwiYWN0aXZlXCIpO1xuICAgICAgICAgICAgICAgIHRyaWdnZXJFdmVudChcIm9uT3BlblwiKTtcbiAgICAgICAgICAgICAgICBwb3NpdGlvbkNhbGVuZGFyKHBvc2l0aW9uRWxlbWVudCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoc2VsZi5jb25maWcuZW5hYmxlVGltZSA9PT0gdHJ1ZSAmJiBzZWxmLmNvbmZpZy5ub0NhbGVuZGFyID09PSB0cnVlKSB7XG4gICAgICAgICAgICAgICAgaWYgKHNlbGYuc2VsZWN0ZWREYXRlcy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgc2V0RGVmYXVsdFRpbWUoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHNlbGYuY29uZmlnLmFsbG93SW5wdXQgPT09IGZhbHNlICYmXG4gICAgICAgICAgICAgICAgICAgIChlID09PSB1bmRlZmluZWQgfHxcbiAgICAgICAgICAgICAgICAgICAgICAgICFzZWxmLnRpbWVDb250YWluZXIuY29udGFpbnMoZS5yZWxhdGVkVGFyZ2V0KSkpIHtcbiAgICAgICAgICAgICAgICAgICAgc2V0VGltZW91dChmdW5jdGlvbiAoKSB7IHJldHVybiBzZWxmLmhvdXJFbGVtZW50LnNlbGVjdCgpOyB9LCA1MCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIG1pbk1heERhdGVTZXR0ZXIodHlwZSkge1xuICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIChkYXRlKSB7XG4gICAgICAgICAgICAgICAgdmFyIGRhdGVPYmogPSAoc2VsZi5jb25maWdbXCJfXCIgKyB0eXBlICsgXCJEYXRlXCJdID0gc2VsZi5wYXJzZURhdGUoZGF0ZSwgc2VsZi5jb25maWcuZGF0ZUZvcm1hdCkpO1xuICAgICAgICAgICAgICAgIHZhciBpbnZlcnNlRGF0ZU9iaiA9IHNlbGYuY29uZmlnW1wiX1wiICsgKHR5cGUgPT09IFwibWluXCIgPyBcIm1heFwiIDogXCJtaW5cIikgKyBcIkRhdGVcIl07XG4gICAgICAgICAgICAgICAgaWYgKGRhdGVPYmogIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICBzZWxmW3R5cGUgPT09IFwibWluXCIgPyBcIm1pbkRhdGVIYXNUaW1lXCIgOiBcIm1heERhdGVIYXNUaW1lXCJdID1cbiAgICAgICAgICAgICAgICAgICAgICAgIGRhdGVPYmouZ2V0SG91cnMoKSA+IDAgfHxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkYXRlT2JqLmdldE1pbnV0ZXMoKSA+IDAgfHxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkYXRlT2JqLmdldFNlY29uZHMoKSA+IDA7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChzZWxmLnNlbGVjdGVkRGF0ZXMpIHtcbiAgICAgICAgICAgICAgICAgICAgc2VsZi5zZWxlY3RlZERhdGVzID0gc2VsZi5zZWxlY3RlZERhdGVzLmZpbHRlcihmdW5jdGlvbiAoZCkgeyByZXR1cm4gaXNFbmFibGVkKGQpOyB9KTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFzZWxmLnNlbGVjdGVkRGF0ZXMubGVuZ3RoICYmIHR5cGUgPT09IFwibWluXCIpXG4gICAgICAgICAgICAgICAgICAgICAgICBzZXRIb3Vyc0Zyb21EYXRlKGRhdGVPYmopO1xuICAgICAgICAgICAgICAgICAgICB1cGRhdGVWYWx1ZSgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoc2VsZi5kYXlzQ29udGFpbmVyKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlZHJhdygpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoZGF0ZU9iaiAhPT0gdW5kZWZpbmVkKVxuICAgICAgICAgICAgICAgICAgICAgICAgc2VsZi5jdXJyZW50WWVhckVsZW1lbnRbdHlwZV0gPSBkYXRlT2JqLmdldEZ1bGxZZWFyKCkudG9TdHJpbmcoKTtcbiAgICAgICAgICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgICAgICAgICAgc2VsZi5jdXJyZW50WWVhckVsZW1lbnQucmVtb3ZlQXR0cmlidXRlKHR5cGUpO1xuICAgICAgICAgICAgICAgICAgICBzZWxmLmN1cnJlbnRZZWFyRWxlbWVudC5kaXNhYmxlZCA9XG4gICAgICAgICAgICAgICAgICAgICAgICAhIWludmVyc2VEYXRlT2JqICYmXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZGF0ZU9iaiAhPT0gdW5kZWZpbmVkICYmXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaW52ZXJzZURhdGVPYmouZ2V0RnVsbFllYXIoKSA9PT0gZGF0ZU9iai5nZXRGdWxsWWVhcigpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gcGFyc2VDb25maWcoKSB7XG4gICAgICAgICAgICB2YXIgYm9vbE9wdHMgPSBbXG4gICAgICAgICAgICAgICAgXCJ3cmFwXCIsXG4gICAgICAgICAgICAgICAgXCJ3ZWVrTnVtYmVyc1wiLFxuICAgICAgICAgICAgICAgIFwiYWxsb3dJbnB1dFwiLFxuICAgICAgICAgICAgICAgIFwiY2xpY2tPcGVuc1wiLFxuICAgICAgICAgICAgICAgIFwidGltZV8yNGhyXCIsXG4gICAgICAgICAgICAgICAgXCJlbmFibGVUaW1lXCIsXG4gICAgICAgICAgICAgICAgXCJub0NhbGVuZGFyXCIsXG4gICAgICAgICAgICAgICAgXCJhbHRJbnB1dFwiLFxuICAgICAgICAgICAgICAgIFwic2hvcnRoYW5kQ3VycmVudE1vbnRoXCIsXG4gICAgICAgICAgICAgICAgXCJpbmxpbmVcIixcbiAgICAgICAgICAgICAgICBcInN0YXRpY1wiLFxuICAgICAgICAgICAgICAgIFwiZW5hYmxlU2Vjb25kc1wiLFxuICAgICAgICAgICAgICAgIFwiZGlzYWJsZU1vYmlsZVwiLFxuICAgICAgICAgICAgXTtcbiAgICAgICAgICAgIHZhciB1c2VyQ29uZmlnID0gX19hc3NpZ24oe30sIGluc3RhbmNlQ29uZmlnLCBKU09OLnBhcnNlKEpTT04uc3RyaW5naWZ5KGVsZW1lbnQuZGF0YXNldCB8fCB7fSkpKTtcbiAgICAgICAgICAgIHZhciBmb3JtYXRzID0ge307XG4gICAgICAgICAgICBzZWxmLmNvbmZpZy5wYXJzZURhdGUgPSB1c2VyQ29uZmlnLnBhcnNlRGF0ZTtcbiAgICAgICAgICAgIHNlbGYuY29uZmlnLmZvcm1hdERhdGUgPSB1c2VyQ29uZmlnLmZvcm1hdERhdGU7XG4gICAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoc2VsZi5jb25maWcsIFwiZW5hYmxlXCIsIHtcbiAgICAgICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHNlbGYuY29uZmlnLl9lbmFibGU7IH0sXG4gICAgICAgICAgICAgICAgc2V0OiBmdW5jdGlvbiAoZGF0ZXMpIHtcbiAgICAgICAgICAgICAgICAgICAgc2VsZi5jb25maWcuX2VuYWJsZSA9IHBhcnNlRGF0ZVJ1bGVzKGRhdGVzKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShzZWxmLmNvbmZpZywgXCJkaXNhYmxlXCIsIHtcbiAgICAgICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHNlbGYuY29uZmlnLl9kaXNhYmxlOyB9LFxuICAgICAgICAgICAgICAgIHNldDogZnVuY3Rpb24gKGRhdGVzKSB7XG4gICAgICAgICAgICAgICAgICAgIHNlbGYuY29uZmlnLl9kaXNhYmxlID0gcGFyc2VEYXRlUnVsZXMoZGF0ZXMpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgdmFyIHRpbWVNb2RlID0gdXNlckNvbmZpZy5tb2RlID09PSBcInRpbWVcIjtcbiAgICAgICAgICAgIGlmICghdXNlckNvbmZpZy5kYXRlRm9ybWF0ICYmICh1c2VyQ29uZmlnLmVuYWJsZVRpbWUgfHwgdGltZU1vZGUpKSB7XG4gICAgICAgICAgICAgICAgdmFyIGRlZmF1bHREYXRlRm9ybWF0ID0gZmxhdHBpY2tyLmRlZmF1bHRDb25maWcuZGF0ZUZvcm1hdCB8fCBkZWZhdWx0cy5kYXRlRm9ybWF0O1xuICAgICAgICAgICAgICAgIGZvcm1hdHMuZGF0ZUZvcm1hdCA9XG4gICAgICAgICAgICAgICAgICAgIHVzZXJDb25maWcubm9DYWxlbmRhciB8fCB0aW1lTW9kZVxuICAgICAgICAgICAgICAgICAgICAgICAgPyBcIkg6aVwiICsgKHVzZXJDb25maWcuZW5hYmxlU2Vjb25kcyA/IFwiOlNcIiA6IFwiXCIpXG4gICAgICAgICAgICAgICAgICAgICAgICA6IGRlZmF1bHREYXRlRm9ybWF0ICsgXCIgSDppXCIgKyAodXNlckNvbmZpZy5lbmFibGVTZWNvbmRzID8gXCI6U1wiIDogXCJcIik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodXNlckNvbmZpZy5hbHRJbnB1dCAmJlxuICAgICAgICAgICAgICAgICh1c2VyQ29uZmlnLmVuYWJsZVRpbWUgfHwgdGltZU1vZGUpICYmXG4gICAgICAgICAgICAgICAgIXVzZXJDb25maWcuYWx0Rm9ybWF0KSB7XG4gICAgICAgICAgICAgICAgdmFyIGRlZmF1bHRBbHRGb3JtYXQgPSBmbGF0cGlja3IuZGVmYXVsdENvbmZpZy5hbHRGb3JtYXQgfHwgZGVmYXVsdHMuYWx0Rm9ybWF0O1xuICAgICAgICAgICAgICAgIGZvcm1hdHMuYWx0Rm9ybWF0ID1cbiAgICAgICAgICAgICAgICAgICAgdXNlckNvbmZpZy5ub0NhbGVuZGFyIHx8IHRpbWVNb2RlXG4gICAgICAgICAgICAgICAgICAgICAgICA/IFwiaDppXCIgKyAodXNlckNvbmZpZy5lbmFibGVTZWNvbmRzID8gXCI6UyBLXCIgOiBcIiBLXCIpXG4gICAgICAgICAgICAgICAgICAgICAgICA6IGRlZmF1bHRBbHRGb3JtYXQgKyAoXCIgaDppXCIgKyAodXNlckNvbmZpZy5lbmFibGVTZWNvbmRzID8gXCI6U1wiIDogXCJcIikgKyBcIiBLXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCF1c2VyQ29uZmlnLmFsdElucHV0Q2xhc3MpIHtcbiAgICAgICAgICAgICAgICBzZWxmLmNvbmZpZy5hbHRJbnB1dENsYXNzID1cbiAgICAgICAgICAgICAgICAgICAgc2VsZi5pbnB1dC5jbGFzc05hbWUgKyBcIiBcIiArIHNlbGYuY29uZmlnLmFsdElucHV0Q2xhc3M7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoc2VsZi5jb25maWcsIFwibWluRGF0ZVwiLCB7XG4gICAgICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBzZWxmLmNvbmZpZy5fbWluRGF0ZTsgfSxcbiAgICAgICAgICAgICAgICBzZXQ6IG1pbk1heERhdGVTZXR0ZXIoXCJtaW5cIilcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHNlbGYuY29uZmlnLCBcIm1heERhdGVcIiwge1xuICAgICAgICAgICAgICAgIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gc2VsZi5jb25maWcuX21heERhdGU7IH0sXG4gICAgICAgICAgICAgICAgc2V0OiBtaW5NYXhEYXRlU2V0dGVyKFwibWF4XCIpXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHZhciBtaW5NYXhUaW1lU2V0dGVyID0gZnVuY3Rpb24gKHR5cGUpIHsgcmV0dXJuIGZ1bmN0aW9uICh2YWwpIHtcbiAgICAgICAgICAgICAgICBzZWxmLmNvbmZpZ1t0eXBlID09PSBcIm1pblwiID8gXCJfbWluVGltZVwiIDogXCJfbWF4VGltZVwiXSA9IHNlbGYucGFyc2VEYXRlKHZhbCwgXCJIOmlcIik7XG4gICAgICAgICAgICB9OyB9O1xuICAgICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHNlbGYuY29uZmlnLCBcIm1pblRpbWVcIiwge1xuICAgICAgICAgICAgICAgIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gc2VsZi5jb25maWcuX21pblRpbWU7IH0sXG4gICAgICAgICAgICAgICAgc2V0OiBtaW5NYXhUaW1lU2V0dGVyKFwibWluXCIpXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShzZWxmLmNvbmZpZywgXCJtYXhUaW1lXCIsIHtcbiAgICAgICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHNlbGYuY29uZmlnLl9tYXhUaW1lOyB9LFxuICAgICAgICAgICAgICAgIHNldDogbWluTWF4VGltZVNldHRlcihcIm1heFwiKVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBpZiAodXNlckNvbmZpZy5tb2RlID09PSBcInRpbWVcIikge1xuICAgICAgICAgICAgICAgIHNlbGYuY29uZmlnLm5vQ2FsZW5kYXIgPSB0cnVlO1xuICAgICAgICAgICAgICAgIHNlbGYuY29uZmlnLmVuYWJsZVRpbWUgPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgT2JqZWN0LmFzc2lnbihzZWxmLmNvbmZpZywgZm9ybWF0cywgdXNlckNvbmZpZyk7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGJvb2xPcHRzLmxlbmd0aDsgaSsrKVxuICAgICAgICAgICAgICAgIHNlbGYuY29uZmlnW2Jvb2xPcHRzW2ldXSA9XG4gICAgICAgICAgICAgICAgICAgIHNlbGYuY29uZmlnW2Jvb2xPcHRzW2ldXSA9PT0gdHJ1ZSB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgc2VsZi5jb25maWdbYm9vbE9wdHNbaV1dID09PSBcInRydWVcIjtcbiAgICAgICAgICAgIEhPT0tTLmZpbHRlcihmdW5jdGlvbiAoaG9vaykgeyByZXR1cm4gc2VsZi5jb25maWdbaG9va10gIT09IHVuZGVmaW5lZDsgfSkuZm9yRWFjaChmdW5jdGlvbiAoaG9vaykge1xuICAgICAgICAgICAgICAgIHNlbGYuY29uZmlnW2hvb2tdID0gYXJyYXlpZnkoc2VsZi5jb25maWdbaG9va10gfHwgW10pLm1hcChiaW5kVG9JbnN0YW5jZSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHNlbGYuaXNNb2JpbGUgPVxuICAgICAgICAgICAgICAgICFzZWxmLmNvbmZpZy5kaXNhYmxlTW9iaWxlICYmXG4gICAgICAgICAgICAgICAgICAgICFzZWxmLmNvbmZpZy5pbmxpbmUgJiZcbiAgICAgICAgICAgICAgICAgICAgc2VsZi5jb25maWcubW9kZSA9PT0gXCJzaW5nbGVcIiAmJlxuICAgICAgICAgICAgICAgICAgICAhc2VsZi5jb25maWcuZGlzYWJsZS5sZW5ndGggJiZcbiAgICAgICAgICAgICAgICAgICAgIXNlbGYuY29uZmlnLmVuYWJsZS5sZW5ndGggJiZcbiAgICAgICAgICAgICAgICAgICAgIXNlbGYuY29uZmlnLndlZWtOdW1iZXJzICYmXG4gICAgICAgICAgICAgICAgICAgIC9BbmRyb2lkfHdlYk9TfGlQaG9uZXxpUGFkfGlQb2R8QmxhY2tCZXJyeXxJRU1vYmlsZXxPcGVyYSBNaW5pL2kudGVzdChuYXZpZ2F0b3IudXNlckFnZW50KTtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgc2VsZi5jb25maWcucGx1Z2lucy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIHZhciBwbHVnaW5Db25mID0gc2VsZi5jb25maWcucGx1Z2luc1tpXShzZWxmKSB8fCB7fTtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBrZXkgaW4gcGx1Z2luQ29uZikge1xuICAgICAgICAgICAgICAgICAgICBpZiAoSE9PS1MuaW5kZXhPZihrZXkpID4gLTEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNlbGYuY29uZmlnW2tleV0gPSBhcnJheWlmeShwbHVnaW5Db25mW2tleV0pXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLm1hcChiaW5kVG9JbnN0YW5jZSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAuY29uY2F0KHNlbGYuY29uZmlnW2tleV0pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKHR5cGVvZiB1c2VyQ29uZmlnW2tleV0gPT09IFwidW5kZWZpbmVkXCIpXG4gICAgICAgICAgICAgICAgICAgICAgICBzZWxmLmNvbmZpZ1trZXldID0gcGx1Z2luQ29uZltrZXldO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRyaWdnZXJFdmVudChcIm9uUGFyc2VDb25maWdcIik7XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gc2V0dXBMb2NhbGUoKSB7XG4gICAgICAgICAgICBpZiAodHlwZW9mIHNlbGYuY29uZmlnLmxvY2FsZSAhPT0gXCJvYmplY3RcIiAmJlxuICAgICAgICAgICAgICAgIHR5cGVvZiBmbGF0cGlja3IubDEwbnNbc2VsZi5jb25maWcubG9jYWxlXSA9PT0gXCJ1bmRlZmluZWRcIilcbiAgICAgICAgICAgICAgICBzZWxmLmNvbmZpZy5lcnJvckhhbmRsZXIobmV3IEVycm9yKFwiZmxhdHBpY2tyOiBpbnZhbGlkIGxvY2FsZSBcIiArIHNlbGYuY29uZmlnLmxvY2FsZSkpO1xuICAgICAgICAgICAgc2VsZi5sMTBuID0gX19hc3NpZ24oe30sIGZsYXRwaWNrci5sMTBuc1tcImRlZmF1bHRcIl0sICh0eXBlb2Ygc2VsZi5jb25maWcubG9jYWxlID09PSBcIm9iamVjdFwiXG4gICAgICAgICAgICAgICAgPyBzZWxmLmNvbmZpZy5sb2NhbGVcbiAgICAgICAgICAgICAgICA6IHNlbGYuY29uZmlnLmxvY2FsZSAhPT0gXCJkZWZhdWx0XCJcbiAgICAgICAgICAgICAgICAgICAgPyBmbGF0cGlja3IubDEwbnNbc2VsZi5jb25maWcubG9jYWxlXVxuICAgICAgICAgICAgICAgICAgICA6IHVuZGVmaW5lZCkpO1xuICAgICAgICAgICAgdG9rZW5SZWdleC5LID0gXCIoXCIgKyBzZWxmLmwxMG4uYW1QTVswXSArIFwifFwiICsgc2VsZi5sMTBuLmFtUE1bMV0gKyBcInxcIiArIHNlbGYubDEwbi5hbVBNWzBdLnRvTG93ZXJDYXNlKCkgKyBcInxcIiArIHNlbGYubDEwbi5hbVBNWzFdLnRvTG93ZXJDYXNlKCkgKyBcIilcIjtcbiAgICAgICAgICAgIHZhciB1c2VyQ29uZmlnID0gX19hc3NpZ24oe30sIGluc3RhbmNlQ29uZmlnLCBKU09OLnBhcnNlKEpTT04uc3RyaW5naWZ5KGVsZW1lbnQuZGF0YXNldCB8fCB7fSkpKTtcbiAgICAgICAgICAgIGlmICh1c2VyQ29uZmlnLnRpbWVfMjRociA9PT0gdW5kZWZpbmVkICYmXG4gICAgICAgICAgICAgICAgZmxhdHBpY2tyLmRlZmF1bHRDb25maWcudGltZV8yNGhyID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICBzZWxmLmNvbmZpZy50aW1lXzI0aHIgPSBzZWxmLmwxMG4udGltZV8yNGhyO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgc2VsZi5mb3JtYXREYXRlID0gY3JlYXRlRGF0ZUZvcm1hdHRlcihzZWxmKTtcbiAgICAgICAgICAgIHNlbGYucGFyc2VEYXRlID0gY3JlYXRlRGF0ZVBhcnNlcih7IGNvbmZpZzogc2VsZi5jb25maWcsIGwxMG46IHNlbGYubDEwbiB9KTtcbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiBwb3NpdGlvbkNhbGVuZGFyKGN1c3RvbVBvc2l0aW9uRWxlbWVudCkge1xuICAgICAgICAgICAgaWYgKHNlbGYuY2FsZW5kYXJDb250YWluZXIgPT09IHVuZGVmaW5lZClcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB0cmlnZ2VyRXZlbnQoXCJvblByZUNhbGVuZGFyUG9zaXRpb25cIik7XG4gICAgICAgICAgICB2YXIgcG9zaXRpb25FbGVtZW50ID0gY3VzdG9tUG9zaXRpb25FbGVtZW50IHx8IHNlbGYuX3Bvc2l0aW9uRWxlbWVudDtcbiAgICAgICAgICAgIHZhciBjYWxlbmRhckhlaWdodCA9IEFycmF5LnByb3RvdHlwZS5yZWR1Y2UuY2FsbChzZWxmLmNhbGVuZGFyQ29udGFpbmVyLmNoaWxkcmVuLCAoZnVuY3Rpb24gKGFjYywgY2hpbGQpIHsgcmV0dXJuIGFjYyArIGNoaWxkLm9mZnNldEhlaWdodDsgfSksIDApLCBjYWxlbmRhcldpZHRoID0gc2VsZi5jYWxlbmRhckNvbnRhaW5lci5vZmZzZXRXaWR0aCwgY29uZmlnUG9zID0gc2VsZi5jb25maWcucG9zaXRpb24uc3BsaXQoXCIgXCIpLCBjb25maWdQb3NWZXJ0aWNhbCA9IGNvbmZpZ1Bvc1swXSwgY29uZmlnUG9zSG9yaXpvbnRhbCA9IGNvbmZpZ1Bvcy5sZW5ndGggPiAxID8gY29uZmlnUG9zWzFdIDogbnVsbCwgaW5wdXRCb3VuZHMgPSBwb3NpdGlvbkVsZW1lbnQuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCksIGRpc3RhbmNlRnJvbUJvdHRvbSA9IHdpbmRvdy5pbm5lckhlaWdodCAtIGlucHV0Qm91bmRzLmJvdHRvbSwgc2hvd09uVG9wID0gY29uZmlnUG9zVmVydGljYWwgPT09IFwiYWJvdmVcIiB8fFxuICAgICAgICAgICAgICAgIChjb25maWdQb3NWZXJ0aWNhbCAhPT0gXCJiZWxvd1wiICYmXG4gICAgICAgICAgICAgICAgICAgIGRpc3RhbmNlRnJvbUJvdHRvbSA8IGNhbGVuZGFySGVpZ2h0ICYmXG4gICAgICAgICAgICAgICAgICAgIGlucHV0Qm91bmRzLnRvcCA+IGNhbGVuZGFySGVpZ2h0KTtcbiAgICAgICAgICAgIHZhciB0b3AgPSB3aW5kb3cucGFnZVlPZmZzZXQgK1xuICAgICAgICAgICAgICAgIGlucHV0Qm91bmRzLnRvcCArXG4gICAgICAgICAgICAgICAgKCFzaG93T25Ub3AgPyBwb3NpdGlvbkVsZW1lbnQub2Zmc2V0SGVpZ2h0ICsgMiA6IC1jYWxlbmRhckhlaWdodCAtIDIpO1xuICAgICAgICAgICAgdG9nZ2xlQ2xhc3Moc2VsZi5jYWxlbmRhckNvbnRhaW5lciwgXCJhcnJvd1RvcFwiLCAhc2hvd09uVG9wKTtcbiAgICAgICAgICAgIHRvZ2dsZUNsYXNzKHNlbGYuY2FsZW5kYXJDb250YWluZXIsIFwiYXJyb3dCb3R0b21cIiwgc2hvd09uVG9wKTtcbiAgICAgICAgICAgIGlmIChzZWxmLmNvbmZpZy5pbmxpbmUpXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgdmFyIGxlZnQgPSB3aW5kb3cucGFnZVhPZmZzZXQgK1xuICAgICAgICAgICAgICAgIGlucHV0Qm91bmRzLmxlZnQgLVxuICAgICAgICAgICAgICAgIChjb25maWdQb3NIb3Jpem9udGFsICE9IG51bGwgJiYgY29uZmlnUG9zSG9yaXpvbnRhbCA9PT0gXCJjZW50ZXJcIlxuICAgICAgICAgICAgICAgICAgICA/IChjYWxlbmRhcldpZHRoIC0gaW5wdXRCb3VuZHMud2lkdGgpIC8gMlxuICAgICAgICAgICAgICAgICAgICA6IDApO1xuICAgICAgICAgICAgdmFyIHJpZ2h0ID0gd2luZG93LmRvY3VtZW50LmJvZHkub2Zmc2V0V2lkdGggLSBpbnB1dEJvdW5kcy5yaWdodDtcbiAgICAgICAgICAgIHZhciByaWdodE1vc3QgPSBsZWZ0ICsgY2FsZW5kYXJXaWR0aCA+IHdpbmRvdy5kb2N1bWVudC5ib2R5Lm9mZnNldFdpZHRoO1xuICAgICAgICAgICAgdmFyIGNlbnRlck1vc3QgPSByaWdodCArIGNhbGVuZGFyV2lkdGggPiB3aW5kb3cuZG9jdW1lbnQuYm9keS5vZmZzZXRXaWR0aDtcbiAgICAgICAgICAgIHRvZ2dsZUNsYXNzKHNlbGYuY2FsZW5kYXJDb250YWluZXIsIFwicmlnaHRNb3N0XCIsIHJpZ2h0TW9zdCk7XG4gICAgICAgICAgICBpZiAoc2VsZi5jb25maWcuc3RhdGljKVxuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIHNlbGYuY2FsZW5kYXJDb250YWluZXIuc3R5bGUudG9wID0gdG9wICsgXCJweFwiO1xuICAgICAgICAgICAgaWYgKCFyaWdodE1vc3QpIHtcbiAgICAgICAgICAgICAgICBzZWxmLmNhbGVuZGFyQ29udGFpbmVyLnN0eWxlLmxlZnQgPSBsZWZ0ICsgXCJweFwiO1xuICAgICAgICAgICAgICAgIHNlbGYuY2FsZW5kYXJDb250YWluZXIuc3R5bGUucmlnaHQgPSBcImF1dG9cIjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKCFjZW50ZXJNb3N0KSB7XG4gICAgICAgICAgICAgICAgc2VsZi5jYWxlbmRhckNvbnRhaW5lci5zdHlsZS5sZWZ0ID0gXCJhdXRvXCI7XG4gICAgICAgICAgICAgICAgc2VsZi5jYWxlbmRhckNvbnRhaW5lci5zdHlsZS5yaWdodCA9IHJpZ2h0ICsgXCJweFwiO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdmFyIGRvYyA9IGRvY3VtZW50LnN0eWxlU2hlZXRzWzBdO1xuICAgICAgICAgICAgICAgIC8vIHNvbWUgdGVzdGluZyBlbnZpcm9ubWVudHMgZG9uJ3QgaGF2ZSBjc3Mgc3VwcG9ydFxuICAgICAgICAgICAgICAgIGlmIChkb2MgPT09IHVuZGVmaW5lZClcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIHZhciBib2R5V2lkdGggPSB3aW5kb3cuZG9jdW1lbnQuYm9keS5vZmZzZXRXaWR0aDtcbiAgICAgICAgICAgICAgICB2YXIgY2VudGVyTGVmdCA9IE1hdGgubWF4KDAsIGJvZHlXaWR0aCAvIDIgLSBjYWxlbmRhcldpZHRoIC8gMik7XG4gICAgICAgICAgICAgICAgdmFyIGNlbnRlckJlZm9yZSA9IFwiLmZsYXRwaWNrci1jYWxlbmRhci5jZW50ZXJNb3N0OmJlZm9yZVwiO1xuICAgICAgICAgICAgICAgIHZhciBjZW50ZXJBZnRlciA9IFwiLmZsYXRwaWNrci1jYWxlbmRhci5jZW50ZXJNb3N0OmFmdGVyXCI7XG4gICAgICAgICAgICAgICAgdmFyIGNlbnRlckluZGV4ID0gZG9jLmNzc1J1bGVzLmxlbmd0aDtcbiAgICAgICAgICAgICAgICB2YXIgY2VudGVyU3R5bGUgPSBcIntsZWZ0OlwiICsgaW5wdXRCb3VuZHMubGVmdCArIFwicHg7cmlnaHQ6YXV0bzt9XCI7XG4gICAgICAgICAgICAgICAgdG9nZ2xlQ2xhc3Moc2VsZi5jYWxlbmRhckNvbnRhaW5lciwgXCJyaWdodE1vc3RcIiwgZmFsc2UpO1xuICAgICAgICAgICAgICAgIHRvZ2dsZUNsYXNzKHNlbGYuY2FsZW5kYXJDb250YWluZXIsIFwiY2VudGVyTW9zdFwiLCB0cnVlKTtcbiAgICAgICAgICAgICAgICBkb2MuaW5zZXJ0UnVsZShjZW50ZXJCZWZvcmUgKyBcIixcIiArIGNlbnRlckFmdGVyICsgY2VudGVyU3R5bGUsIGNlbnRlckluZGV4KTtcbiAgICAgICAgICAgICAgICBzZWxmLmNhbGVuZGFyQ29udGFpbmVyLnN0eWxlLmxlZnQgPSBjZW50ZXJMZWZ0ICsgXCJweFwiO1xuICAgICAgICAgICAgICAgIHNlbGYuY2FsZW5kYXJDb250YWluZXIuc3R5bGUucmlnaHQgPSBcImF1dG9cIjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiByZWRyYXcoKSB7XG4gICAgICAgICAgICBpZiAoc2VsZi5jb25maWcubm9DYWxlbmRhciB8fCBzZWxmLmlzTW9iaWxlKVxuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIHVwZGF0ZU5hdmlnYXRpb25DdXJyZW50TW9udGgoKTtcbiAgICAgICAgICAgIGJ1aWxkRGF5cygpO1xuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIGZvY3VzQW5kQ2xvc2UoKSB7XG4gICAgICAgICAgICBzZWxmLl9pbnB1dC5mb2N1cygpO1xuICAgICAgICAgICAgaWYgKHdpbmRvdy5uYXZpZ2F0b3IudXNlckFnZW50LmluZGV4T2YoXCJNU0lFXCIpICE9PSAtMSB8fFxuICAgICAgICAgICAgICAgIG5hdmlnYXRvci5tc01heFRvdWNoUG9pbnRzICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAvLyBoYWNrIC0gYnVncyBpbiB0aGUgd2F5IElFIGhhbmRsZXMgZm9jdXMga2VlcHMgdGhlIGNhbGVuZGFyIG9wZW5cbiAgICAgICAgICAgICAgICBzZXRUaW1lb3V0KHNlbGYuY2xvc2UsIDApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgc2VsZi5jbG9zZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIHNlbGVjdERhdGUoZSkge1xuICAgICAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgICAgZS5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICAgICAgICAgIHZhciBpc1NlbGVjdGFibGUgPSBmdW5jdGlvbiAoZGF5KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGRheS5jbGFzc0xpc3QgJiZcbiAgICAgICAgICAgICAgICAgICAgZGF5LmNsYXNzTGlzdC5jb250YWlucyhcImZsYXRwaWNrci1kYXlcIikgJiZcbiAgICAgICAgICAgICAgICAgICAgIWRheS5jbGFzc0xpc3QuY29udGFpbnMoXCJmbGF0cGlja3ItZGlzYWJsZWRcIikgJiZcbiAgICAgICAgICAgICAgICAgICAgIWRheS5jbGFzc0xpc3QuY29udGFpbnMoXCJub3RBbGxvd2VkXCIpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHZhciB0ID0gZmluZFBhcmVudChlLnRhcmdldCwgaXNTZWxlY3RhYmxlKTtcbiAgICAgICAgICAgIGlmICh0ID09PSB1bmRlZmluZWQpXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgdmFyIHRhcmdldCA9IHQ7XG4gICAgICAgICAgICB2YXIgc2VsZWN0ZWREYXRlID0gKHNlbGYubGF0ZXN0U2VsZWN0ZWREYXRlT2JqID0gbmV3IERhdGUodGFyZ2V0LmRhdGVPYmouZ2V0VGltZSgpKSk7XG4gICAgICAgICAgICB2YXIgc2hvdWxkQ2hhbmdlTW9udGggPSAoc2VsZWN0ZWREYXRlLmdldE1vbnRoKCkgPCBzZWxmLmN1cnJlbnRNb250aCB8fFxuICAgICAgICAgICAgICAgIHNlbGVjdGVkRGF0ZS5nZXRNb250aCgpID5cbiAgICAgICAgICAgICAgICAgICAgc2VsZi5jdXJyZW50TW9udGggKyBzZWxmLmNvbmZpZy5zaG93TW9udGhzIC0gMSkgJiZcbiAgICAgICAgICAgICAgICBzZWxmLmNvbmZpZy5tb2RlICE9PSBcInJhbmdlXCI7XG4gICAgICAgICAgICBzZWxmLnNlbGVjdGVkRGF0ZUVsZW0gPSB0YXJnZXQ7XG4gICAgICAgICAgICBpZiAoc2VsZi5jb25maWcubW9kZSA9PT0gXCJzaW5nbGVcIilcbiAgICAgICAgICAgICAgICBzZWxmLnNlbGVjdGVkRGF0ZXMgPSBbc2VsZWN0ZWREYXRlXTtcbiAgICAgICAgICAgIGVsc2UgaWYgKHNlbGYuY29uZmlnLm1vZGUgPT09IFwibXVsdGlwbGVcIikge1xuICAgICAgICAgICAgICAgIHZhciBzZWxlY3RlZEluZGV4ID0gaXNEYXRlU2VsZWN0ZWQoc2VsZWN0ZWREYXRlKTtcbiAgICAgICAgICAgICAgICBpZiAoc2VsZWN0ZWRJbmRleClcbiAgICAgICAgICAgICAgICAgICAgc2VsZi5zZWxlY3RlZERhdGVzLnNwbGljZShwYXJzZUludChzZWxlY3RlZEluZGV4KSwgMSk7XG4gICAgICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgICAgICBzZWxmLnNlbGVjdGVkRGF0ZXMucHVzaChzZWxlY3RlZERhdGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoc2VsZi5jb25maWcubW9kZSA9PT0gXCJyYW5nZVwiKSB7XG4gICAgICAgICAgICAgICAgaWYgKHNlbGYuc2VsZWN0ZWREYXRlcy5sZW5ndGggPT09IDIpIHtcbiAgICAgICAgICAgICAgICAgICAgc2VsZi5jbGVhcihmYWxzZSwgZmFsc2UpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBzZWxmLmxhdGVzdFNlbGVjdGVkRGF0ZU9iaiA9IHNlbGVjdGVkRGF0ZTtcbiAgICAgICAgICAgICAgICBzZWxmLnNlbGVjdGVkRGF0ZXMucHVzaChzZWxlY3RlZERhdGUpO1xuICAgICAgICAgICAgICAgIC8vIHVubGVzcyBzZWxlY3Rpbmcgc2FtZSBkYXRlIHR3aWNlLCBzb3J0IGFzY2VuZGluZ2x5XG4gICAgICAgICAgICAgICAgaWYgKGNvbXBhcmVEYXRlcyhzZWxlY3RlZERhdGUsIHNlbGYuc2VsZWN0ZWREYXRlc1swXSwgdHJ1ZSkgIT09IDApXG4gICAgICAgICAgICAgICAgICAgIHNlbGYuc2VsZWN0ZWREYXRlcy5zb3J0KGZ1bmN0aW9uIChhLCBiKSB7IHJldHVybiBhLmdldFRpbWUoKSAtIGIuZ2V0VGltZSgpOyB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHNldEhvdXJzRnJvbUlucHV0cygpO1xuICAgICAgICAgICAgaWYgKHNob3VsZENoYW5nZU1vbnRoKSB7XG4gICAgICAgICAgICAgICAgdmFyIGlzTmV3WWVhciA9IHNlbGYuY3VycmVudFllYXIgIT09IHNlbGVjdGVkRGF0ZS5nZXRGdWxsWWVhcigpO1xuICAgICAgICAgICAgICAgIHNlbGYuY3VycmVudFllYXIgPSBzZWxlY3RlZERhdGUuZ2V0RnVsbFllYXIoKTtcbiAgICAgICAgICAgICAgICBzZWxmLmN1cnJlbnRNb250aCA9IHNlbGVjdGVkRGF0ZS5nZXRNb250aCgpO1xuICAgICAgICAgICAgICAgIGlmIChpc05ld1llYXIpIHtcbiAgICAgICAgICAgICAgICAgICAgdHJpZ2dlckV2ZW50KFwib25ZZWFyQ2hhbmdlXCIpO1xuICAgICAgICAgICAgICAgICAgICBidWlsZE1vbnRoU3dpdGNoKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRyaWdnZXJFdmVudChcIm9uTW9udGhDaGFuZ2VcIik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB1cGRhdGVOYXZpZ2F0aW9uQ3VycmVudE1vbnRoKCk7XG4gICAgICAgICAgICBidWlsZERheXMoKTtcbiAgICAgICAgICAgIHVwZGF0ZVZhbHVlKCk7XG4gICAgICAgICAgICBpZiAoc2VsZi5jb25maWcuZW5hYmxlVGltZSlcbiAgICAgICAgICAgICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHsgcmV0dXJuIChzZWxmLnNob3dUaW1lSW5wdXQgPSB0cnVlKTsgfSwgNTApO1xuICAgICAgICAgICAgLy8gbWFpbnRhaW4gZm9jdXNcbiAgICAgICAgICAgIGlmICghc2hvdWxkQ2hhbmdlTW9udGggJiZcbiAgICAgICAgICAgICAgICBzZWxmLmNvbmZpZy5tb2RlICE9PSBcInJhbmdlXCIgJiZcbiAgICAgICAgICAgICAgICBzZWxmLmNvbmZpZy5zaG93TW9udGhzID09PSAxKVxuICAgICAgICAgICAgICAgIGZvY3VzT25EYXlFbGVtKHRhcmdldCk7XG4gICAgICAgICAgICBlbHNlIGlmIChzZWxmLnNlbGVjdGVkRGF0ZUVsZW0gIT09IHVuZGVmaW5lZCAmJlxuICAgICAgICAgICAgICAgIHNlbGYuaG91ckVsZW1lbnQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIHNlbGYuc2VsZWN0ZWREYXRlRWxlbSAmJiBzZWxmLnNlbGVjdGVkRGF0ZUVsZW0uZm9jdXMoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChzZWxmLmhvdXJFbGVtZW50ICE9PSB1bmRlZmluZWQpXG4gICAgICAgICAgICAgICAgc2VsZi5ob3VyRWxlbWVudCAhPT0gdW5kZWZpbmVkICYmIHNlbGYuaG91ckVsZW1lbnQuZm9jdXMoKTtcbiAgICAgICAgICAgIGlmIChzZWxmLmNvbmZpZy5jbG9zZU9uU2VsZWN0KSB7XG4gICAgICAgICAgICAgICAgdmFyIHNpbmdsZSA9IHNlbGYuY29uZmlnLm1vZGUgPT09IFwic2luZ2xlXCIgJiYgIXNlbGYuY29uZmlnLmVuYWJsZVRpbWU7XG4gICAgICAgICAgICAgICAgdmFyIHJhbmdlID0gc2VsZi5jb25maWcubW9kZSA9PT0gXCJyYW5nZVwiICYmXG4gICAgICAgICAgICAgICAgICAgIHNlbGYuc2VsZWN0ZWREYXRlcy5sZW5ndGggPT09IDIgJiZcbiAgICAgICAgICAgICAgICAgICAgIXNlbGYuY29uZmlnLmVuYWJsZVRpbWU7XG4gICAgICAgICAgICAgICAgaWYgKHNpbmdsZSB8fCByYW5nZSkge1xuICAgICAgICAgICAgICAgICAgICBmb2N1c0FuZENsb3NlKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdHJpZ2dlckNoYW5nZSgpO1xuICAgICAgICB9XG4gICAgICAgIHZhciBDQUxMQkFDS1MgPSB7XG4gICAgICAgICAgICBsb2NhbGU6IFtzZXR1cExvY2FsZSwgdXBkYXRlV2Vla2RheXNdLFxuICAgICAgICAgICAgc2hvd01vbnRoczogW2J1aWxkTW9udGhzLCBzZXRDYWxlbmRhcldpZHRoLCBidWlsZFdlZWtkYXlzXSxcbiAgICAgICAgICAgIG1pbkRhdGU6IFtqdW1wVG9EYXRlXSxcbiAgICAgICAgICAgIG1heERhdGU6IFtqdW1wVG9EYXRlXVxuICAgICAgICB9O1xuICAgICAgICBmdW5jdGlvbiBzZXQob3B0aW9uLCB2YWx1ZSkge1xuICAgICAgICAgICAgaWYgKG9wdGlvbiAhPT0gbnVsbCAmJiB0eXBlb2Ygb3B0aW9uID09PSBcIm9iamVjdFwiKSB7XG4gICAgICAgICAgICAgICAgT2JqZWN0LmFzc2lnbihzZWxmLmNvbmZpZywgb3B0aW9uKTtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBrZXkgaW4gb3B0aW9uKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChDQUxMQkFDS1Nba2V5XSAhPT0gdW5kZWZpbmVkKVxuICAgICAgICAgICAgICAgICAgICAgICAgQ0FMTEJBQ0tTW2tleV0uZm9yRWFjaChmdW5jdGlvbiAoeCkgeyByZXR1cm4geCgpOyB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBzZWxmLmNvbmZpZ1tvcHRpb25dID0gdmFsdWU7XG4gICAgICAgICAgICAgICAgaWYgKENBTExCQUNLU1tvcHRpb25dICE9PSB1bmRlZmluZWQpXG4gICAgICAgICAgICAgICAgICAgIENBTExCQUNLU1tvcHRpb25dLmZvckVhY2goZnVuY3Rpb24gKHgpIHsgcmV0dXJuIHgoKTsgfSk7XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoSE9PS1MuaW5kZXhPZihvcHRpb24pID4gLTEpXG4gICAgICAgICAgICAgICAgICAgIHNlbGYuY29uZmlnW29wdGlvbl0gPSBhcnJheWlmeSh2YWx1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBzZWxmLnJlZHJhdygpO1xuICAgICAgICAgICAgdXBkYXRlVmFsdWUoZmFsc2UpO1xuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIHNldFNlbGVjdGVkRGF0ZShpbnB1dERhdGUsIGZvcm1hdCkge1xuICAgICAgICAgICAgdmFyIGRhdGVzID0gW107XG4gICAgICAgICAgICBpZiAoaW5wdXREYXRlIGluc3RhbmNlb2YgQXJyYXkpXG4gICAgICAgICAgICAgICAgZGF0ZXMgPSBpbnB1dERhdGUubWFwKGZ1bmN0aW9uIChkKSB7IHJldHVybiBzZWxmLnBhcnNlRGF0ZShkLCBmb3JtYXQpOyB9KTtcbiAgICAgICAgICAgIGVsc2UgaWYgKGlucHV0RGF0ZSBpbnN0YW5jZW9mIERhdGUgfHwgdHlwZW9mIGlucHV0RGF0ZSA9PT0gXCJudW1iZXJcIilcbiAgICAgICAgICAgICAgICBkYXRlcyA9IFtzZWxmLnBhcnNlRGF0ZShpbnB1dERhdGUsIGZvcm1hdCldO1xuICAgICAgICAgICAgZWxzZSBpZiAodHlwZW9mIGlucHV0RGF0ZSA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgICAgICAgIHN3aXRjaCAoc2VsZi5jb25maWcubW9kZSkge1xuICAgICAgICAgICAgICAgICAgICBjYXNlIFwic2luZ2xlXCI6XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgXCJ0aW1lXCI6XG4gICAgICAgICAgICAgICAgICAgICAgICBkYXRlcyA9IFtzZWxmLnBhcnNlRGF0ZShpbnB1dERhdGUsIGZvcm1hdCldO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgXCJtdWx0aXBsZVwiOlxuICAgICAgICAgICAgICAgICAgICAgICAgZGF0ZXMgPSBpbnB1dERhdGVcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAuc3BsaXQoc2VsZi5jb25maWcuY29uanVuY3Rpb24pXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLm1hcChmdW5jdGlvbiAoZGF0ZSkgeyByZXR1cm4gc2VsZi5wYXJzZURhdGUoZGF0ZSwgZm9ybWF0KTsgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgY2FzZSBcInJhbmdlXCI6XG4gICAgICAgICAgICAgICAgICAgICAgICBkYXRlcyA9IGlucHV0RGF0ZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5zcGxpdChzZWxmLmwxMG4ucmFuZ2VTZXBhcmF0b3IpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLm1hcChmdW5jdGlvbiAoZGF0ZSkgeyByZXR1cm4gc2VsZi5wYXJzZURhdGUoZGF0ZSwgZm9ybWF0KTsgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICBzZWxmLmNvbmZpZy5lcnJvckhhbmRsZXIobmV3IEVycm9yKFwiSW52YWxpZCBkYXRlIHN1cHBsaWVkOiBcIiArIEpTT04uc3RyaW5naWZ5KGlucHV0RGF0ZSkpKTtcbiAgICAgICAgICAgIHNlbGYuc2VsZWN0ZWREYXRlcyA9IGRhdGVzLmZpbHRlcihmdW5jdGlvbiAoZCkgeyByZXR1cm4gZCBpbnN0YW5jZW9mIERhdGUgJiYgaXNFbmFibGVkKGQsIGZhbHNlKTsgfSk7XG4gICAgICAgICAgICBpZiAoc2VsZi5jb25maWcubW9kZSA9PT0gXCJyYW5nZVwiKVxuICAgICAgICAgICAgICAgIHNlbGYuc2VsZWN0ZWREYXRlcy5zb3J0KGZ1bmN0aW9uIChhLCBiKSB7IHJldHVybiBhLmdldFRpbWUoKSAtIGIuZ2V0VGltZSgpOyB9KTtcbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiBzZXREYXRlKGRhdGUsIHRyaWdnZXJDaGFuZ2UsIGZvcm1hdCkge1xuICAgICAgICAgICAgaWYgKHRyaWdnZXJDaGFuZ2UgPT09IHZvaWQgMCkgeyB0cmlnZ2VyQ2hhbmdlID0gZmFsc2U7IH1cbiAgICAgICAgICAgIGlmIChmb3JtYXQgPT09IHZvaWQgMCkgeyBmb3JtYXQgPSBzZWxmLmNvbmZpZy5kYXRlRm9ybWF0OyB9XG4gICAgICAgICAgICBpZiAoKGRhdGUgIT09IDAgJiYgIWRhdGUpIHx8IChkYXRlIGluc3RhbmNlb2YgQXJyYXkgJiYgZGF0ZS5sZW5ndGggPT09IDApKVxuICAgICAgICAgICAgICAgIHJldHVybiBzZWxmLmNsZWFyKHRyaWdnZXJDaGFuZ2UpO1xuICAgICAgICAgICAgc2V0U2VsZWN0ZWREYXRlKGRhdGUsIGZvcm1hdCk7XG4gICAgICAgICAgICBzZWxmLnNob3dUaW1lSW5wdXQgPSBzZWxmLnNlbGVjdGVkRGF0ZXMubGVuZ3RoID4gMDtcbiAgICAgICAgICAgIHNlbGYubGF0ZXN0U2VsZWN0ZWREYXRlT2JqID1cbiAgICAgICAgICAgICAgICBzZWxmLnNlbGVjdGVkRGF0ZXNbc2VsZi5zZWxlY3RlZERhdGVzLmxlbmd0aCAtIDFdO1xuICAgICAgICAgICAgc2VsZi5yZWRyYXcoKTtcbiAgICAgICAgICAgIGp1bXBUb0RhdGUoKTtcbiAgICAgICAgICAgIHNldEhvdXJzRnJvbURhdGUoKTtcbiAgICAgICAgICAgIGlmIChzZWxmLnNlbGVjdGVkRGF0ZXMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICAgICAgc2VsZi5jbGVhcihmYWxzZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB1cGRhdGVWYWx1ZSh0cmlnZ2VyQ2hhbmdlKTtcbiAgICAgICAgICAgIGlmICh0cmlnZ2VyQ2hhbmdlKVxuICAgICAgICAgICAgICAgIHRyaWdnZXJFdmVudChcIm9uQ2hhbmdlXCIpO1xuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIHBhcnNlRGF0ZVJ1bGVzKGFycikge1xuICAgICAgICAgICAgcmV0dXJuIGFyclxuICAgICAgICAgICAgICAgIC5zbGljZSgpXG4gICAgICAgICAgICAgICAgLm1hcChmdW5jdGlvbiAocnVsZSkge1xuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgcnVsZSA9PT0gXCJzdHJpbmdcIiB8fFxuICAgICAgICAgICAgICAgICAgICB0eXBlb2YgcnVsZSA9PT0gXCJudW1iZXJcIiB8fFxuICAgICAgICAgICAgICAgICAgICBydWxlIGluc3RhbmNlb2YgRGF0ZSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gc2VsZi5wYXJzZURhdGUocnVsZSwgdW5kZWZpbmVkLCB0cnVlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAocnVsZSAmJlxuICAgICAgICAgICAgICAgICAgICB0eXBlb2YgcnVsZSA9PT0gXCJvYmplY3RcIiAmJlxuICAgICAgICAgICAgICAgICAgICBydWxlLmZyb20gJiZcbiAgICAgICAgICAgICAgICAgICAgcnVsZS50bylcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZyb206IHNlbGYucGFyc2VEYXRlKHJ1bGUuZnJvbSwgdW5kZWZpbmVkKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHRvOiBzZWxmLnBhcnNlRGF0ZShydWxlLnRvLCB1bmRlZmluZWQpXG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJ1bGU7XG4gICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgIC5maWx0ZXIoZnVuY3Rpb24gKHgpIHsgcmV0dXJuIHg7IH0pOyAvLyByZW1vdmUgZmFsc3kgdmFsdWVzXG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gc2V0dXBEYXRlcygpIHtcbiAgICAgICAgICAgIHNlbGYuc2VsZWN0ZWREYXRlcyA9IFtdO1xuICAgICAgICAgICAgc2VsZi5ub3cgPSBzZWxmLnBhcnNlRGF0ZShzZWxmLmNvbmZpZy5ub3cpIHx8IG5ldyBEYXRlKCk7XG4gICAgICAgICAgICAvLyBXb3JrYXJvdW5kIElFMTEgc2V0dGluZyBwbGFjZWhvbGRlciBhcyB0aGUgaW5wdXQncyB2YWx1ZVxuICAgICAgICAgICAgdmFyIHByZWxvYWRlZERhdGUgPSBzZWxmLmNvbmZpZy5kZWZhdWx0RGF0ZSB8fFxuICAgICAgICAgICAgICAgICgoc2VsZi5pbnB1dC5ub2RlTmFtZSA9PT0gXCJJTlBVVFwiIHx8XG4gICAgICAgICAgICAgICAgICAgIHNlbGYuaW5wdXQubm9kZU5hbWUgPT09IFwiVEVYVEFSRUFcIikgJiZcbiAgICAgICAgICAgICAgICAgICAgc2VsZi5pbnB1dC5wbGFjZWhvbGRlciAmJlxuICAgICAgICAgICAgICAgICAgICBzZWxmLmlucHV0LnZhbHVlID09PSBzZWxmLmlucHV0LnBsYWNlaG9sZGVyXG4gICAgICAgICAgICAgICAgICAgID8gbnVsbFxuICAgICAgICAgICAgICAgICAgICA6IHNlbGYuaW5wdXQudmFsdWUpO1xuICAgICAgICAgICAgaWYgKHByZWxvYWRlZERhdGUpXG4gICAgICAgICAgICAgICAgc2V0U2VsZWN0ZWREYXRlKHByZWxvYWRlZERhdGUsIHNlbGYuY29uZmlnLmRhdGVGb3JtYXQpO1xuICAgICAgICAgICAgc2VsZi5faW5pdGlhbERhdGUgPVxuICAgICAgICAgICAgICAgIHNlbGYuc2VsZWN0ZWREYXRlcy5sZW5ndGggPiAwXG4gICAgICAgICAgICAgICAgICAgID8gc2VsZi5zZWxlY3RlZERhdGVzWzBdXG4gICAgICAgICAgICAgICAgICAgIDogc2VsZi5jb25maWcubWluRGF0ZSAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgc2VsZi5jb25maWcubWluRGF0ZS5nZXRUaW1lKCkgPiBzZWxmLm5vdy5nZXRUaW1lKClcbiAgICAgICAgICAgICAgICAgICAgICAgID8gc2VsZi5jb25maWcubWluRGF0ZVxuICAgICAgICAgICAgICAgICAgICAgICAgOiBzZWxmLmNvbmZpZy5tYXhEYXRlICYmXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc2VsZi5jb25maWcubWF4RGF0ZS5nZXRUaW1lKCkgPCBzZWxmLm5vdy5nZXRUaW1lKClcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA/IHNlbGYuY29uZmlnLm1heERhdGVcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA6IHNlbGYubm93O1xuICAgICAgICAgICAgc2VsZi5jdXJyZW50WWVhciA9IHNlbGYuX2luaXRpYWxEYXRlLmdldEZ1bGxZZWFyKCk7XG4gICAgICAgICAgICBzZWxmLmN1cnJlbnRNb250aCA9IHNlbGYuX2luaXRpYWxEYXRlLmdldE1vbnRoKCk7XG4gICAgICAgICAgICBpZiAoc2VsZi5zZWxlY3RlZERhdGVzLmxlbmd0aCA+IDApXG4gICAgICAgICAgICAgICAgc2VsZi5sYXRlc3RTZWxlY3RlZERhdGVPYmogPSBzZWxmLnNlbGVjdGVkRGF0ZXNbMF07XG4gICAgICAgICAgICBpZiAoc2VsZi5jb25maWcubWluVGltZSAhPT0gdW5kZWZpbmVkKVxuICAgICAgICAgICAgICAgIHNlbGYuY29uZmlnLm1pblRpbWUgPSBzZWxmLnBhcnNlRGF0ZShzZWxmLmNvbmZpZy5taW5UaW1lLCBcIkg6aVwiKTtcbiAgICAgICAgICAgIGlmIChzZWxmLmNvbmZpZy5tYXhUaW1lICE9PSB1bmRlZmluZWQpXG4gICAgICAgICAgICAgICAgc2VsZi5jb25maWcubWF4VGltZSA9IHNlbGYucGFyc2VEYXRlKHNlbGYuY29uZmlnLm1heFRpbWUsIFwiSDppXCIpO1xuICAgICAgICAgICAgc2VsZi5taW5EYXRlSGFzVGltZSA9XG4gICAgICAgICAgICAgICAgISFzZWxmLmNvbmZpZy5taW5EYXRlICYmXG4gICAgICAgICAgICAgICAgICAgIChzZWxmLmNvbmZpZy5taW5EYXRlLmdldEhvdXJzKCkgPiAwIHx8XG4gICAgICAgICAgICAgICAgICAgICAgICBzZWxmLmNvbmZpZy5taW5EYXRlLmdldE1pbnV0ZXMoKSA+IDAgfHxcbiAgICAgICAgICAgICAgICAgICAgICAgIHNlbGYuY29uZmlnLm1pbkRhdGUuZ2V0U2Vjb25kcygpID4gMCk7XG4gICAgICAgICAgICBzZWxmLm1heERhdGVIYXNUaW1lID1cbiAgICAgICAgICAgICAgICAhIXNlbGYuY29uZmlnLm1heERhdGUgJiZcbiAgICAgICAgICAgICAgICAgICAgKHNlbGYuY29uZmlnLm1heERhdGUuZ2V0SG91cnMoKSA+IDAgfHxcbiAgICAgICAgICAgICAgICAgICAgICAgIHNlbGYuY29uZmlnLm1heERhdGUuZ2V0TWludXRlcygpID4gMCB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgc2VsZi5jb25maWcubWF4RGF0ZS5nZXRTZWNvbmRzKCkgPiAwKTtcbiAgICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShzZWxmLCBcInNob3dUaW1lSW5wdXRcIiwge1xuICAgICAgICAgICAgICAgIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gc2VsZi5fc2hvd1RpbWVJbnB1dDsgfSxcbiAgICAgICAgICAgICAgICBzZXQ6IGZ1bmN0aW9uIChib29sKSB7XG4gICAgICAgICAgICAgICAgICAgIHNlbGYuX3Nob3dUaW1lSW5wdXQgPSBib29sO1xuICAgICAgICAgICAgICAgICAgICBpZiAoc2VsZi5jYWxlbmRhckNvbnRhaW5lcilcbiAgICAgICAgICAgICAgICAgICAgICAgIHRvZ2dsZUNsYXNzKHNlbGYuY2FsZW5kYXJDb250YWluZXIsIFwic2hvd1RpbWVJbnB1dFwiLCBib29sKTtcbiAgICAgICAgICAgICAgICAgICAgc2VsZi5pc09wZW4gJiYgcG9zaXRpb25DYWxlbmRhcigpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIHNldHVwSW5wdXRzKCkge1xuICAgICAgICAgICAgc2VsZi5pbnB1dCA9IHNlbGYuY29uZmlnLndyYXBcbiAgICAgICAgICAgICAgICA/IGVsZW1lbnQucXVlcnlTZWxlY3RvcihcIltkYXRhLWlucHV0XVwiKVxuICAgICAgICAgICAgICAgIDogZWxlbWVudDtcbiAgICAgICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG4gICAgICAgICAgICBpZiAoIXNlbGYuaW5wdXQpIHtcbiAgICAgICAgICAgICAgICBzZWxmLmNvbmZpZy5lcnJvckhhbmRsZXIobmV3IEVycm9yKFwiSW52YWxpZCBpbnB1dCBlbGVtZW50IHNwZWNpZmllZFwiKSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gaGFjazogc3RvcmUgcHJldmlvdXMgdHlwZSB0byByZXN0b3JlIGl0IGFmdGVyIGRlc3Ryb3koKVxuICAgICAgICAgICAgc2VsZi5pbnB1dC5fdHlwZSA9IHNlbGYuaW5wdXQudHlwZTtcbiAgICAgICAgICAgIHNlbGYuaW5wdXQudHlwZSA9IFwidGV4dFwiO1xuICAgICAgICAgICAgc2VsZi5pbnB1dC5jbGFzc0xpc3QuYWRkKFwiZmxhdHBpY2tyLWlucHV0XCIpO1xuICAgICAgICAgICAgc2VsZi5faW5wdXQgPSBzZWxmLmlucHV0O1xuICAgICAgICAgICAgaWYgKHNlbGYuY29uZmlnLmFsdElucHV0KSB7XG4gICAgICAgICAgICAgICAgLy8gcmVwbGljYXRlIHNlbGYuZWxlbWVudFxuICAgICAgICAgICAgICAgIHNlbGYuYWx0SW5wdXQgPSBjcmVhdGVFbGVtZW50KHNlbGYuaW5wdXQubm9kZU5hbWUsIHNlbGYuY29uZmlnLmFsdElucHV0Q2xhc3MpO1xuICAgICAgICAgICAgICAgIHNlbGYuX2lucHV0ID0gc2VsZi5hbHRJbnB1dDtcbiAgICAgICAgICAgICAgICBzZWxmLmFsdElucHV0LnBsYWNlaG9sZGVyID0gc2VsZi5pbnB1dC5wbGFjZWhvbGRlcjtcbiAgICAgICAgICAgICAgICBzZWxmLmFsdElucHV0LmRpc2FibGVkID0gc2VsZi5pbnB1dC5kaXNhYmxlZDtcbiAgICAgICAgICAgICAgICBzZWxmLmFsdElucHV0LnJlcXVpcmVkID0gc2VsZi5pbnB1dC5yZXF1aXJlZDtcbiAgICAgICAgICAgICAgICBzZWxmLmFsdElucHV0LnRhYkluZGV4ID0gc2VsZi5pbnB1dC50YWJJbmRleDtcbiAgICAgICAgICAgICAgICBzZWxmLmFsdElucHV0LnR5cGUgPSBcInRleHRcIjtcbiAgICAgICAgICAgICAgICBzZWxmLmlucHV0LnNldEF0dHJpYnV0ZShcInR5cGVcIiwgXCJoaWRkZW5cIik7XG4gICAgICAgICAgICAgICAgaWYgKCFzZWxmLmNvbmZpZy5zdGF0aWMgJiYgc2VsZi5pbnB1dC5wYXJlbnROb2RlKVxuICAgICAgICAgICAgICAgICAgICBzZWxmLmlucHV0LnBhcmVudE5vZGUuaW5zZXJ0QmVmb3JlKHNlbGYuYWx0SW5wdXQsIHNlbGYuaW5wdXQubmV4dFNpYmxpbmcpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCFzZWxmLmNvbmZpZy5hbGxvd0lucHV0KVxuICAgICAgICAgICAgICAgIHNlbGYuX2lucHV0LnNldEF0dHJpYnV0ZShcInJlYWRvbmx5XCIsIFwicmVhZG9ubHlcIik7XG4gICAgICAgICAgICBzZWxmLl9wb3NpdGlvbkVsZW1lbnQgPSBzZWxmLmNvbmZpZy5wb3NpdGlvbkVsZW1lbnQgfHwgc2VsZi5faW5wdXQ7XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gc2V0dXBNb2JpbGUoKSB7XG4gICAgICAgICAgICB2YXIgaW5wdXRUeXBlID0gc2VsZi5jb25maWcuZW5hYmxlVGltZVxuICAgICAgICAgICAgICAgID8gc2VsZi5jb25maWcubm9DYWxlbmRhclxuICAgICAgICAgICAgICAgICAgICA/IFwidGltZVwiXG4gICAgICAgICAgICAgICAgICAgIDogXCJkYXRldGltZS1sb2NhbFwiXG4gICAgICAgICAgICAgICAgOiBcImRhdGVcIjtcbiAgICAgICAgICAgIHNlbGYubW9iaWxlSW5wdXQgPSBjcmVhdGVFbGVtZW50KFwiaW5wdXRcIiwgc2VsZi5pbnB1dC5jbGFzc05hbWUgKyBcIiBmbGF0cGlja3ItbW9iaWxlXCIpO1xuICAgICAgICAgICAgc2VsZi5tb2JpbGVJbnB1dC5zdGVwID0gc2VsZi5pbnB1dC5nZXRBdHRyaWJ1dGUoXCJzdGVwXCIpIHx8IFwiYW55XCI7XG4gICAgICAgICAgICBzZWxmLm1vYmlsZUlucHV0LnRhYkluZGV4ID0gMTtcbiAgICAgICAgICAgIHNlbGYubW9iaWxlSW5wdXQudHlwZSA9IGlucHV0VHlwZTtcbiAgICAgICAgICAgIHNlbGYubW9iaWxlSW5wdXQuZGlzYWJsZWQgPSBzZWxmLmlucHV0LmRpc2FibGVkO1xuICAgICAgICAgICAgc2VsZi5tb2JpbGVJbnB1dC5yZXF1aXJlZCA9IHNlbGYuaW5wdXQucmVxdWlyZWQ7XG4gICAgICAgICAgICBzZWxmLm1vYmlsZUlucHV0LnBsYWNlaG9sZGVyID0gc2VsZi5pbnB1dC5wbGFjZWhvbGRlcjtcbiAgICAgICAgICAgIHNlbGYubW9iaWxlRm9ybWF0U3RyID1cbiAgICAgICAgICAgICAgICBpbnB1dFR5cGUgPT09IFwiZGF0ZXRpbWUtbG9jYWxcIlxuICAgICAgICAgICAgICAgICAgICA/IFwiWS1tLWRcXFxcVEg6aTpTXCJcbiAgICAgICAgICAgICAgICAgICAgOiBpbnB1dFR5cGUgPT09IFwiZGF0ZVwiXG4gICAgICAgICAgICAgICAgICAgICAgICA/IFwiWS1tLWRcIlxuICAgICAgICAgICAgICAgICAgICAgICAgOiBcIkg6aTpTXCI7XG4gICAgICAgICAgICBpZiAoc2VsZi5zZWxlY3RlZERhdGVzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICBzZWxmLm1vYmlsZUlucHV0LmRlZmF1bHRWYWx1ZSA9IHNlbGYubW9iaWxlSW5wdXQudmFsdWUgPSBzZWxmLmZvcm1hdERhdGUoc2VsZi5zZWxlY3RlZERhdGVzWzBdLCBzZWxmLm1vYmlsZUZvcm1hdFN0cik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoc2VsZi5jb25maWcubWluRGF0ZSlcbiAgICAgICAgICAgICAgICBzZWxmLm1vYmlsZUlucHV0Lm1pbiA9IHNlbGYuZm9ybWF0RGF0ZShzZWxmLmNvbmZpZy5taW5EYXRlLCBcIlktbS1kXCIpO1xuICAgICAgICAgICAgaWYgKHNlbGYuY29uZmlnLm1heERhdGUpXG4gICAgICAgICAgICAgICAgc2VsZi5tb2JpbGVJbnB1dC5tYXggPSBzZWxmLmZvcm1hdERhdGUoc2VsZi5jb25maWcubWF4RGF0ZSwgXCJZLW0tZFwiKTtcbiAgICAgICAgICAgIHNlbGYuaW5wdXQudHlwZSA9IFwiaGlkZGVuXCI7XG4gICAgICAgICAgICBpZiAoc2VsZi5hbHRJbnB1dCAhPT0gdW5kZWZpbmVkKVxuICAgICAgICAgICAgICAgIHNlbGYuYWx0SW5wdXQudHlwZSA9IFwiaGlkZGVuXCI7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIGlmIChzZWxmLmlucHV0LnBhcmVudE5vZGUpXG4gICAgICAgICAgICAgICAgICAgIHNlbGYuaW5wdXQucGFyZW50Tm9kZS5pbnNlcnRCZWZvcmUoc2VsZi5tb2JpbGVJbnB1dCwgc2VsZi5pbnB1dC5uZXh0U2libGluZyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoX2EpIHsgfVxuICAgICAgICAgICAgYmluZChzZWxmLm1vYmlsZUlucHV0LCBcImNoYW5nZVwiLCBmdW5jdGlvbiAoZSkge1xuICAgICAgICAgICAgICAgIHNlbGYuc2V0RGF0ZShlLnRhcmdldC52YWx1ZSwgZmFsc2UsIHNlbGYubW9iaWxlRm9ybWF0U3RyKTtcbiAgICAgICAgICAgICAgICB0cmlnZ2VyRXZlbnQoXCJvbkNoYW5nZVwiKTtcbiAgICAgICAgICAgICAgICB0cmlnZ2VyRXZlbnQoXCJvbkNsb3NlXCIpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gdG9nZ2xlKGUpIHtcbiAgICAgICAgICAgIGlmIChzZWxmLmlzT3BlbiA9PT0gdHJ1ZSlcbiAgICAgICAgICAgICAgICByZXR1cm4gc2VsZi5jbG9zZSgpO1xuICAgICAgICAgICAgc2VsZi5vcGVuKGUpO1xuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIHRyaWdnZXJFdmVudChldmVudCwgZGF0YSkge1xuICAgICAgICAgICAgLy8gSWYgdGhlIGluc3RhbmNlIGhhcyBiZWVuIGRlc3Ryb3llZCBhbHJlYWR5LCBhbGwgaG9va3MgaGF2ZSBiZWVuIHJlbW92ZWRcbiAgICAgICAgICAgIGlmIChzZWxmLmNvbmZpZyA9PT0gdW5kZWZpbmVkKVxuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIHZhciBob29rcyA9IHNlbGYuY29uZmlnW2V2ZW50XTtcbiAgICAgICAgICAgIGlmIChob29rcyAhPT0gdW5kZWZpbmVkICYmIGhvb2tzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaG9va3NbaV0gJiYgaSA8IGhvb2tzLmxlbmd0aDsgaSsrKVxuICAgICAgICAgICAgICAgICAgICBob29rc1tpXShzZWxmLnNlbGVjdGVkRGF0ZXMsIHNlbGYuaW5wdXQudmFsdWUsIHNlbGYsIGRhdGEpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGV2ZW50ID09PSBcIm9uQ2hhbmdlXCIpIHtcbiAgICAgICAgICAgICAgICBzZWxmLmlucHV0LmRpc3BhdGNoRXZlbnQoY3JlYXRlRXZlbnQoXCJjaGFuZ2VcIikpO1xuICAgICAgICAgICAgICAgIC8vIG1hbnkgZnJvbnQtZW5kIGZyYW1ld29ya3MgYmluZCB0byB0aGUgaW5wdXQgZXZlbnRcbiAgICAgICAgICAgICAgICBzZWxmLmlucHV0LmRpc3BhdGNoRXZlbnQoY3JlYXRlRXZlbnQoXCJpbnB1dFwiKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gY3JlYXRlRXZlbnQobmFtZSkge1xuICAgICAgICAgICAgdmFyIGUgPSBkb2N1bWVudC5jcmVhdGVFdmVudChcIkV2ZW50XCIpO1xuICAgICAgICAgICAgZS5pbml0RXZlbnQobmFtZSwgdHJ1ZSwgdHJ1ZSk7XG4gICAgICAgICAgICByZXR1cm4gZTtcbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiBpc0RhdGVTZWxlY3RlZChkYXRlKSB7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHNlbGYuc2VsZWN0ZWREYXRlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIGlmIChjb21wYXJlRGF0ZXMoc2VsZi5zZWxlY3RlZERhdGVzW2ldLCBkYXRlKSA9PT0gMClcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFwiXCIgKyBpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIGlzRGF0ZUluUmFuZ2UoZGF0ZSkge1xuICAgICAgICAgICAgaWYgKHNlbGYuY29uZmlnLm1vZGUgIT09IFwicmFuZ2VcIiB8fCBzZWxmLnNlbGVjdGVkRGF0ZXMubGVuZ3RoIDwgMilcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICByZXR1cm4gKGNvbXBhcmVEYXRlcyhkYXRlLCBzZWxmLnNlbGVjdGVkRGF0ZXNbMF0pID49IDAgJiZcbiAgICAgICAgICAgICAgICBjb21wYXJlRGF0ZXMoZGF0ZSwgc2VsZi5zZWxlY3RlZERhdGVzWzFdKSA8PSAwKTtcbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiB1cGRhdGVOYXZpZ2F0aW9uQ3VycmVudE1vbnRoKCkge1xuICAgICAgICAgICAgaWYgKHNlbGYuY29uZmlnLm5vQ2FsZW5kYXIgfHwgc2VsZi5pc01vYmlsZSB8fCAhc2VsZi5tb250aE5hdilcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICBzZWxmLnllYXJFbGVtZW50cy5mb3JFYWNoKGZ1bmN0aW9uICh5ZWFyRWxlbWVudCwgaSkge1xuICAgICAgICAgICAgICAgIHZhciBkID0gbmV3IERhdGUoc2VsZi5jdXJyZW50WWVhciwgc2VsZi5jdXJyZW50TW9udGgsIDEpO1xuICAgICAgICAgICAgICAgIGQuc2V0TW9udGgoc2VsZi5jdXJyZW50TW9udGggKyBpKTtcbiAgICAgICAgICAgICAgICBpZiAoc2VsZi5jb25maWcuc2hvd01vbnRocyA+IDEgfHxcbiAgICAgICAgICAgICAgICAgICAgc2VsZi5jb25maWcubW9udGhTZWxlY3RvclR5cGUgPT09IFwic3RhdGljXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgc2VsZi5tb250aEVsZW1lbnRzW2ldLnRleHRDb250ZW50ID1cbiAgICAgICAgICAgICAgICAgICAgICAgIG1vbnRoVG9TdHIoZC5nZXRNb250aCgpLCBzZWxmLmNvbmZpZy5zaG9ydGhhbmRDdXJyZW50TW9udGgsIHNlbGYubDEwbikgKyBcIiBcIjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHNlbGYubW9udGhzRHJvcGRvd25Db250YWluZXIudmFsdWUgPSBkLmdldE1vbnRoKCkudG9TdHJpbmcoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgeWVhckVsZW1lbnQudmFsdWUgPSBkLmdldEZ1bGxZZWFyKCkudG9TdHJpbmcoKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgc2VsZi5faGlkZVByZXZNb250aEFycm93ID1cbiAgICAgICAgICAgICAgICBzZWxmLmNvbmZpZy5taW5EYXRlICE9PSB1bmRlZmluZWQgJiZcbiAgICAgICAgICAgICAgICAgICAgKHNlbGYuY3VycmVudFllYXIgPT09IHNlbGYuY29uZmlnLm1pbkRhdGUuZ2V0RnVsbFllYXIoKVxuICAgICAgICAgICAgICAgICAgICAgICAgPyBzZWxmLmN1cnJlbnRNb250aCA8PSBzZWxmLmNvbmZpZy5taW5EYXRlLmdldE1vbnRoKClcbiAgICAgICAgICAgICAgICAgICAgICAgIDogc2VsZi5jdXJyZW50WWVhciA8IHNlbGYuY29uZmlnLm1pbkRhdGUuZ2V0RnVsbFllYXIoKSk7XG4gICAgICAgICAgICBzZWxmLl9oaWRlTmV4dE1vbnRoQXJyb3cgPVxuICAgICAgICAgICAgICAgIHNlbGYuY29uZmlnLm1heERhdGUgIT09IHVuZGVmaW5lZCAmJlxuICAgICAgICAgICAgICAgICAgICAoc2VsZi5jdXJyZW50WWVhciA9PT0gc2VsZi5jb25maWcubWF4RGF0ZS5nZXRGdWxsWWVhcigpXG4gICAgICAgICAgICAgICAgICAgICAgICA/IHNlbGYuY3VycmVudE1vbnRoICsgMSA+IHNlbGYuY29uZmlnLm1heERhdGUuZ2V0TW9udGgoKVxuICAgICAgICAgICAgICAgICAgICAgICAgOiBzZWxmLmN1cnJlbnRZZWFyID4gc2VsZi5jb25maWcubWF4RGF0ZS5nZXRGdWxsWWVhcigpKTtcbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiBnZXREYXRlU3RyKGZvcm1hdCkge1xuICAgICAgICAgICAgcmV0dXJuIHNlbGYuc2VsZWN0ZWREYXRlc1xuICAgICAgICAgICAgICAgIC5tYXAoZnVuY3Rpb24gKGRPYmopIHsgcmV0dXJuIHNlbGYuZm9ybWF0RGF0ZShkT2JqLCBmb3JtYXQpOyB9KVxuICAgICAgICAgICAgICAgIC5maWx0ZXIoZnVuY3Rpb24gKGQsIGksIGFycikge1xuICAgICAgICAgICAgICAgIHJldHVybiBzZWxmLmNvbmZpZy5tb2RlICE9PSBcInJhbmdlXCIgfHxcbiAgICAgICAgICAgICAgICAgICAgc2VsZi5jb25maWcuZW5hYmxlVGltZSB8fFxuICAgICAgICAgICAgICAgICAgICBhcnIuaW5kZXhPZihkKSA9PT0gaTtcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgLmpvaW4oc2VsZi5jb25maWcubW9kZSAhPT0gXCJyYW5nZVwiXG4gICAgICAgICAgICAgICAgPyBzZWxmLmNvbmZpZy5jb25qdW5jdGlvblxuICAgICAgICAgICAgICAgIDogc2VsZi5sMTBuLnJhbmdlU2VwYXJhdG9yKTtcbiAgICAgICAgfVxuICAgICAgICAvKipcbiAgICAgICAgICogVXBkYXRlcyB0aGUgdmFsdWVzIG9mIGlucHV0cyBhc3NvY2lhdGVkIHdpdGggdGhlIGNhbGVuZGFyXG4gICAgICAgICAqL1xuICAgICAgICBmdW5jdGlvbiB1cGRhdGVWYWx1ZSh0cmlnZ2VyQ2hhbmdlKSB7XG4gICAgICAgICAgICBpZiAodHJpZ2dlckNoYW5nZSA9PT0gdm9pZCAwKSB7IHRyaWdnZXJDaGFuZ2UgPSB0cnVlOyB9XG4gICAgICAgICAgICBpZiAoc2VsZi5tb2JpbGVJbnB1dCAhPT0gdW5kZWZpbmVkICYmIHNlbGYubW9iaWxlRm9ybWF0U3RyKSB7XG4gICAgICAgICAgICAgICAgc2VsZi5tb2JpbGVJbnB1dC52YWx1ZSA9XG4gICAgICAgICAgICAgICAgICAgIHNlbGYubGF0ZXN0U2VsZWN0ZWREYXRlT2JqICE9PSB1bmRlZmluZWRcbiAgICAgICAgICAgICAgICAgICAgICAgID8gc2VsZi5mb3JtYXREYXRlKHNlbGYubGF0ZXN0U2VsZWN0ZWREYXRlT2JqLCBzZWxmLm1vYmlsZUZvcm1hdFN0cilcbiAgICAgICAgICAgICAgICAgICAgICAgIDogXCJcIjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHNlbGYuaW5wdXQudmFsdWUgPSBnZXREYXRlU3RyKHNlbGYuY29uZmlnLmRhdGVGb3JtYXQpO1xuICAgICAgICAgICAgaWYgKHNlbGYuYWx0SW5wdXQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIHNlbGYuYWx0SW5wdXQudmFsdWUgPSBnZXREYXRlU3RyKHNlbGYuY29uZmlnLmFsdEZvcm1hdCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodHJpZ2dlckNoYW5nZSAhPT0gZmFsc2UpXG4gICAgICAgICAgICAgICAgdHJpZ2dlckV2ZW50KFwib25WYWx1ZVVwZGF0ZVwiKTtcbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiBvbk1vbnRoTmF2Q2xpY2soZSkge1xuICAgICAgICAgICAgdmFyIGlzUHJldk1vbnRoID0gc2VsZi5wcmV2TW9udGhOYXYuY29udGFpbnMoZS50YXJnZXQpO1xuICAgICAgICAgICAgdmFyIGlzTmV4dE1vbnRoID0gc2VsZi5uZXh0TW9udGhOYXYuY29udGFpbnMoZS50YXJnZXQpO1xuICAgICAgICAgICAgaWYgKGlzUHJldk1vbnRoIHx8IGlzTmV4dE1vbnRoKSB7XG4gICAgICAgICAgICAgICAgY2hhbmdlTW9udGgoaXNQcmV2TW9udGggPyAtMSA6IDEpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoc2VsZi55ZWFyRWxlbWVudHMuaW5kZXhPZihlLnRhcmdldCkgPj0gMCkge1xuICAgICAgICAgICAgICAgIGUudGFyZ2V0LnNlbGVjdCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoZS50YXJnZXQuY2xhc3NMaXN0LmNvbnRhaW5zKFwiYXJyb3dVcFwiKSkge1xuICAgICAgICAgICAgICAgIHNlbGYuY2hhbmdlWWVhcihzZWxmLmN1cnJlbnRZZWFyICsgMSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChlLnRhcmdldC5jbGFzc0xpc3QuY29udGFpbnMoXCJhcnJvd0Rvd25cIikpIHtcbiAgICAgICAgICAgICAgICBzZWxmLmNoYW5nZVllYXIoc2VsZi5jdXJyZW50WWVhciAtIDEpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIHRpbWVXcmFwcGVyKGUpIHtcbiAgICAgICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICAgIHZhciBpc0tleURvd24gPSBlLnR5cGUgPT09IFwia2V5ZG93blwiLCBpbnB1dCA9IGUudGFyZ2V0O1xuICAgICAgICAgICAgaWYgKHNlbGYuYW1QTSAhPT0gdW5kZWZpbmVkICYmIGUudGFyZ2V0ID09PSBzZWxmLmFtUE0pIHtcbiAgICAgICAgICAgICAgICBzZWxmLmFtUE0udGV4dENvbnRlbnQgPVxuICAgICAgICAgICAgICAgICAgICBzZWxmLmwxMG4uYW1QTVtpbnQoc2VsZi5hbVBNLnRleHRDb250ZW50ID09PSBzZWxmLmwxMG4uYW1QTVswXSldO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIG1pbiA9IHBhcnNlRmxvYXQoaW5wdXQuZ2V0QXR0cmlidXRlKFwibWluXCIpKSwgbWF4ID0gcGFyc2VGbG9hdChpbnB1dC5nZXRBdHRyaWJ1dGUoXCJtYXhcIikpLCBzdGVwID0gcGFyc2VGbG9hdChpbnB1dC5nZXRBdHRyaWJ1dGUoXCJzdGVwXCIpKSwgY3VyVmFsdWUgPSBwYXJzZUludChpbnB1dC52YWx1ZSwgMTApLCBkZWx0YSA9IGUuZGVsdGEgfHxcbiAgICAgICAgICAgICAgICAoaXNLZXlEb3duID8gKGUud2hpY2ggPT09IDM4ID8gMSA6IC0xKSA6IDApO1xuICAgICAgICAgICAgdmFyIG5ld1ZhbHVlID0gY3VyVmFsdWUgKyBzdGVwICogZGVsdGE7XG4gICAgICAgICAgICBpZiAodHlwZW9mIGlucHV0LnZhbHVlICE9PSBcInVuZGVmaW5lZFwiICYmIGlucHV0LnZhbHVlLmxlbmd0aCA9PT0gMikge1xuICAgICAgICAgICAgICAgIHZhciBpc0hvdXJFbGVtID0gaW5wdXQgPT09IHNlbGYuaG91ckVsZW1lbnQsIGlzTWludXRlRWxlbSA9IGlucHV0ID09PSBzZWxmLm1pbnV0ZUVsZW1lbnQ7XG4gICAgICAgICAgICAgICAgaWYgKG5ld1ZhbHVlIDwgbWluKSB7XG4gICAgICAgICAgICAgICAgICAgIG5ld1ZhbHVlID1cbiAgICAgICAgICAgICAgICAgICAgICAgIG1heCArXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbmV3VmFsdWUgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGludCghaXNIb3VyRWxlbSkgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIChpbnQoaXNIb3VyRWxlbSkgJiYgaW50KCFzZWxmLmFtUE0pKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGlzTWludXRlRWxlbSlcbiAgICAgICAgICAgICAgICAgICAgICAgIGluY3JlbWVudE51bUlucHV0KHVuZGVmaW5lZCwgLTEsIHNlbGYuaG91ckVsZW1lbnQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmIChuZXdWYWx1ZSA+IG1heCkge1xuICAgICAgICAgICAgICAgICAgICBuZXdWYWx1ZSA9XG4gICAgICAgICAgICAgICAgICAgICAgICBpbnB1dCA9PT0gc2VsZi5ob3VyRWxlbWVudCA/IG5ld1ZhbHVlIC0gbWF4IC0gaW50KCFzZWxmLmFtUE0pIDogbWluO1xuICAgICAgICAgICAgICAgICAgICBpZiAoaXNNaW51dGVFbGVtKVxuICAgICAgICAgICAgICAgICAgICAgICAgaW5jcmVtZW50TnVtSW5wdXQodW5kZWZpbmVkLCAxLCBzZWxmLmhvdXJFbGVtZW50KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHNlbGYuYW1QTSAmJlxuICAgICAgICAgICAgICAgICAgICBpc0hvdXJFbGVtICYmXG4gICAgICAgICAgICAgICAgICAgIChzdGVwID09PSAxXG4gICAgICAgICAgICAgICAgICAgICAgICA/IG5ld1ZhbHVlICsgY3VyVmFsdWUgPT09IDIzXG4gICAgICAgICAgICAgICAgICAgICAgICA6IE1hdGguYWJzKG5ld1ZhbHVlIC0gY3VyVmFsdWUpID4gc3RlcCkpIHtcbiAgICAgICAgICAgICAgICAgICAgc2VsZi5hbVBNLnRleHRDb250ZW50ID1cbiAgICAgICAgICAgICAgICAgICAgICAgIHNlbGYubDEwbi5hbVBNW2ludChzZWxmLmFtUE0udGV4dENvbnRlbnQgPT09IHNlbGYubDEwbi5hbVBNWzBdKV07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlucHV0LnZhbHVlID0gcGFkKG5ld1ZhbHVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpbml0KCk7XG4gICAgICAgIHJldHVybiBzZWxmO1xuICAgIH1cbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuICAgIGZ1bmN0aW9uIF9mbGF0cGlja3Iobm9kZUxpc3QsIGNvbmZpZykge1xuICAgICAgICAvLyBzdGF0aWMgbGlzdFxuICAgICAgICB2YXIgbm9kZXMgPSBBcnJheS5wcm90b3R5cGUuc2xpY2VcbiAgICAgICAgICAgIC5jYWxsKG5vZGVMaXN0KVxuICAgICAgICAgICAgLmZpbHRlcihmdW5jdGlvbiAoeCkgeyByZXR1cm4geCBpbnN0YW5jZW9mIEhUTUxFbGVtZW50OyB9KTtcbiAgICAgICAgdmFyIGluc3RhbmNlcyA9IFtdO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG5vZGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICB2YXIgbm9kZSA9IG5vZGVzW2ldO1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBpZiAobm9kZS5nZXRBdHRyaWJ1dGUoXCJkYXRhLWZwLW9taXRcIikgIT09IG51bGwpXG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIGlmIChub2RlLl9mbGF0cGlja3IgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICBub2RlLl9mbGF0cGlja3IuZGVzdHJveSgpO1xuICAgICAgICAgICAgICAgICAgICBub2RlLl9mbGF0cGlja3IgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIG5vZGUuX2ZsYXRwaWNrciA9IEZsYXRwaWNrckluc3RhbmNlKG5vZGUsIGNvbmZpZyB8fCB7fSk7XG4gICAgICAgICAgICAgICAgaW5zdGFuY2VzLnB1c2gobm9kZS5fZmxhdHBpY2tyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgY29uc29sZS5lcnJvcihlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gaW5zdGFuY2VzLmxlbmd0aCA9PT0gMSA/IGluc3RhbmNlc1swXSA6IGluc3RhbmNlcztcbiAgICB9XG4gICAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbiAgICBpZiAodHlwZW9mIEhUTUxFbGVtZW50ICE9PSBcInVuZGVmaW5lZFwiICYmXG4gICAgICAgIHR5cGVvZiBIVE1MQ29sbGVjdGlvbiAhPT0gXCJ1bmRlZmluZWRcIiAmJlxuICAgICAgICB0eXBlb2YgTm9kZUxpc3QgIT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgICAgLy8gYnJvd3NlciBlbnZcbiAgICAgICAgSFRNTENvbGxlY3Rpb24ucHJvdG90eXBlLmZsYXRwaWNrciA9IE5vZGVMaXN0LnByb3RvdHlwZS5mbGF0cGlja3IgPSBmdW5jdGlvbiAoY29uZmlnKSB7XG4gICAgICAgICAgICByZXR1cm4gX2ZsYXRwaWNrcih0aGlzLCBjb25maWcpO1xuICAgICAgICB9O1xuICAgICAgICBIVE1MRWxlbWVudC5wcm90b3R5cGUuZmxhdHBpY2tyID0gZnVuY3Rpb24gKGNvbmZpZykge1xuICAgICAgICAgICAgcmV0dXJuIF9mbGF0cGlja3IoW3RoaXNdLCBjb25maWcpO1xuICAgICAgICB9O1xuICAgIH1cbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuICAgIHZhciBmbGF0cGlja3IgPSBmdW5jdGlvbiAoc2VsZWN0b3IsIGNvbmZpZykge1xuICAgICAgICBpZiAodHlwZW9mIHNlbGVjdG9yID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgICByZXR1cm4gX2ZsYXRwaWNrcih3aW5kb3cuZG9jdW1lbnQucXVlcnlTZWxlY3RvckFsbChzZWxlY3RvciksIGNvbmZpZyk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoc2VsZWN0b3IgaW5zdGFuY2VvZiBOb2RlKSB7XG4gICAgICAgICAgICByZXR1cm4gX2ZsYXRwaWNrcihbc2VsZWN0b3JdLCBjb25maWcpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIF9mbGF0cGlja3Ioc2VsZWN0b3IsIGNvbmZpZyk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG4gICAgZmxhdHBpY2tyLmRlZmF1bHRDb25maWcgPSB7fTtcbiAgICBmbGF0cGlja3IubDEwbnMgPSB7XG4gICAgICAgIGVuOiBfX2Fzc2lnbih7fSwgZW5nbGlzaCksXG4gICAgICAgIFwiZGVmYXVsdFwiOiBfX2Fzc2lnbih7fSwgZW5nbGlzaClcbiAgICB9O1xuICAgIGZsYXRwaWNrci5sb2NhbGl6ZSA9IGZ1bmN0aW9uIChsMTBuKSB7XG4gICAgICAgIGZsYXRwaWNrci5sMTBuc1tcImRlZmF1bHRcIl0gPSBfX2Fzc2lnbih7fSwgZmxhdHBpY2tyLmwxMG5zW1wiZGVmYXVsdFwiXSwgbDEwbik7XG4gICAgfTtcbiAgICBmbGF0cGlja3Iuc2V0RGVmYXVsdHMgPSBmdW5jdGlvbiAoY29uZmlnKSB7XG4gICAgICAgIGZsYXRwaWNrci5kZWZhdWx0Q29uZmlnID0gX19hc3NpZ24oe30sIGZsYXRwaWNrci5kZWZhdWx0Q29uZmlnLCBjb25maWcpO1xuICAgIH07XG4gICAgZmxhdHBpY2tyLnBhcnNlRGF0ZSA9IGNyZWF0ZURhdGVQYXJzZXIoe30pO1xuICAgIGZsYXRwaWNrci5mb3JtYXREYXRlID0gY3JlYXRlRGF0ZUZvcm1hdHRlcih7fSk7XG4gICAgZmxhdHBpY2tyLmNvbXBhcmVEYXRlcyA9IGNvbXBhcmVEYXRlcztcbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuICAgIGlmICh0eXBlb2YgalF1ZXJ5ICE9PSBcInVuZGVmaW5lZFwiICYmIHR5cGVvZiBqUXVlcnkuZm4gIT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgICAgalF1ZXJ5LmZuLmZsYXRwaWNrciA9IGZ1bmN0aW9uIChjb25maWcpIHtcbiAgICAgICAgICAgIHJldHVybiBfZmxhdHBpY2tyKHRoaXMsIGNvbmZpZyk7XG4gICAgICAgIH07XG4gICAgfVxuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvY2FtZWxjYXNlXG4gICAgRGF0ZS5wcm90b3R5cGUuZnBfaW5jciA9IGZ1bmN0aW9uIChkYXlzKSB7XG4gICAgICAgIHJldHVybiBuZXcgRGF0ZSh0aGlzLmdldEZ1bGxZZWFyKCksIHRoaXMuZ2V0TW9udGgoKSwgdGhpcy5nZXREYXRlKCkgKyAodHlwZW9mIGRheXMgPT09IFwic3RyaW5nXCIgPyBwYXJzZUludChkYXlzLCAxMCkgOiBkYXlzKSk7XG4gICAgfTtcbiAgICBpZiAodHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgICB3aW5kb3cuZmxhdHBpY2tyID0gZmxhdHBpY2tyO1xuICAgIH1cblxuICAgIHJldHVybiBmbGF0cGlja3I7XG5cbn0pKTtcbiJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///cf06\n')},fe7f:function(module,exports,__webpack_require__){eval("// extracted by mini-css-extract-plugin//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZHJvcGlmeS9kaXN0L2Nzcy9kcm9waWZ5LmNzcz9iYmFjIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBIiwiZmlsZSI6ImZlN2YuanMiLCJzb3VyY2VzQ29udGVudCI6WyIvLyBleHRyYWN0ZWQgYnkgbWluaS1jc3MtZXh0cmFjdC1wbHVnaW4iXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///fe7f\n")}}]);